var Hermes = function(e){ 'use strict';const t = { FilterCreate: 'filter-create', FilterMove: 'filter-move', FilterResizeAfter: 'filter-resize-after', FilterResizeBefore: 'filter-resize-before', LabelMove: 'label-move', None: 'none' }, i = { AxisEvenlySpaced: 'axis-evenly-spaced', Equidistant: 'equidistant' }, s = { Categorical: 'categorical', Linear: 'linear', Logarithmic: 'logarithmic' }, a = { Horizontal: 'horizontal', Vertical: 'vertical' }, n = { DimensionAxis: 'dimension-axis', DimensionLabel: 'dimension-label', Filter: 'filter', FilterResize: 'filter-resize' }, l = { After: 'after', Before: 'before' }, o = { Bezier: 'bezier', Straight: 'straight' }, r = Number.NaN, h = { x: Number.NaN, y: Number.NaN }, c = { h: Number.NaN, w: Number.NaN, x: Number.NaN, y: Number.NaN }, d = { dimIndex: -1, p0: h, p1: h, type: t.None }, u = 'normal 12px san-serif', g = 'butt', p = 'round', f = 10, m = 'black', x = { debug: !1, direction: a.Horizontal, hooks: {}, interactions: { throttleDelayMouseMove: 50, throttleDelayResize: 50 }, style: { axes: { axis: { boundaryPadding: 15, lineWidth: 1, strokeStyle: 'rgba(147, 147, 147, 1.0)' }, axisActve: { lineWidth: 3, strokeStyle: 'rgba(99, 200, 255, 1.0)' }, axisHover: { lineWidth: 3, strokeStyle: 'rgba(79, 180, 246, 1.0)' }, filter: { cornerRadius: 2, fillStyle: 'rgba(235, 100, 200, 1.0)', strokeStyle: 'rgba(255, 255, 255, 1.0)', width: 4 }, filterActive: { cornerRadius: 3, fillStyle: 'rgba(255, 120, 220, 1.0)', width: 8 }, filterAxisHover: { cornerRadius: 2, fillStyle: 'rgba(235, 100, 200, 1.0)', width: 6 }, filterHover: { cornerRadius: 2, fillStyle: 'rgba(235, 100, 200, 1.0)', width: 8 }, label: { fillStyle: 'rgba(0, 0, 0, 1.0)', font: 'normal 11px sans-serif', lineWidth: 3, offset: 4, placement: l.After, strokeStyle: 'rgba(255, 255, 255, 1.0)' }, labelActive: { fillStyle: 'rgba(0, 0, 0, 1.0)' }, labelHover: { fillStyle: 'rgba(0, 0, 0, 1.0)' }, tick: { length: 4, lineWidth: 1, strokeStyle: 'rgba(147, 147, 147, 1.0)' }, tickActive: { strokeStyle: 'rgba(99, 200, 255, 1.0)' }, tickHover: { strokeStyle: 'rgba(79, 180, 246, 1.0)' } }, data: { default: { lineWidth: 1, strokeStyle: 'rgba(82, 144, 244, 1.0)' }, filtered: { lineWidth: 1, strokeStyle: 'rgba(0, 0, 0, 0.05)' }, path: { options: {}, type: o.Straight } }, dimension: { label: { angle: void 0, boundaryPadding: 5, fillStyle: 'rgba(0, 0, 0, 1.0)', font: 'normal 11px sans-serif', lineWidth: 3, offset: 16, placement: l.Before, strokeStyle: 'rgba(255, 255, 255, 1.0)' }, labelActive: { fillStyle: 'rgba(99, 200, 255, 1.0)' }, labelHover: { fillStyle: 'rgba(79, 180, 246, 1.0)' }, layout: i.AxisEvenlySpaced }, padding: [ 32, 64 ] } }, y = { p0: Number.NaN, p1: Number.NaN, value0: Number.NaN, value1: Number.NaN }, v = { dimension: { axis: 0, bound: void 0, boundOffset: void 0, offset: 0 }, filters: { active: y, key: void 0 }, shared: { action: d, focus: void 0 } }, b = e => 'number' == typeof e, k = e => 'object' == typeof e && null != e && Object.getPrototypeOf(e) === Object.prototype && !Array.isArray(e) && !(e => e instanceof Map)(e) && !S(e), S = e => e instanceof Set, M = e => 'string' == typeof e, L = e => JSON.parse(JSON.stringify(e)), E = (e, t) => Math.min(t[1], Math.max(t[0], e)), w = (e, t) => M(e) && M(t) ? e.localeCompare(t) : e === t ? 0 : e > t ? 1 : -1, N = (...e) => e.reduce(((e, t) => (Object.keys(t).forEach((i => { k(e[i]) && k(t[i]) ? e[i] = N(e[i], t[i]) : (Array.isArray(e[i]) && Array.isArray(t[i]), e[i] = t[i]); })), e)), {}), O = (e, t) => { const{ actual: i, finite: a } = e.reduce(((e, i) => (b(i) && ((e => t === s.Logarithmic ? isFinite(Math.log(e)) : isFinite(e))(i) && (i < e.finite[0] && (e.finite[0] = i), i > e.finite[1] && (e.finite[1] = i)), i < e.actual[0] && (e.actual[0] = i), i > e.actual[1] && (e.actual[1] = i)), e)), { actual: [ 1 / 0, -1 / 0 ], finite: [ Number.MAX_VALUE, -Number.MAX_VALUE ] });return{ actual: i.sort(), finite: a.sort() }; }, z = (e, t) => e[t % e.length], B = (e, t, i, s) => { const a = i > 1 ? i - 1 : 1;return s % (a + 1) * ((e - t) / a) + t; }, P = e => e[((e, t = 0) => Math.floor(Math.random() * (e - t)) + t)(e.length)], F = (e, t, i = {}) => { if(null != i.includeNaN){ const e = E(i.includeNaN, [ 0, 1 ]);if(Math.random() < e)return Number.NaN; }if(null != i.includeNegativeInfinity){ const e = E(i.includeNegativeInfinity, [ 0, 1 ]);if(Math.random() < e)return-1 / 0; }if(null != i.includePositiveInfinity){ const e = E(i.includePositiveInfinity, [ 0, 1 ]);if(Math.random() < e)return 1 / 0; }return Math.random() * (e - t) + t; }, A = e => { let t = ((e, t = 6) => { let i = e.toString();const s = Math.abs(e);return isNaN(e) ? i = 'NaN' : Number.isFinite(e) ? 0 !== s && (s < .01 || s > 999 ? i = e.toExponential(t) : Number.isInteger(e) || (i = e.toFixed(t))) : i = (e < 0 ? '-' : '') + 'Infinity', i; })(e);return t = t.replace(/(e)\+(\d+)/, '$1$2'), t = t.replace(/0+(e-?\d+)$/, '$1'), t = t.replace(/(\.[0-9]+?)0+$/, '$1'), t = t.replace(/\.(e)/, '$1'), t; }, C = (e, t = {}) => { var i, s;const a = null !== (i = t.size) && void 0 !== i ? i : 24, n = null !== (s = t.suffix) && void 0 !== s ? s : '...';return e.length <= a ? e : `${e.substring(0, a)}${n}`; }, T = e => M(e) ? e : e.toString();class D{constructor(e, t, i, s = {}){ this.direction = e, this.minValue = t, this.maxValue = i, this.range = 0, this.reverse = false, this.tickLabels = [], this.tickPos = [], this.ticks = [], this.tickPadding = 0, this.tickSpacing = 0, this.axisLength = 1, this.maxTicks = 1, this.dataOnEdge = true, this.max = i, this.min = t, null != s.dataOnEdge && (this.dataOnEdge = s.dataOnEdge), this.reverse = e === a.Horizontal ? null != s.reverse && s.reverse : null == s.reverse || !s.reverse, this.setMinMaxValues(t, i, !1); }setAxisLength(e){ this.axisLength = e, this.maxTicks = e / 50, this.calculate(); }setMinMaxValues(e, t, i = !0){ if(e === t){ const i = e;if(0 === i)e = -1, t = 1;else if(i < 0){ e = i - ((t = -(2 ** (Math.log2(Math.abs(i)) - 1))) - i); }else{ t = i + (i - (e = 2 ** (Math.log2(i) - 1))); } }this.minValue = e, this.maxValue = t, this.max = t, this.min = e, this.range = t - e, i && this.calculate(); }niceNum(e, t){ const i = Math.floor(Math.log10(e)), s = e / 10 ** i;let a;return a = t ? s < 1.5 ? 1 : s < 3 ? 2 : s < 7 ? 5 : 10 : s <= 1 ? 1 : s <= 2 ? 2 : s <= 5 ? 5 : 10, a * 10 ** i; }}class R extends D{constructor(e, t = [], i = {}){ super(e, 0, 0, i), this.direction = e, this.categories = t, this.reverse && this.categories.reverse(), this.tickLabels = this.categories.map((e => T(e))); }percentToValue(e){ return this.posToValue(e * this.axisLength); }posToValue(e){ let t = 1 / 0, i = Number.NaN;for(let s = 0;s < this.tickPos.length;s++){ const a = this.tickPos[s], n = Math.abs(e - a);n < t && (t = n, i = this.categories[s]); }return i; }valueToPercent(e){ const t = T(e), i = this.tickLabels.findIndex((e => e === t));return-1 !== i ? this.tickPos[i] / this.axisLength : 0; }valueToPos(e){ return this.valueToPercent(e) * this.axisLength; }calculate(){ const e = this.tickLabels.length;let t = 0;this.tickSpacing = this.axisLength / (this.dataOnEdge ? e - 1 : e), this.tickPos = [];for(let i = 0;i < e;i++)[ 0, e ].includes(i) ? t += this.dataOnEdge ? 0 : this.tickSpacing / 2 : t += this.tickSpacing, this.tickPos.push(t); }}class I extends Error{constructor(e){ super(`[Hermes] ${e instanceof Error ? e.message : M(e) ? e : 'Critical error encountered!'}`); }}class _ extends D{percentToValue(e){ const t = this.dataOnEdge ? this.minValue : this.min, i = this.dataOnEdge ? this.maxValue : this.max;return(this.reverse ? 1 - e : e) * (i - t) + t; }posToValue(e){ return this.percentToValue(e / this.axisLength); }valueToPercent(e){ if(!b(e))return 0;const t = this.dataOnEdge ? this.minValue : this.min, i = (e - t) / ((this.dataOnEdge ? this.maxValue : this.max) - t);return this.reverse ? 1 - i : i; }valueToPos(e){ return this.valueToPercent(e) * this.axisLength; }calculate(){ this.range = this.niceNum(this.maxValue - this.minValue, !1), this.tickSpacing = this.niceNum(this.range / this.maxTicks, !0), this.min = Math.floor(this.minValue / this.tickSpacing) * this.tickSpacing, this.max = Math.ceil(this.maxValue / this.tickSpacing) * this.tickSpacing;const e = Math.round((this.max - this.min) / this.tickSpacing);this.ticks = [], this.tickLabels = [];for(let t = 0;t <= e;t++){ let i = t * this.tickSpacing + this.min;this.dataOnEdge && 0 === t && (i = this.minValue), this.dataOnEdge && t === e && (i = this.maxValue), this.ticks.push(i);let s = A(i);this.dataOnEdge && [ 0, e ].includes(t) && (s = `*${s}`), this.tickLabels.push(s); }this.tickPos = this.ticks.map((e => this.valueToPos(e))); }}const V = e => t => Math.log(t) / Math.log(e);class H extends D{constructor(e, t, i, s, a, n = 10, l = {}){ super(e, t, i, l), this.direction = e, this.finiteMin = t, this.finiteMax = i, this.actualMin = s, this.actualMax = a, this.logBase = n, this.maxExp = Number.NaN, this.maxExpExact = Number.NaN, this.minExp = Number.NaN, this.minExpExact = Number.NaN, this.log = V(n), this.logBase = n, this.actualMax = a, this.actualMin = s; }setLogBase(e = 10){ this.logBase = e, this.calculate(); }percentToValue(e){ if(0 === e)return this.reverse ? this.actualMax : this.actualMin;if(1 === e)return this.reverse ? this.actualMin : this.actualMax;const t = this.dataOnEdge ? this.minExpExact : this.minExp, i = (this.reverse ? 1 - e : e) * this.rangeExp() + t;return this.logBase ** i; }posToValue(e){ return this.percentToValue(e / this.axisLength); }valueToPercent(e){ if(!b(e))return 0;const t = this.log(e), i = this.dataOnEdge ? this.minExpExact : this.minExp, s = (t - i) / ((this.dataOnEdge ? this.maxExpExact : this.maxExp) - i);return this.reverse ? 1 - s : s; }valueToPos(e){ return this.valueToPercent(e) * this.axisLength; }rangeExp(){ return this.dataOnEdge ? this.maxExpExact - this.minExpExact : this.maxExp - this.minExp; }calculate(){ this.log = V(this.logBase), this.minExpExact = this.log(this.minValue), this.maxExpExact = this.log(this.maxValue), this.minExp = Math.floor(this.minExpExact), this.maxExp = Math.ceil(this.maxExpExact), this.range = this.logBase ** this.maxExp - this.logBase ** this.minExp, this.tickSpacing = 1;const e = Math.round((this.maxExp - this.minExp) / this.tickSpacing);this.ticks = [], this.tickLabels = [];for(let t = 0;t <= e;t++){ const i = t * this.tickSpacing + this.minExp;let s = this.logBase ** i;this.dataOnEdge && 0 === t && (s = this.logBase ** this.minExpExact), this.dataOnEdge && t === e && (s = this.logBase ** this.maxExpExact), this.ticks.push(s);let a = A(s);this.dataOnEdge && [ 0, e ].includes(t) && (a = `*${a}`), this.tickLabels.push(a); }this.tickPos = this.ticks.map((e => this.valueToPos(e))); }}const $ = (e, t) => e.x * t.x + e.y * t.y, W = (e, t, i, s) => { const a = { x: s.x - t.x, y: s.y - t.y }, n = { x: i.x - t.x, y: i.y - t.y }, l = { x: e.x - t.x, y: e.y - t.y }, o = $(a, a), r = $(a, n), h = $(a, l), c = $(n, n), d = $(n, l), u = 1 / (o * c - r * r), g = (c * h - r * d) * u, p = (o * d - r * h) * u;return g >= 0 && p >= 0 && g + p < 1; }, J = (e, t, i = {}) => { if(e.save(), i.fillStyle){ e.fillStyle = i.fillStyle, e.beginPath(), e.moveTo(t[0].x, t[0].y);for(let i = 1;i < t.length;i++)e.lineTo(t[i].x, t[i].y);e.closePath(), e.fill(); }if(i.strokeStyle){ e.lineCap = i.lineCap || g, e.lineDashOffset=i.lineDashOffset||0, e.lineJoin = i.lineJoin || p, e.lineWidth = i.lineWidth || 1, e.miterLimit = i.miterLimit || f, e.strokeStyle = i.strokeStyle, e.beginPath(), e.moveTo(t[0].x, t[0].y);for(let i = 1;i < t.length;i++)e.lineTo(t[i].x, t[i].y);e.closePath(), e.stroke(); }e.restore(); }, j = (e, t, i, s, a = {}) => { var n;if(t.length < 2)return;e.save(), e.lineCap = a.lineCap || g, e.lineDashOffset=a.lineDashOffset||0, e.lineJoin = a.lineJoin || p, e.lineWidth = a.lineWidth || 1, e.miterLimit = a.miterLimit || f, e.strokeStyle = a.strokeStyle || m, e.beginPath(), e.moveTo(t[0].x, t[0].y);const l = null !== (n = s.options.bezierFactor) && void 0 !== n ? n : .3;for(let a = 1;a < t.length;a++){ const[ n, r ] = [ t[a].x, t[a].y ];if(s.type === o.Straight)e.lineTo(n, r);else if(s.type === o.Bezier){ const[ s, o ] = [ t[a - 1].x, t[a - 1].y ], [ h, c ] = [ s + (i ? (n - s) * l : 0), o + (i ? 0 : (r - o) * l) ], [ d, u ] = [ n - (i ? (n - s) * l : 0), r - (i ? 0 : (r - o) * l) ];e.bezierCurveTo(h, c, d, u, n, r); } }e.stroke(), e.restore(); }, q = (e, t, i, s, a, n = {}) => { e.save(), e.lineCap = n.lineCap || g, e.lineDashOffset=n.lineDashOffset||0, e.lineJoin = n.lineJoin || p, e.lineWidth = n.lineWidth || 1, e.miterLimit = n.miterLimit || f, e.strokeStyle = n.strokeStyle || m, e.beginPath(), e.moveTo(ee(t), ee(i)), e.lineTo(ee(s), ee(a)), e.stroke(), e.restore(); }, U = (e, t, i, s, a, n = {}) => { e.save();const l = ee(t), o = ee(i), r = n.cornerRadius||0;n.fillStyle && (e.fillStyle = n.fillStyle, 0 === r ? e.fillRect(l, o, s, a) : (X(e, l, o, s, a, r), e.fill())), n.strokeStyle && (e.lineCap = n.lineCap || g, e.lineDashOffset=n.lineDashOffset||0, e.lineJoin = n.lineJoin || p, e.lineWidth = n.lineWidth || 1, e.miterLimit = n.miterLimit || f, e.strokeStyle = n.strokeStyle, 0 === r ? e.strokeRect(l, o, s, a) : (X(e, l, o, s, a, r), e.stroke())), e.restore(); }, X = (e, t, i, s, a, n) => { e.beginPath(), e.moveTo(t + n, i), e.lineTo(t + s - n, i), e.quadraticCurveTo(t + s, i, t + s, i + n), e.lineTo(t + s, i + a - n), e.quadraticCurveTo(t + s, i + a, t + s - n, i + a), e.lineTo(t + n, i + a), e.quadraticCurveTo(t, i + a, t, i + a - n), e.lineTo(t, i + n), e.quadraticCurveTo(t, i, t + n, i), e.closePath(); }, G = (e, t, i, s, a, n = {}) => { const l = Z(a), o = l > Math.PI / 2 && l <= 3 * Math.PI / 2, r = -a - (o ? Math.PI : 0);e.save(), te(e, n.font), e.direction = n.direction || 'inherit', e.textAlign = n.textAlign || (o ? 'right' : 'left'), e.textBaseline = n.textBaseline || 'middle', r % 2 * Math.PI != 0 && (e.translate(i, s), e.rotate(r), e.translate(-i, -s)), n.strokeStyle && (e.lineCap = n.lineCap || g, e.lineDashOffset=n.lineDashOffset||0, e.lineJoin = n.lineJoin || p, e.lineWidth = n.lineWidth || 1, e.miterLimit = n.miterLimit || f, e.strokeStyle = n.strokeStyle, e.strokeText(t, i, s)), n.fillStyle && (e.fillStyle = n.fillStyle, e.fillText(t, i, s)), e.restore(); }, K = (e, t, i, s, a, n = 0, l = 0, o = 0) => { const r = e + n - o, h = t + l - o, c = e + i + n + o, d = t + s + l + o, u = [ { x: r, y: h }, { x: c, y: h }, { x: c, y: d }, { x: r, y: d } ];if(null != a){ const i = Z(a);return u.map((s => ((e, t, i, s = 0, a = 0) => { const n = e - s, l = t - a, o = Math.cos(i), r = Math.sin(i);return{ x: o * n - r * l + s, y: r * n + o * l + a }; })(s.x, s.y, -i, e, t))); }return u; }, Y = (e, t, i = u) => { te(e, i);const s = e.measureText(t), a = s.actualBoundingBoxLeft + s.actualBoundingBoxRight;return{ h: s.actualBoundingBoxAscent + s.actualBoundingBoxDescent, w: a }; }, Q = e => { const t = devicePixelRatio <= 1 ? 1 : 2 - .5 ** (devicePixelRatio - 1);return Array.isArray(e) ? 2 === e.length ? [ e[0] * t, e[1] * t, e[0] * t, e[1] * t ] : e.map((e => e * t)) : new Array(4).fill(e * t); }, Z = e => (e + 2 * Math.PI) % (2 * Math.PI), ee = e => Math.round(e - .5) + .5, te = (e, t = u) => { const i = new RegExp(/(-?\d*\.?\d+)px/), s = t.match(i);if(2 === (null == s ? void 0 : s.length)){ const a = Math.round(parseFloat(s[1]) * devicePixelRatio);e.font = t.replace(i, `${a}px`); }else e.font = t; }, ie = (e, t) => { const i = e.length;if(i < 1)return'#000000';if(1 === i)return e[0];const s = t * (i - 1), a = Math.floor(s), n = Math.ceil(s), l = ((e, t, i) => { const s = Math.round((t.r - e.r) * i + e.r), a = Math.round((t.g - e.g) * i + e.g), n = Math.round((t.b - e.b) * i + e.b);if(null != e.a && null != t.a)return{ a: (t.a - e.a) * i + e.a, b: n, g: a, r: s };return{ b: n, g: a, r: s }; })(se(e[a]), se(e[n]), s - a);return(e => null != e.a ? `rgba(${e.r}, ${e.g}, ${e.b}, ${e.a})` : `rgb(${e.r}, ${e.g}, ${e.b})`)(l); }, se = e => { if(/^#/.test(e))return(e => { const t = { b: 0, g: 0, r: 0 }, i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return i && i.length > 3 && (t.r = parseInt(i[1], 16), t.g = parseInt(i[2], 16), t.b = parseInt(i[3], 16)), t; })(e);const t = /^rgba?\(\s*?(\d+)\s*?,\s*?(\d+)\s*?,\s*?(\d+)\s*?(,\s*?([\d.]+)\s*?)?\)$/i.exec(e);if(t && t.length > 3){ const e = { a: 1, b: 0, g: 0, r: 0 };return e.r = parseInt(t[1]), e.g = parseInt(t[2]), e.b = parseInt(t[3]), t.length > 5 && void 0 !== t[5] && (e.a = parseFloat(t[5])), e; }return{ a: 1, b: 0, g: 0, r: 0 }; }, ae = (e, t) => { const i = t.getBoundingClientRect();return{ x: (e.clientX - i.x) * devicePixelRatio, y: (e.clientY - i.y) * devicePixelRatio }; }, ne = (e, t) => { let i;return(...s) => { null == i && (i = setTimeout((() => { e(...s), i = void 0; }), t)); }; }, le = (e, i, s) => { const a = i.shared.action, n = a.type === t.LabelMove && a.dimIndex === e, l = i.dimension.bound || c, o = i.dimension.boundOffset || { x: 0, y: 0 };return n ? (h = o, { h: (r = l).h, w: r.w, x: r.x + h.x, y: r.y + h.y }) : s;var r, h; }, oe = e => 1 === w(e.value0, e.value1) ? [ e.value1, e.value0 ] : [ e.value0, e.value1 ], re = e => isNaN(e.p0) && isNaN(e.p1), he = (e, t) => { const i = L(y);return e.p0 < t.p0 ? (i.p0 = e.p0, i.value0 = e.value0) : (i.p0 = t.p0, i.value0 = t.value0), e.p1 > t.p1 ? (i.p1 = e.p1, i.value1 = e.value1) : (i.p1 = t.p1, i.value1 = t.value1), i; }, ce = { 'accuracy': [ .55, .99 ], 'dropout': [ .2, .8 ], 'global-batch-size': [ 5, 30 ], 'layer-free-decay': [ .001, .1 ], 'layer-split-factor': [ 1, 16 ], 'learning-rate': [ 1e-4, .1 ], 'learning-rate-decay': [ 1e-6, .001 ], 'loss': [ 1.7, 2.4 ], 'metrics-base': [ .5, .9 ], 'n-filters': [ 8, 64 ] }, de = [ { dataOnEdge: !1, key: 'dropout', label: 'Dropout', type: s.Linear }, { dataOnEdge: !1, key: 'global-batch-size', label: 'Global Batch Size', type: s.Linear }, { categories: [ 4, 8, 16, 32, 64 ], dataOnEdge: !1, key: 'layer-dense-size', label: 'Layer Dense Size', type: s.Categorical }, { dataOnEdge: !1, key: 'layer-free-decay', label: 'Layer Free Decay', logBase: 10, type: s.Logarithmic }, { categories: [ !0, !1 ], dataOnEdge: !1, key: 'layer-inverse', label: 'Layer Inverse', type: s.Categorical }, { dataOnEdge: !1, key: 'learning-rate', label: 'Learning Rate', logBase: 10, type: s.Logarithmic }, { dataOnEdge: !1, key: 'learning-rate-decay', label: 'Learning Rate Decay', logBase: 10, type: s.Logarithmic }, { dataOnEdge: !1, key: 'layer-split-factor', label: 'Layer Split Factor', logBase: 2, type: s.Logarithmic }, { dataOnEdge: !1, key: 'metrics-base', label: 'Metrics Base', type: s.Linear }, { dataOnEdge: !1, key: 'n-filters', label: 'N Filters', type: s.Linear } ], ue = [ { dataOnEdge: !1, disableDrag: !0, key: 'accuracy', label: 'Accuracy', type: s.Linear }, { dataOnEdge: !1, disableDrag: !0, key: 'loss', label: 'Loss', type: s.Logarithmic } ];var ge = Object.freeze({ __proto__: null, DEFAULT_DIMENSION_COUNT: 10, dimensionRanges: ce, dimensionSamples: de, generateData: (e, t, i = !0, a = {}) => e.reduce(((e, n) => (e[n.key] = new Array(t).fill(null).map(((e, l) => { if(n.type === s.Categorical){ if(n.categories)return i ? P(n.categories) : z(n.categories, l); }else if(n.type === s.Linear){ const e = ce[n.key];if(e)return i ? F(e[1], e[0], a) : B(e[1], e[0], t, l); }else if(n.type === s.Logarithmic){ const e = ce[n.key];if(e && n.logBase)return i ? ((e, t, i, s = {}) => { const a = 10 === e ? Math.log10 : 2 === e ? Math.log2 : Math.log, n = a === Math.log ? Math.log(e) : 1, l = a(t) / n, o = a(i) / n, r = F(l, o, s);return isNaN(r) || !isFinite(r) ? r : e ** r; })(n.logBase, e[1], e[0], a) : ((e, t, i, s, a) => { const n = 10 === e ? Math.log10 : 2 === e ? Math.log2 : Math.log, l = n === Math.log ? Math.log(e) : 1, o = n(t) / l, r = n(i) / l;return e ** B(o, r, s, a); })(n.logBase, e[1], e[0], t, l); }return r; })), e)), {}), generateDimensions: (e = 10, t = !0) => { const i = new Array(e - 1).fill(null).map(((e, i) => t ? P(de) : z(de, i))), s = t ? P(ue) : z(ue, 0);return i.push(s), i; }, metricDimensionSamples: ue });class pe{constructor(e, t, i, s){ this.config = x, this.data = {}, this.dataCount = 0, this.dimensions = [], this.dimensionsOriginal = [], this.filters = {}, this.size = { h: 0, w: 0 }, this.ix = L(v), this._ = void 0;const a = (e => M(e) ? document.querySelector(e) : e)(e);if(!a)throw new I('Target element selector did not match anything.');this.element = a;const n = this.element.getBoundingClientRect();if(0 === n.width || 0 === n.height)throw new I('Target element width and height must both be greater than 0px.');const l = this.element.querySelectorAll('canvas');0 === l.length ? (this.canvas = document.createElement('canvas'), this.element.appendChild(this.canvas)) : this.canvas = l[0];const o = this.canvas.getContext('2d');if(!o)throw new I('Unable to get context from target element.');this.ctx = o, t && this.setDimensions(t, !1), i && this.setConfig(i, !1), s && this.setData(s, !1), (t || i || s) && this.redraw(), this.listeners = { dblclick: this.handleDoubleClick.bind(this), mousedown: this.handleMouseDown.bind(this), mousemove: 0 === this.config.interactions.throttleDelayMouseMove ? this.handleMouseMove.bind(this) : ne((e => this.handleMouseMove.bind(this)(e)), this.config.interactions.throttleDelayMouseMove), mouseup: this.handleMouseUp.bind(this) }, this.enable(); }static deepMerge(...e){ return N(...e); }static getTester(){ return ge; }static validateData(e, t){ const i = { count: 0, message: '', valid: !0 }, s = Object.values(e);for(let e = 0;e < s.length;e++){ const t = s[e];if(0 === e)i.count = t.length;else if(t.length !== i.count)return i.message = 'The dimension data are not uniform in size.', i.valid = !1, i; }const a = Object.keys(e);for(let e = 0;e < t.length;e++){ const s = t[e].key;if(!a.includes(s))return i.message = `Data for "${s} is missing.`, i.valid = !1, i; }return i; }static validateDimension(e){ if(e.type === s.Categorical){ if(!e.categories || 0 === e.categories.length)return{ message: `Categorical dimension "${e.key}" is missing "categories".`, valid: !1 }; }else if(e.type === s.Logarithmic && (null == e.logBase || 0 === e.logBase))return{ message: `Logarithmic dimension "${e.key}" is missing "logBase".`, valid: !1 };return{ message: '', valid: !0 }; }static validateDimensions(e){ if(0 === e.length)return{ message: 'Need at least one dimension defined.', valid: !1 };for(let t = 0;t < e.length;t++){ const{ message: i, valid: s } = pe.validateDimension(e[t]);if(!s)return{ message: i, valid: s }; }return{ message: '', valid: !0 }; }setConfig(e = {}, t = !0){ this.config = N(x, e), this.addObservers(), t && this.redraw(); }setData(e, t = !0){ const i = pe.validateData(e, this.dimensionsOriginal);if(!i.valid)throw new I(i.message);const s = (e => { const t = Object.keys(e), i = {}, s = {};let a = 0;for(const s of t){ 0 === a && (a = e[s].length);for(const[ t, a ]of e[s].entries())!b(a) || !isNaN(a) && isFinite(a) || (i[t] = !0); }for(const a of t)s[a] = e[a].filter(((e, t) => !i[t]));return{ count: a - Object.keys(i).length, data: s }; })(e);this.data = s.data, this.dataCount = s.count, this.setDimensions(this.dimensionsOriginal, !1), t && this.redraw(); }setDimensions(e, t = !0){ const i = pe.validateDimensions(e);if(!i.valid)throw new I(i.message);const n = this.config.direction === a.Horizontal ? a.Vertical : a.Horizontal;this.dimensionsOriginal = e, this.dimensions = L(e).map((e => { const t = e.key, i = this.data[t] || [], a = { ...e, labelTruncated: C(e.label, { size: this.config.style.dimension.label.truncate }), rangeActual: void 0, rangeFinite: void 0, scale: new _(n, 0, 100) };if(e.type === s.Linear || e.type === s.Logarithmic){ const t = O(i, e.type);e.type === s.Linear ? a.scale = new _(n, t.actual[0], t.actual[1], e) : e.type === s.Logarithmic && (a.scale = new H(n, t.finite[0], t.finite[1], t.actual[0], t.actual[1], e.logBase, e)); }else e.type === s.Categorical && (a.scale = new R(n, e.categories, e));return a; })), t && this.redraw(); }setSize(e, t, i = !0){ var s, a;const n = { h: this.size.h, w: this.size.w }, l = Math.round(e * devicePixelRatio), o = Math.round(t * devicePixelRatio);this.canvas.width = l, this.canvas.height = o, this.canvas.style.width = `${e}px`, this.canvas.style.height = `${t}px`, this.size = { h: o, w: l }, null === (a = (s = this.config.hooks).onResize) || void 0 === a || a.call(s, this.size, n), i && this.redraw(); }disable(){ this.removeListeners(), this.removeObservers(), this.ix = L(v), this.updateCursor(), this.redraw(); }enable(){ this.addListeners(), this.addObservers(); }redraw(){ 0 === this.size.w && 0 === this.size.h || (this.calculate(), this.clear(), this.config.debug && this.drawDebugOutline(), this.draw()); }destroy(){ this.removeListeners(), this.removeObservers(), this.canvas && this.element.contains(this.canvas) && this.element.removeChild(this.canvas); }addListeners(){ this.element.addEventListener('dblclick', this.listeners.dblclick), this.element.addEventListener('mousedown', this.listeners.mousedown), window.addEventListener('mousemove', this.listeners.mousemove), window.addEventListener('mouseup', this.listeners.mouseup); }addObservers(){ this.resizeObserver && (this.resizeObserver.unobserve(this.element), this.resizeObserver = void 0), this.resizeObserver = new ResizeObserver(0 === this.config.interactions.throttleDelayResize ? this.handleResize.bind(this) : ne((e => this.handleResize.bind(this)(e)), this.config.interactions.throttleDelayResize)), this.resizeObserver.observe(this.element); }removeListeners(){ this.element.removeEventListener('dblclick', this.listeners.dblclick), this.element.removeEventListener('mousedown', this.listeners.mousedown), window.removeEventListener('mousemove', this.listeners.mousemove), window.removeEventListener('mouseup', this.listeners.mouseup); }removeObservers(){ var e;null === (e = this.resizeObserver) || void 0 === e || e.unobserve(this.element), this.resizeObserver = void 0; }calculate(){ this.calculateLayout(), this.calculateStyles(); }calculateLayout(){ var e, t;const s = { dims: { list: new Array(this.dimensions.length).fill(void 0).map((() => ({ axes: {}, label: {}, layout: {} }))), shared: { axes: {}, label: {}, layout: {} } }, layout: { drawRect: {}, padding: Q(this.config.style.padding) } }, { h: n, w: o } = this.size, r = s.layout, h = s.dims.shared.axes, c = s.dims.shared.label, d = s.dims.shared.layout, u = this.dimensions.length, g = this.config.direction === a.Horizontal, p = this.config.style.dimension.label, f = this.config.style.dimension.label.boundaryPadding, m = this.config.style.dimension.layout, x = this.config.style.axes.label, y = this.config.style.axes.axis.boundaryPadding, v = p.placement === l.Before, b = null != p.angle, k = x.placement === l.Before;if(r.drawRect = { h: n - r.padding[0] - r.padding[2], w: o - r.padding[1] - r.padding[3], x: r.padding[3], y: r.padding[0] }, c.cos = b ? Math.cos(null !== (e = p.angle) && void 0 !== e ? e : 0) : void 0, c.sin = b ? Math.sin(null !== (t = p.angle) && void 0 !== t ? t : 0) : void 0, c.rad = p.angle || (g ? void 0 : v ? -Math.PI : 0), c.maxLengthCos = 0, c.maxLengthSin = 0, this.dimensions.forEach(((e, t) => { const i = Y(this.ctx, e.labelTruncated, p.font), a = s.dims.list[t].label;a.w = i.w, a.h = i.h, a.lengthCos = b ? i.w * c.cos : i.w, a.lengthSin = b ? i.w * c.sin : i.h, Math.abs(a.lengthCos) > Math.abs(c.maxLengthCos) && (c.maxLengthCos = a.lengthCos), Math.abs(a.lengthSin) > Math.abs(c.maxLengthSin) && (c.maxLengthSin = a.lengthSin); })), h.start = 0, h.stop = 0, g)if(v){ const e = Math.max(0, c.maxLengthSin);h.start = r.padding[0] + e + p.offset, h.stop = n - r.padding[2]; }else{ const e = b ? Math.max(0, -c.maxLengthSin) : c.maxLengthSin;h.start = r.padding[0], h.stop = n - r.padding[2] - e - p.offset; }else if(v){ const e = b ? Math.max(0, -c.maxLengthCos) : c.maxLengthCos;h.start = r.padding[3] + e + p.offset, h.stop = o - r.padding[1]; }else{ const e = Math.max(0, c.maxLengthCos);h.start = r.padding[3], h.stop = o - r.padding[1] - e - p.offset; }if(h.length = h.stop - h.start, h.labelFactor = k ? -1 : 1, d.totalBoundSpace = 0, this.dimensions.forEach(((e, t) => { const i = s.dims.list[t].axes, a = s.dims.list[t].label, l = s.dims.list[t].layout, c = e.scale;i.tickLabels = [], i.tickPos = [], i.maxLength = 0, c && (c.setAxisLength(h.length), i.tickLabels = c.tickLabels.slice(), i.tickPos = c.tickPos.slice(), c.tickLabels.forEach((e => { const t = Y(this.ctx, e, x.font);i.maxLength = Math.max(t.w, i.maxLength); }))), b ? (l.spaceBefore = g ? a.lengthCos < 0 ? -a.lengthCos : 0 : a.lengthSin > 0 ? a.lengthSin : 0, l.spaceAfter = g ? a.lengthCos > 0 ? a.lengthCos : 0 : a.lengthSin < 0 ? -a.lengthSin : 0) : (l.spaceBefore = (g ? a.lengthCos : a.lengthSin) / 2, l.spaceAfter = (g ? a.lengthCos : a.lengthSin) / 2), k ? l.spaceBefore = Math.max(l.spaceBefore, i.maxLength) : l.spaceAfter = Math.max(l.spaceAfter, i.maxLength), g ? (l.bound = { h: n - r.padding[0] - r.padding[2], w: l.spaceBefore + l.spaceAfter, x: 0, y: r.padding[0] }, d.totalBoundSpace += l.bound.w) : (l.bound = { h: l.spaceBefore + l.spaceAfter, w: o - r.padding[1] - r.padding[3], x: r.padding[3], y: 0 }, d.totalBoundSpace += l.bound.h); })), g){ const e = r.drawRect.w - d.totalBoundSpace;d.gap = u > 1 ? Math.max(e, 0) / (u - 1) : 0, d.offset = r.padding[3], d.space = u > 1 ? r.drawRect.w / (u - 1) : 0; }else{ const e = r.drawRect.h - d.totalBoundSpace;d.gap = u > 1 ? Math.max(e, 0) / (u - 1) : 0, d.offset = r.padding[0], d.space = u > 1 ? r.drawRect.h / (u - 1) : 0; }let S = d.offset;for(let e = 0;e < s.dims.list.length;e++){ const t = s.dims.list[e].label, a = s.dims.list[e].layout;g ? (m === i.AxisEvenlySpaced ? (a.bound.x = S - a.spaceBefore, S += d.space) : m === i.Equidistant && (a.bound.x = S, S += d.gap + a.bound.w), a.axisStart = { x: a.spaceBefore, y: h.start - r.padding[0] }, a.axisStop = { x: a.spaceBefore, y: h.stop - r.padding[0] }, a.labelPoint = { x: a.spaceBefore, y: v ? h.start - p.offset - r.padding[0] : h.stop + p.offset - r.padding[0] }) : (m === i.AxisEvenlySpaced ? (a.bound.y = S - a.spaceBefore, S += d.space) : m === i.Equidistant && (a.bound.y = S, S += d.gap + a.bound.h), a.axisStart = { x: h.start - r.padding[3], y: a.spaceBefore }, a.axisStop = { x: h.stop - r.padding[3], y: a.spaceBefore }, a.labelPoint = { x: v ? h.start - p.offset - r.padding[1] : h.stop + p.offset - r.padding[1], y: a.spaceBefore });const n = g ? -t.w / 2 : 0, l = g ? v ? -t.h : 0 : -t.h / 2;a.labelBoundary = K(a.bound.x + a.labelPoint.x, a.bound.y + a.labelPoint.y, t.w, t.h, c.rad, b ? 0 : n, b ? -t.h / 2 : l, f), a.axisBoundary = [ { x: a.bound.x + a.axisStart.x - (g ? y : 0), y: a.bound.y + a.axisStart.y - (g ? 0 : y) }, { x: a.bound.x + a.axisStart.x + (g ? y : 0), y: a.bound.y + a.axisStart.y + (g ? 0 : y) }, { x: a.bound.x + a.axisStop.x + (g ? y : 0), y: a.bound.y + a.axisStop.y + (g ? 0 : y) }, { x: a.bound.x + a.axisStop.x - (g ? y : 0), y: a.bound.y + a.axisStop.y - (g ? 0 : y) } ]; }this._ = s; }calculateStyles(){ if(!this._)return;this._.styles = this._.styles || [];const e = this.config.style, i = e.axes, s = e.dimension, a = this._.dims.list, l = this._.styles, o = this.ix.shared.action, r = this.ix.shared.focus, h = o.type !== t.None;for(let e = 0;e < a.length;e++){ const a = this.dimensions[e].key, c = this.filters[a] || [], d = o.type === t.LabelMove && o.dimIndex === e, u = (null == r ? void 0 : r.type) === n.DimensionLabel && (null == r ? void 0 : r.dimIndex) === e, g = (o.type === t.FilterCreate || o.type === t.FilterMove || o.type === t.FilterResizeAfter || o.type === t.FilterResizeBefore) && o.dimIndex === e, p = ((null == r ? void 0 : r.type) === n.DimensionAxis || (null == r ? void 0 : r.type) === n.Filter || (null == r ? void 0 : r.type) === n.FilterResize) && (null == r ? void 0 : r.dimIndex) === e;l[e] = l[e] || {}, l[e].label = { ...s.label, ...d || !u || h ? {} : s.labelHover, ...d ? s.labelActive : {} }, l[e].axis = { ...i.axis, ...g || !p || h ? {} : i.axisHover, ...g ? i.axisActve : {} }, l[e].tick = { ...i.tick, ...g || !p || h ? {} : i.tickHover, ...g ? i.tickActive : {} }, l[e].tickLabel = { ...i.label, ...g || !p || h ? {} : i.labelHover, ...g ? i.labelActive : {} }, l[e].filters = c.map(((t, s) => { const a = ((null == r ? void 0 : r.type) === n.Filter || (null == r ? void 0 : r.type) === n.FilterResize) && (null == r ? void 0 : r.dimIndex) === e && (null == r ? void 0 : r.filterIndex) === s, l = g || p && !a, h = a && void 0 === o.filterIndex, c = o.dimIndex === e && o.filterIndex === s;return{ ...i.filter, ...l ? i.filterAxisHover : {}, ...h ? i.filterHover : {}, ...c ? i.filterActive : {} }; })); } }getFocusByPoint(e){ if(!this._)return;const t = this._.dims.shared.axes, i = this.config.direction === a.Horizontal ? 'y' : 'x', s = this._.dims.shared.axes.length;for(let a = 0;a < this._.dims.list.length;a++){ const l = this.dimensions[a].key, o = this._.dims.list[a].layout, r = o.labelBoundary;if((W(e, r[0], r[1], r[2]) || W(e, r[2], r[3], r[0])) && !this.dimensions[a].disableDrag)return{ dimIndex: a, type: n.DimensionLabel };const h = o.axisBoundary;if(W(e, h[0], h[1], h[2]) || W(e, h[2], h[3], h[0])){ const r = this.filters[l] || [], h = o.bound[i] + o.axisStart[i], c = (e[i] - h) / s, d = r.findIndex((e => c >= e.p0 && c <= e.p1));let u = n.DimensionAxis;if(-1 !== d){ const e = 3 / t.length, i = r[d];u = c <= i.p0 + e || c >= i.p1 - e ? n.FilterResize : n.Filter; }return{ dimIndex: a, filterIndex: d, type: u }; } } }updateActiveLabel(){ var e, i;if(!this._ || this.ix.shared.action.type !== t.LabelMove)return;const s = this._.dims.list, n = this.ix, l = n.dimension, o = n.shared.action, r = this.config.direction === a.Horizontal, h = r ? 'x' : 'y';l.boundOffset = { x: r ? o.p1.x - o.p0.x : 0, y: r ? 0 : o.p1.y - o.p0.y };let c = -1;const d = l.axis + l.boundOffset[h];for(let e = 0;e < s.length;e++){ if(o.dimIndex === e || this.dimensions[e].disableDrag)continue;const t = s[e].layout, i = t.bound[h] + t.axisStart[h], a = Math.abs(d - i) < 30;if(o.dimIndex < e){ if(d < i && !a)break;c = e; }if(o.dimIndex > e && (d < i || a)){ c = e;break; } }if(-1 !== c){ const t = o.dimIndex, s = this.dimensions.splice(o.dimIndex, 1);if(0 === s.length)return;this.dimensions.splice(c, 0, s[0]), o.dimIndex = c, null === (i = (e = this.config.hooks).onDimensionMove) || void 0 === i || i.call(e, s[0], c, t); } }setActiveFilter(e, i, s){ if(!this._)return;const a = this.filters, n = this.ix, l = n.shared.action, o = n.filters, r = this._.dims.shared.axes, h = (a[e] || []).findIndex((e => i >= e.p0 && i <= e.p1));-1 !== h ? (o.active = a[e][h], o.active.startP0 = o.active.p0, o.active.startP1 = o.active.p1, l.filterIndex = h, i >= o.active.p0 && i <= o.active.p0 + 3 / r.length ? l.type = t.FilterResizeBefore : i >= o.active.p1 - 3 / r.length && i <= o.active.p1 ? l.type = t.FilterResizeAfter : l.type = t.FilterMove) : (l.type = t.FilterCreate, o.active = { p0: i, p1: i, value0: s, value1: s }, a[e] = a[e] || [], a[e].push(o.active), l.filterIndex = a[e].length - 1); }updateActiveFilter(e){ var i, s, n, l, o, r, h, c, d, u, g, p;if(!this._)return;const f = this._.dims.list, m = this._.dims.shared.axes, x = this.ix, v = x.filters, b = x.shared.action, k = this.filters, S = b.dimIndex, M = this.config.direction === a.Horizontal ? 'y' : 'x';if(!(b.type === t.FilterCreate || b.type === t.FilterMove || b.type === t.FilterResizeAfter || b.type === t.FilterResizeBefore) || !v.key)return;const L = f[b.dimIndex].layout.bound, N = f[b.dimIndex].layout.axisStart[M];if(b.type === t.FilterMove){ const e = null !== (i = v.active.startP0) && void 0 !== i ? i : 0, t = null !== (s = v.active.startP1) && void 0 !== s ? s : 0, a = t - e, n = (b.p1[M] - b.p0[M]) / m.length;v.active.p0 = e + n, v.active.p1 = t + n, v.active.p0 < 0 ? (v.active.p0 = 0, v.active.p1 = a) : v.active.p1 > 1 && (v.active.p0 = 1 - a, v.active.p1 = 1), v.active.value0 = this.dimensions[S].scale.percentToValue(v.active.p0), v.active.value1 = this.dimensions[S].scale.percentToValue(v.active.p1); }else b.type === t.FilterResizeBefore ? (v.active.p0 = (b.p1[M] - L[M] - N) / m.length, v.active.p0 = E(v.active.p0, [ 0, 1 ]), v.active.value0 = this.dimensions[S].scale.percentToValue(v.active.p0)) : (v.active.p1 = (b.p1[M] - L[M] - N) / m.length, v.active.p1 = E(v.active.p1, [ 0, 1 ]), v.active.value1 = this.dimensions[S].scale.percentToValue(v.active.p1));if('mouseup' === e.type){ if(O = b.p0, z = b.p1, Math.sqrt((z.x - O.x) ** 2 + (z.y - O.y) ** 2) < 1){ const e = k[v.key] || [], t = (v.active.p1 - v.active.p0) / 2 + v.active.p0, i = e.findIndex((e => t >= e.p0 && t <= e.p1));-1 !== i && (null === (l = (n = this.config.hooks).onFilterRemove) || void 0 === l || l.call(n, oe(e[i])), e.splice(i, 1)); }else{ if(v.active.p1 < v.active.p0){ const[ e, t ] = [ v.active.p1, v.active.value1 ];[ v.active.p1, v.active.value1 ] = [ v.active.p0, v.active.value0 ], [ v.active.p0, v.active.value0 ] = [ e, t ]; }switch(b.type){ case t.FilterCreate:null === (r = (o = this.config.hooks).onFilterCreate) || void 0 === r || r.call(o, oe(v.active));break;case t.FilterMove:null === (c = (h = this.config.hooks).onFilterMove) || void 0 === c || c.call(h, oe(v.active));break;case t.FilterResizeAfter:case t.FilterResizeBefore:null === (u = (d = this.config.hooks).onFilterResize) || void 0 === u || u.call(d, oe(v.active)); } }var O, z, B;v.active = { ...y }, v.key = void 0, this.cleanUpFilters(), null === (p = null === (g = this.config.hooks) || void 0 === g ? void 0 : g.onFilterChange) || void 0 === p || p.call(g, (B = this.filters, Object.keys(B).reduce(((e, t) => (e[t] = B[t].map((e => oe(e))).sort(((e, t) => w(e[0], t[0]))), e)), {}))); } }cleanUpFilters(){ Object.keys(this.filters).forEach((e => { const t = this.filters[e] || [];for(let e = 0;e < t.length;e++)if((a = t[e]).p0 >= a.p1)t[e] = { ...y };else for(let a = e + 1;a < t.length;a++)re(t[e]) || re(t[a]) || (i = t[e], s = t[a], i.p0 <= s.p1 && s.p0 <= i.p1 && (t[a] = he(t[e], t[a]), t[e] = { ...y }));var i, s, a;this.filters[e] = t.filter((e => !re(e))); })); }updateCursor(){ const e = this.ix, i = e.shared.action, s = e.shared.focus, l = this.config.direction === a.Horizontal;let o = 'default';i.type !== t.None ? i.type === t.FilterMove || i.type === t.LabelMove ? o = 'grabbing' : i.type === t.FilterResizeAfter || i.type === t.FilterResizeBefore ? o = l ? 'ns-resize' : 'ew-resize' : i.type === t.FilterCreate && (o = 'crosshair') : void 0 !== s && (s.type === n.DimensionLabel ? o = 'grab' : s.type === n.DimensionAxis ? o = 'crosshair' : s.type === n.Filter ? o = 'grab' : s.type === n.FilterResize && (o = l ? 'ns-resize' : 'ew-resize')), this.canvas.style.cursor = o; }clear(){ const{ h: e, w: t } = this.size;this.ctx.clearRect(0, 0, t, e); }draw(){ var e;if(!this._)return;const t = this._.dims.list, i = this._.dims.shared.axes, s = this._.dims.shared.label, o = this._.styles, r = this.ix, h = this.ix.shared.focus, c = this.filters, d = this.config.direction === a.Horizontal, u = this.config.style.axes, g = this.config.style.data, p = this.config.style.dimension, f = p.label.placement === l.Before, m = u.label.placement === l.Before, x = null === (e = g.colorScale) || void 0 === e ? void 0 : e.dimensionKey;for(let e = 0;e < this.dataCount;e++){ let i = g.default, s = !1, a = !1;const n = this.dimensions.map(((n, l) => { var o, h, u, p, f, m, y, v, b;const k = n.key, S = t[l].layout, M = le(l, r, S.bound), L = this.data[k][e], E = null !== (h = null === (o = n.scale) || void 0 === o ? void 0 : o.valueToPos(L)) && void 0 !== h ? h : 0, w = null !== (p = null === (u = n.scale) || void 0 === u ? void 0 : u.valueToPercent(L)) && void 0 !== p ? p : 0, N = M.x + S.axisStart.x + (d ? 0 : E), O = M.y + S.axisStart.y + (d ? E : 0);if(x === k){ const e = null !== (m = null === (f = n.scale) || void 0 === f ? void 0 : f.valueToPercent(L)) && void 0 !== m ? m : 0, t = null !== (v = null === (y = n.scale) || void 0 === y ? void 0 : y.reverse) && void 0 !== v && v, s = (null === (b = g.colorScale) || void 0 === b ? void 0 : b.colors) || [], a = ie(t ? s.slice().reverse() : s, e);i.strokeStyle = a; }if(c[k] && 0 !== c[k].length){ s = !0;let e = !1;for(let t = 0;t < c[k].length;t++){ const i = c[k][t], s = Math.min(i.p0, i.p1), a = Math.max(i.p0, i.p1);if(w >= s && w <= a){ e = !0;break; } }e || (a = !0); }return{ x: N, y: O }; }));s && a && (i = g.filtered), j(this.ctx, n, d, g.path, i); }const y = null == p.label.angle && d, v = { textAlign: y ? 'center' : void 0, textBaseline: y ? f ? 'bottom' : 'top' : void 0 };this.dimensions.forEach(((e, i) => { var a;const n = le(i, r, t[i].layout.bound), l = t[i].layout.labelPoint, h = n.x + l.x, c = n.y + l.y, d = { ...o[i].label, ...v };G(this.ctx, e.labelTruncated, h, c, null !== (a = s.rad) && void 0 !== a ? a : 0, d); }));const b = null == u.label.angle && d, k = { textAlign: b ? void 0 : 'center', textBaseline: b ? void 0 : m ? 'bottom' : 'top' };t.forEach(((e, t) => { const s = this.dimensions[t].key, a = le(t, r, e.layout.bound), l = e.layout.axisStart, g = e.layout.axisStop, p = e.axes.tickLabels, f = e.axes.tickPos, x = m ? -1 : 1, y = c[s] || [];q(this.ctx, a.x + l.x, a.y + l.y, a.x + g.x, a.y + g.y, o[t].axis);for(let e = 0;e < p.length;e++){ let i = p[e];if('*' === i[0]){ if((null == h ? void 0 : h.dimIndex) !== t || (null == h ? void 0 : h.type) !== n.DimensionAxis && (null == h ? void 0 : h.type) !== n.Filter && (null == h ? void 0 : h.type) !== n.FilterResize)continue;i = i.substring(1); }const s = d ? 0 : f[e], r = d ? f[e] : 0, c = d ? x * u.tick.length : 0, g = d ? 0 : x * u.tick.length, y = a.x + l.x + s, v = a.y + l.y + r, b = a.x + l.x + s + c, S = a.y + l.y + r + g;q(this.ctx, y, v, b, S, o[t].tick);const M = d ? b + x * u.label.offset : y, L = d ? v : S + x * u.label.offset, E = null != u.label.angle ? u.label.angle : d && m ? Math.PI : 0, w = { ...o[t].tickLabel, ...k };G(this.ctx, i, M, L, E, w); }y.forEach(((e, s) => { const n = e.p0 * i.length, r = e.p1 * i.length, h = o[t].filters[s].width, c = h / 2, u = a.x + l.x + (d ? -c : n), g = a.y + l.y + (d ? n : -c), p = d ? h : r - n, f = d ? r - n : h;U(this.ctx, u, g, p, f, o[t].filters[s]); })); })); }drawDebugOutline(){ if(!this._)return;const{ h: e, w: t } = this.size, i = this._.layout, s = this._.dims.list, n = this._.dims.shared.layout, l = this.config.direction === a.Horizontal, o = { strokeStyle: '#dddddd' };q(this.ctx, 0, i.padding[0], t, i.padding[0], o), q(this.ctx, 0, e - i.padding[2], t, e - i.padding[2], o), q(this.ctx, i.padding[3], 0, i.padding[3], e, o), q(this.ctx, t - i.padding[1], 0, t - i.padding[1], e, o);const r = { strokeStyle: '#999999' }, h = { strokeStyle: '#ff0000' }, c = { strokeStyle: '#eeeeee' }, d = { strokeStyle: '#0099cc' }, u = { strokeStyle: '#ffcc00' };s.forEach(((e, t) => { const s = e.layout.bound, a = e.layout.axisBoundary, o = e.layout.labelPoint, m = e.layout.labelBoundary;U(this.ctx, l ? i.padding[3] + t * n.space : s.x, l ? s.y : i.padding[0] + t * n.space, l ? n.space : s.w, l ? s.h : n.space, r), U(this.ctx, s.x, s.y, s.w, s.h, h), ((e, t, i, s, a = {}) => { e.save(), a.fillStyle && (e.fillStyle = null == a ? void 0 : a.fillStyle, e.moveTo(t + s, i), e.beginPath(), e.arc(t, i, s, 0, 2 * Math.PI), e.fill()), a.strokeStyle && (e.lineCap = a.lineCap || g, e.lineDashOffset=a.lineDashOffset||0, e.lineJoin = a.lineJoin || p, e.lineWidth = a.lineWidth || 1, e.miterLimit = a.miterLimit || f, e.strokeStyle = a.strokeStyle, e.moveTo(t + s, i), e.beginPath(), e.arc(t, i, s, 0, 2 * Math.PI), e.stroke()), e.restore(); })(this.ctx, s.x + o.x, s.y + o.y, 3, d), J(this.ctx, m, u), J(this.ctx, a, c); })); }handleResize(e){ const t = e.find((e => e.target === this.element));if(!t)return;const{ width: i, height: s } = t.contentRect;this.setSize(i, s); }handleDoubleClick(){ var e, t;this.setDimensions(this.dimensionsOriginal, !1), this.filters = {}, this.ix = L(v), this.redraw(), null === (t = (e = this.config.hooks).onReset) || void 0 === t || t.call(e); }handleMouseDown(e){ var i, s;if(!this._)return;const l = this.ix.shared, o = this.ix.shared.action, r = this.ix.dimension, h = this.ix.filters, c = this._.dims.shared.axes, d = this.config.direction === a.Horizontal, u = d ? 'x' : 'y', g = d ? 'y' : 'x', p = ae(e, this.element);if(o.p0 = p, o.p1 = p, o.filterIndex = -1, l.focus = this.getFocusByPoint(p), l.focus){ const e = l.focus.dimIndex, a = this._.dims.list[e].layout, d = a.bound, p = a.axisStart;if((null === (i = l.focus) || void 0 === i ? void 0 : i.type) === n.DimensionLabel)o.type = t.LabelMove, o.dimIndex = e, r.axis = d[u] + p[u], r.bound = d;else if([ n.DimensionAxis, n.Filter, n.FilterResize ].includes(null === (s = l.focus) || void 0 === s ? void 0 : s.type)){ o.type = t.FilterCreate, o.dimIndex = e, h.key = this.dimensions[e].key;const i = (o.p0[g] - d[g] - p[g]) / c.length, s = this.dimensions[e].scale.percentToValue(i);this.setActiveFilter(h.key, i, s); } }this.updateCursor(), this.redraw(); }handleMouseMove(e){ if(!this._)return;const t = ae(e, this.element);this.ix.shared.action.p1 = t, this.ix.shared.focus = this.getFocusByPoint(t), this.updateActiveLabel(), this.updateActiveFilter(e), this.updateCursor(), this.redraw(); }handleMouseUp(e){ if(!this._)return;const t = ae(e, this.element);this.ix.shared.action.p1 = t, this.updateActiveLabel(), this.updateActiveFilter(e), this.ix = L(v), this.ix.shared.focus = this.getFocusByPoint(t), this.updateCursor(), this.redraw(); }}return e.ActionType = t, e.DimensionLayout = i, e.DimensionType = s, e.Direction = a, e.FocusType = n, e.LabelPlacement = l, e.PathType = o, e.default = pe, e; }({});
