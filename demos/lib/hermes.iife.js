var Hermes=function(e){"use strict";const t={FilterCreate:"filter-create",FilterMove:"filter-move",FilterResizeAfter:"filter-resize-after",FilterResizeBefore:"filter-resize-before",LabelMove:"label-move",None:"none"},i={AxisEvenlySpaced:"axis-evenly-spaced",Equidistant:"equidistant"},s={Categorical:"categorical",Linear:"linear",Logarithmic:"logarithmic"},a={Horizontal:"horizontal",Vertical:"vertical"},n={DimensionAxis:"dimension-axis",DimensionLabel:"dimension-label",Filter:"filter",FilterResize:"filter-resize"},l={After:"after",Before:"before"},r={Bezier:"bezier",Straight:"straight"},o=Number.NaN,h={x:Number.NaN,y:Number.NaN},c={h:Number.NaN,w:Number.NaN,x:Number.NaN,y:Number.NaN},d={dimIndex:-1,p0:h,p1:h,type:t.None},u="normal 12px san-serif",f="butt",p="round",y=10,g="black",x={debug:!1,direction:a.Horizontal,filters:{},hooks:{},interactions:{throttleDelayMouseMove:50,throttleDelayResize:50},style:{axes:{axis:{boundaryPadding:15,infLineDash:[2,4],infOffset:24,lineWidth:1,nanGap:24,strokeStyle:"rgba(147, 147, 147, 1.0)"},axisActive:{lineWidth:3,strokeStyle:"rgba(99, 200, 255, 1.0)"},axisHover:{lineWidth:3,strokeStyle:"rgba(79, 180, 246, 1.0)"},filter:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",strokeStyle:"rgba(255, 255, 255, 1.0)",width:4},filterActive:{cornerRadius:3,fillStyle:"rgba(255, 120, 220, 1.0)",width:8},filterAxisHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:6},filterHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:8},label:{fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:4,placement:l.After,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(0, 0, 0, 1.0)"},labelHover:{fillStyle:"rgba(0, 0, 0, 1.0)"},tick:{length:4,lineWidth:1,strokeStyle:"rgba(147, 147, 147, 1.0)"},tickActive:{strokeStyle:"rgba(99, 200, 255, 1.0)"},tickHover:{strokeStyle:"rgba(79, 180, 246, 1.0)"}},data:{default:{lineWidth:1,strokeStyle:"rgba(82, 144, 244, 1.0)"},filtered:{lineWidth:1,strokeStyle:"rgba(0, 0, 0, 0.05)"},overrideNaN:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overrideNegativeInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overridePositiveInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},path:{options:{},type:r.Straight},series:[]},dimension:{label:{angle:void 0,boundaryPadding:5,fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:16,placement:l.Before,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(99, 200, 255, 1.0)"},labelHover:{fillStyle:"rgba(79, 180, 246, 1.0)"},layout:i.AxisEvenlySpaced},padding:[32,64]}},m={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:Number.NaN,p1:Number.NaN,percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN},v={dimension:{axis:0,bound:void 0,boundOffset:void 0,offset:0},filters:{active:m,key:void 0},shared:{action:d,focus:void 0}},b=e=>"number"==typeof e,N=e=>"object"==typeof e&&null!=e&&Object.getPrototypeOf(e)===Object.prototype&&!Array.isArray(e)&&!(e=>e instanceof Map)(e)&&!S(e),S=e=>e instanceof Set,k=e=>"string"==typeof e,I=e=>JSON.parse(JSON.stringify(e)),M=(e,t)=>Math.min(t[1],Math.max(t[0],e)),L=(e,t)=>k(e)&&k(t)?e.localeCompare(t):e===t?0:e>t?1:-1,B=(...e)=>e.reduce(((e,t)=>(Object.keys(t).forEach((i=>{N(e[i])&&N(t[i])?e[i]=B(e[i],t[i]):(Array.isArray(e[i])&&Array.isArray(t[i]),e[i]=t[i])})),e)),{}),E=(e,t)=>e.reduce(((e,i)=>(b(i)&&!isNaN(i)&&((e=>t===s.Logarithmic?isFinite(Math.log(e)):isFinite(e))(i)&&(i<e.finite[0]&&(e.finite[0]=i),i>e.finite[1]&&(e.finite[1]=i)),i<e.actual[0]&&(e.actual[0]=i),i>e.actual[1]&&(e.actual[1]=i)),e)),{actual:[1/0,-1/0],finite:[Number.MAX_VALUE,-Number.MAX_VALUE]}),D=(e,t)=>e[t%e.length],w=(e,t,i,s,a={})=>{var n,l,r;const o=i>1?i-1:1,h=(e-t)/o;if(0!==Object.keys(a).length){const e=null!==(n=a.includeNaN)&&void 0!==n?n:0,t=(null!==(l=a.includeNegativeInfinity)&&void 0!==l?l:0)+e,o=(null!==(r=a.includePositiveInfinity)&&void 0!==r?r:0)+t,h=s/i;if(h<=e)return Number.NaN;if(h<=t)return Number.NEGATIVE_INFINITY;if(h<=o)return Number.POSITIVE_INFINITY}return s%(o+1)*h+t},O=e=>e[((e,t=0)=>Math.floor(Math.random()*(e-t))+t)(e.length)],P=(e,t,i={})=>{if(null!=i.includeNaN){const e=M(i.includeNaN,[0,1]);if(Math.random()<e)return Number.NaN}if(null!=i.includeNegativeInfinity){const e=M(i.includeNegativeInfinity,[0,1]);if(Math.random()<e)return-1/0}if(null!=i.includePositiveInfinity){const e=M(i.includePositiveInfinity,[0,1]);if(Math.random()<e)return 1/0}return Math.random()*(e-t)+t},z=e=>{let t=((e,t=6)=>{let i=e.toString();const s=Math.abs(e);return isNaN(e)?i="NaN":Number.isFinite(e)?0!==s&&(s<.01||s>999?i=e.toExponential(t):Number.isInteger(e)||(i=e.toFixed(t))):i=(e<0?"-":"")+"Infinity",i})(e);return t=t.replace(/(e)\+(\d+)/,"$1$2"),t=t.replace(/0+(e-?\d+)$/,"$1"),t=t.replace(/(\.[0-9]+?)0+$/,"$1"),t=t.replace(/\.(e)/,"$1"),t},F=(e,t={})=>{var i,s;const a=null!==(i=t.size)&&void 0!==i?i:24,n=null!==(s=t.suffix)&&void 0!==s?s:"...";return e.length<=a?e:`${e.substring(0,a)}${n}`},A=e=>k(e)?e:e.toString();class C{constructor(e,t,i,s={}){this.direction=e,this.minValue=t,this.maxValue=i,this.range=0,this.reverse=false,this.tickLabels=[],this.tickPos=[],this.ticks=[],this.tickPadding=0,this.tickSpacing=0,this.axisLength=1,this.maxTicks=1,this.dataOnEdge=true,this.max=i,this.min=t,null!=s.dataOnEdge&&(this.dataOnEdge=s.dataOnEdge),this.reverse=e===a.Horizontal?null!=s.reverse&&s.reverse:null==s.reverse||!s.reverse,this.setMinMaxValues(t,i,!1)}setAxisLength(e){this.axisLength=e,this.maxTicks=e/50,this.calculate()}setMinMaxValues(e,t,i=!0){if(e===t){const i=e;if(0===i)e=-1,t=1;else if(i<0){e=i-((t=-(2**(Math.log2(Math.abs(i))-1)))-i)}else{t=i+(i-(e=2**(Math.log2(i)-1)))}}this.minValue=e,this.maxValue=t,this.max=t,this.min=e,this.range=t-e,i&&this.calculate()}niceNum(e,t){const i=Math.abs(e),s=Math.floor(Math.log10(i)),a=i/10**s;let n;return n=t?a<1.5?1:a<3?2:a<7?5:10:a<=1?1:a<=2?2:a<=5?5:10,n*10**s}}class T extends C{constructor(e,t=[],i={}){super(e,0,0,i),this.direction=e,this.categories=t,this.reverse&&this.categories.reverse(),this.tickLabels=this.categories.map((e=>A(e)))}percentToValue(e){return this.posToValue(e*this.axisLength)}posToValue(e){let t=1/0,i=Number.NaN;for(let s=0;s<this.tickPos.length;s++){const a=this.tickPos[s],n=Math.abs(e-a);n<t&&(t=n,i=this.categories[s])}return i}valueToPercent(e){const t=A(e),i=this.tickLabels.findIndex((e=>e===t));return-1!==i?this.tickPos[i]/this.axisLength:0}valueToPos(e){return this.valueToPercent(e)*this.axisLength}calculate(){const e=this.tickLabels.length;let t=0;this.tickSpacing=this.axisLength/(this.dataOnEdge?e-1:e),this.tickPos=[];for(let i=0;i<e;i++)[0,e].includes(i)?t+=this.dataOnEdge?0:this.tickSpacing/2:t+=this.tickSpacing,this.tickPos.push(t)}}class R extends Error{constructor(e){super(`[Hermes] ${e instanceof Error?e.message:k(e)?e:"Critical error encountered!"}`)}}class _ extends C{constructor(e,t,i,s,a,n={}){super(e,t,i,n),this.direction=e,this.finiteMin=t,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.config=n,this.actualMax=a,this.actualMin=s}percentToValue(e){if(0===e)return this.reverse?this.actualMax:this.actualMin;if(1===e)return this.reverse?this.actualMin:this.actualMax;const t=this.dataOnEdge?this.minValue:this.min,i=this.dataOnEdge?this.maxValue:this.max;return(this.reverse?1-e:e)*(i-t)+t}posToValue(e){return this.percentToValue(e/this.axisLength)}valueToPercent(e){if(!b(e))return Number.NaN;if(e===this.actualMax)return this.reverse?0:1;if(e===this.actualMin)return this.reverse?1:0;const t=this.dataOnEdge?this.minValue:this.min,i=(e-t)/((this.dataOnEdge?this.maxValue:this.max)-t);return this.reverse?1-i:i}valueToPos(e){return this.valueToPercent(e)*this.axisLength}calculate(){this.range=this.niceNum(this.maxValue-this.minValue,!1),this.tickSpacing=this.niceNum(this.range/this.maxTicks,!0),this.min=Math.floor(this.minValue/this.tickSpacing)*this.tickSpacing,this.max=Math.ceil(this.maxValue/this.tickSpacing)*this.tickSpacing;const e=Math.round((this.max-this.min)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let t=0;t<=e;t++){let i=t*this.tickSpacing+this.min;this.dataOnEdge&&0===t&&(i=this.minValue),this.dataOnEdge&&t===e&&(i=this.maxValue),this.ticks.push(i);let s=z(i);this.dataOnEdge&&[0,e].includes(t)&&(s=`*${s}`),this.tickLabels.push(s)}this.tickPos=this.ticks.map((e=>this.valueToPos(e)))}}const V=e=>t=>Math.log(t)/Math.log(e);class $ extends C{constructor(e,t,i,s,a,n=10,l={}){super(e,t,i,l),this.direction=e,this.finiteMin=t,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.logBase=n,this.maxExp=Number.NaN,this.maxExpExact=Number.NaN,this.minExp=Number.NaN,this.minExpExact=Number.NaN,this.log=V(n),this.logBase=n,this.actualMax=a,this.actualMin=s}setLogBase(e=10){this.logBase=e,this.calculate()}percentToValue(e){if(0===e)return this.reverse?this.actualMax:this.actualMin;if(1===e)return this.reverse?this.actualMin:this.actualMax;const t=this.dataOnEdge?this.minExpExact:this.minExp,i=(this.reverse?1-e:e)*this.rangeExp()+t;return this.logBase**i}posToValue(e){return this.percentToValue(e/this.axisLength)}valueToPercent(e){if(!b(e))return 0;const t=this.log(e),i=this.dataOnEdge?this.minExpExact:this.minExp,s=(t-i)/((this.dataOnEdge?this.maxExpExact:this.maxExp)-i);return this.reverse?1-s:s}valueToPos(e){return this.valueToPercent(e)*this.axisLength}rangeExp(){return this.dataOnEdge?this.maxExpExact-this.minExpExact:this.maxExp-this.minExp}calculate(){this.log=V(this.logBase),this.minExpExact=this.log(this.minValue),this.maxExpExact=this.log(this.maxValue),this.minExp=Math.floor(this.minExpExact),this.maxExp=Math.ceil(this.maxExpExact),this.range=this.logBase**this.maxExp-this.logBase**this.minExp,this.tickSpacing=1;const e=Math.round((this.maxExp-this.minExp)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let t=0;t<=e;t++){const i=t*this.tickSpacing+this.minExp;let s=this.logBase**i;this.dataOnEdge&&0===t&&(s=this.logBase**this.minExpExact),this.dataOnEdge&&t===e&&(s=this.logBase**this.maxExpExact),this.ticks.push(s);let a=z(s);this.dataOnEdge&&[0,e].includes(t)&&(a=`*${a}`),this.tickLabels.push(a)}this.tickPos=this.ticks.map((e=>this.valueToPos(e)))}}const H=(e,t)=>e.x*t.x+e.y*t.y,W=(e,t,i,s)=>{const a={x:s.x-t.x,y:s.y-t.y},n={x:i.x-t.x,y:i.y-t.y},l={x:e.x-t.x,y:e.y-t.y},r=H(a,a),o=H(a,n),h=H(a,l),c=H(n,n),d=H(n,l),u=1/(r*c-o*o),f=(c*h-o*d)*u,p=(r*d-o*h)*u;return f>=0&&p>=0&&f+p<1},J=(e,t,i={})=>{if(e.save(),i.fillStyle){e.fillStyle=i.fillStyle,e.beginPath(),e.moveTo(t[0].x,t[0].y);for(let i=1;i<t.length;i++)e.lineTo(t[i].x,t[i].y);e.closePath(),e.fill()}if(i.strokeStyle){e.lineCap=i.lineCap||f,e.lineDashOffset=i.lineDashOffset||0,e.lineJoin=i.lineJoin||p,e.lineWidth=i.lineWidth||1,e.miterLimit=i.miterLimit||y,e.strokeStyle=i.strokeStyle,e.beginPath(),e.moveTo(t[0].x,t[0].y);for(let i=1;i<t.length;i++)e.lineTo(t[i].x,t[i].y);e.closePath(),e.stroke()}e.restore()},j=(e,t,i,s,a={})=>{var n;if(t.length<2)return;e.save(),e.lineCap=a.lineCap||f,e.lineDashOffset=a.lineDashOffset||0,e.lineJoin=a.lineJoin||p,e.lineWidth=a.lineWidth||1,e.miterLimit=a.miterLimit||y,e.strokeStyle=a.strokeStyle||g,e.beginPath(),e.moveTo(t[0].x,t[0].y);const l=null!==(n=s.options.bezierFactor)&&void 0!==n?n:.3;for(let a=1;a<t.length;a++){const[n,o]=[t[a].x,t[a].y];if(s.type===r.Straight)e.lineTo(n,o);else if(s.type===r.Bezier){const[s,r]=[t[a-1].x,t[a-1].y],[h,c]=[s+(i?(n-s)*l:0),r+(i?0:(o-r)*l)],[d,u]=[n-(i?(n-s)*l:0),o-(i?0:(o-r)*l)];e.bezierCurveTo(h,c,d,u,n,o)}}e.stroke(),e.restore()},q=(e,t,i,s,a,n={})=>{e.save(),e.lineCap=n.lineCap||f,e.lineDashOffset=n.lineDashOffset||0,e.lineJoin=n.lineJoin||p,e.lineWidth=n.lineWidth||1,e.miterLimit=n.miterLimit||y,e.strokeStyle=n.strokeStyle||g,e.beginPath(),e.setLineDash(n.lineDash||[]),e.moveTo(ee(t),ee(i)),e.lineTo(ee(s),ee(a)),e.stroke(),e.restore()},U=(e,t,i,s,a,n={})=>{e.save();const l=ee(t),r=ee(i),o=n.cornerRadius||0;n.fillStyle&&(e.fillStyle=n.fillStyle,0===o?e.fillRect(l,r,s,a):(G(e,l,r,s,a,o),e.fill())),n.strokeStyle&&(e.lineCap=n.lineCap||f,e.lineDashOffset=n.lineDashOffset||0,e.lineJoin=n.lineJoin||p,e.lineWidth=n.lineWidth||1,e.miterLimit=n.miterLimit||y,e.strokeStyle=n.strokeStyle,0===o?e.strokeRect(l,r,s,a):(G(e,l,r,s,a,o),e.stroke())),e.restore()},G=(e,t,i,s,a,n)=>{e.beginPath(),e.moveTo(t+n,i),e.lineTo(t+s-n,i),e.quadraticCurveTo(t+s,i,t+s,i+n),e.lineTo(t+s,i+a-n),e.quadraticCurveTo(t+s,i+a,t+s-n,i+a),e.lineTo(t+n,i+a),e.quadraticCurveTo(t,i+a,t,i+a-n),e.lineTo(t,i+n),e.quadraticCurveTo(t,i,t+n,i),e.closePath()},X=(e,t,i,s,a,n={})=>{const l=Z(a),r=l>Math.PI/2&&l<=3*Math.PI/2,o=-a-(r?Math.PI:0);e.save(),te(e,n.font),e.direction=n.direction||"inherit",e.textAlign=n.textAlign||(r?"right":"left"),e.textBaseline=n.textBaseline||"middle",o%2*Math.PI!=0&&(e.translate(i,s),e.rotate(o),e.translate(-i,-s)),n.strokeStyle&&(e.lineCap=n.lineCap||f,e.lineDashOffset=n.lineDashOffset||0,e.lineJoin=n.lineJoin||p,e.lineWidth=n.lineWidth||1,e.miterLimit=n.miterLimit||y,e.strokeStyle=n.strokeStyle,e.strokeText(t,i,s)),n.fillStyle&&(e.fillStyle=n.fillStyle,e.fillText(t,i,s)),e.restore()},Y=(e,t,i,s,a,n=0,l=0,r=0)=>{const o=e+n-r,h=t+l-r,c=e+i+n+r,d=t+s+l+r,u=[{x:o,y:h},{x:c,y:h},{x:c,y:d},{x:o,y:d}];if(null!=a){const i=Z(a);return u.map((s=>((e,t,i,s=0,a=0)=>{const n=e-s,l=t-a,r=Math.cos(i),o=Math.sin(i);return{x:r*n-o*l+s,y:o*n+r*l+a}})(s.x,s.y,-i,e,t)))}return u},K=(e,t,i=u)=>{te(e,i);const s=e.measureText(t),a=s.actualBoundingBoxLeft+s.actualBoundingBoxRight;return{h:s.actualBoundingBoxAscent+s.actualBoundingBoxDescent,w:a}},Q=e=>{const t=devicePixelRatio<=1?1:2-.5**(devicePixelRatio-1);return Array.isArray(e)?2===e.length?[e[0]*t,e[1]*t,e[0]*t,e[1]*t]:e.map((e=>e*t)):new Array(4).fill(e*t)},Z=e=>(e+2*Math.PI)%(2*Math.PI),ee=e=>Math.round(e-.5)+.5,te=(e,t=u)=>{const i=new RegExp(/(-?\d*\.?\d+)px/),s=t.match(i);if(2===(null==s?void 0:s.length)){const a=Math.round(parseFloat(s[1])*devicePixelRatio);e.font=t.replace(i,`${a}px`)}else e.font=t},ie=(e,t)=>{const i=e.length;if(i<1)return"#000000";if(1===i)return e[0];const s=t*(i-1),a=Math.floor(s),n=Math.ceil(s),l=((e,t,i)=>{const s=Math.round((t.r-e.r)*i+e.r),a=Math.round((t.g-e.g)*i+e.g),n=Math.round((t.b-e.b)*i+e.b);if(null!=e.a&&null!=t.a)return{a:(t.a-e.a)*i+e.a,b:n,g:a,r:s};return{b:n,g:a,r:s}})(se(e[a]),se(e[n]),s-a);return(e=>null!=e.a?`rgba(${e.r}, ${e.g}, ${e.b}, ${e.a})`:`rgb(${e.r}, ${e.g}, ${e.b})`)(l)},se=e=>{if(/^#/.test(e))return(e=>{const t={b:0,g:0,r:0},i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return i&&i.length>3&&(t.r=parseInt(i[1],16),t.g=parseInt(i[2],16),t.b=parseInt(i[3],16)),t})(e);const t=/^rgba?\(\s*?(\d+)\s*?,\s*?(\d+)\s*?,\s*?(\d+)\s*?(,\s*?([\d.]+)\s*?)?\)$/i.exec(e);if(t&&t.length>3){const e={a:1,b:0,g:0,r:0};return e.r=parseInt(t[1]),e.g=parseInt(t[2]),e.b=parseInt(t[3]),t.length>5&&void 0!==t[5]&&(e.a=parseFloat(t[5])),e}return{a:1,b:0,g:0,r:0}},ae=(e,t)=>{const i=t.getBoundingClientRect();return{x:(e.clientX-i.x)*devicePixelRatio,y:(e.clientY-i.y)*devicePixelRatio}},ne=(e,t)=>{let i;return(...s)=>{null==i&&(i=setTimeout((()=>{e(...s),i=void 0}),t))}},le=(e,i,s)=>{const a=i.shared.action,n=a.type===t.LabelMove&&a.dimIndex===e,l=i.dimension.bound||c,r=i.dimension.boundOffset||{x:0,y:0};return n?(h=r,{h:(o=l).h,w:o.w,x:o.x+h.x,y:o.y+h.y}):s;var o,h},re=e=>1===L(e.p0,e.p1)?[e.p1,e.p0]:[e.p0,e.p1],oe=e=>isNaN(e.p0)&&isNaN(e.p1),he=(e,t)=>{const i=I(m);return e.p0<t.p0?(i.p0=e.p0,i.percent0=e.percent0,i.value0=e.value0):(i.p0=t.p0,i.percent0=t.percent0,i.value0=t.value0),e.p1>t.p1?(i.p1=e.p1,i.percent1=e.percent1,i.value1=e.value1):(i.p1=t.p1,i.percent1=t.percent1,i.value1=t.value1),i.hasNaN=e.hasNaN||t.hasNaN,i.hasNegativeInfinity=e.hasNegativeInfinity||t.hasNegativeInfinity,i.hasPositiveInfinity=e.hasPositiveInfinity||t.hasPositiveInfinity,i},ce={accuracy:[.55,.99],dropout:[.2,.8],"global-batch-size":[5,30],"layer-free-decay":[.001,.1],"layer-split-factor":[1,16],"learning-rate":[1e-4,.1],"learning-rate-decay":[1e-6,.001],loss:[1.7,2.4],"metrics-base":[.5,.9],"n-filters":[8,64]},de=[{dataOnEdge:!1,key:"dropout",label:"Dropout",type:s.Linear},{dataOnEdge:!1,key:"global-batch-size",label:"Global Batch Size",type:s.Linear},{categories:[4,8,16,32,64],dataOnEdge:!1,key:"layer-dense-size",label:"Layer Dense Size",type:s.Categorical},{dataOnEdge:!1,key:"layer-free-decay",label:"Layer Free Decay",logBase:10,type:s.Logarithmic},{categories:[!0,!1],dataOnEdge:!1,key:"layer-inverse",label:"Layer Inverse",type:s.Categorical},{dataOnEdge:!1,key:"learning-rate",label:"Learning Rate",logBase:10,type:s.Logarithmic},{dataOnEdge:!1,key:"learning-rate-decay",label:"Learning Rate Decay",logBase:10,type:s.Logarithmic},{dataOnEdge:!1,key:"layer-split-factor",label:"Layer Split Factor",logBase:2,type:s.Logarithmic},{dataOnEdge:!1,key:"metrics-base",label:"Metrics Base",type:s.Linear},{dataOnEdge:!1,key:"n-filters",label:"N Filters",type:s.Linear}],ue=[{dataOnEdge:!0,disableDrag:!0,key:"accuracy",label:"Accuracy",type:s.Linear},{dataOnEdge:!0,disableDrag:!0,key:"loss",label:"Loss",type:s.Logarithmic}];var fe=Object.freeze({__proto__:null,DEFAULT_DIMENSION_COUNT:10,dimensionRanges:ce,dimensionSamples:de,metricDimensionSamples:ue,generateData:(e,t,i=!0,a={})=>e.reduce(((e,n)=>(e[n.key]=new Array(t).fill(null).map(((e,l)=>{if(n.type===s.Categorical){if(n.categories)return i?O(n.categories):D(n.categories,l)}else if(n.type===s.Linear){const e=ce[n.key];if(e)return i?P(e[1],e[0],a):w(e[1],e[0],t,l,a)}else if(n.type===s.Logarithmic){const e=ce[n.key];if(e&&n.logBase)return i?((e,t,i,s={})=>{const a=10===e?Math.log10:2===e?Math.log2:Math.log,n=a===Math.log?Math.log(e):1,l=a(t)/n,r=a(i)/n,o=P(l,r,s);return isNaN(o)||!isFinite(o)?o:e**o})(n.logBase,e[1],e[0],a):((e,t,i,s,a,n={})=>{const l=10===e?Math.log10:2===e?Math.log2:Math.log,r=l===Math.log?Math.log(e):1,o=l(t)/r,h=l(i)/r;return e**w(o,h,s,a,n)})(n.logBase,e[1],e[0],t,l)}return o})),e)),{}),generateDimensions:(e=10,t=!0)=>{const i=new Array(e-1).fill(null).map(((e,i)=>t?O(de):D(de,i))),s=t?O(ue):D(ue,0);return i.push(s),i}});class pe{constructor(e,t,i,s){this.config=x,this.data={},this.dataInfo={hasInfinity:!1,hasNaN:!1,seriesCount:0},this.dimensions=[],this.dimensionsOriginal=[],this.filters={},this.size={h:0,w:0},this.ix=I(v),this._=void 0;const a=(e=>k(e)?document.querySelector(e):e)(e);if(!a)throw new R("Target element selector did not match anything.");this.element=a;const n=this.element.getBoundingClientRect();if(0===n.width||0===n.height)throw new R("Target element width and height must both be greater than 0px.");const l=this.element.querySelectorAll("canvas");0===l.length?(this.canvas=document.createElement("canvas"),this.element.appendChild(this.canvas)):this.canvas=l[0];const r=this.canvas.getContext("2d");if(!r)throw new R("Unable to get context from target element.");this.ctx=r,t&&this.setDimensions(t,!1),i&&this.setConfig(i,!1),s&&this.setData(s,!1),(t||i||s)&&this.redraw(),this.listeners={dblclick:this.handleDoubleClick.bind(this),mousedown:this.handleMouseDown.bind(this),mousemove:0===this.config.interactions.throttleDelayMouseMove?this.handleMouseMove.bind(this):ne((e=>this.handleMouseMove.bind(this)(e)),this.config.interactions.throttleDelayMouseMove),mouseup:this.handleMouseUp.bind(this)},this.enable()}static deepMerge(...e){return B(...e)}static getTester(){return fe}static validateData(e,t){const i={count:0,message:"",valid:!0},s=Object.keys(e),a=Object.values(e);for(let e=0;e<a.length;e++){const t=a[e];if(0===e)i.count=t.length;else if(t.length!==i.count)return i.message="The dimension data are not uniform in size.",i.valid=!1,i;if(-1!==t.findIndex((e=>null==e))){const a=null===t;return i.message=`Data for "${s[e]}" has ${a?"null":"undefined"}`,i.valid=!1,i}}const n=Object.keys(e);for(let e=0;e<t.length;e++){const s=t[e].key;if(!n.includes(s))return i.message=`Data for "${s} is missing.`,i.valid=!1,i}return i}static validateDimension(e){if(e.type===s.Categorical){if(!e.categories||0===e.categories.length)return{message:`Categorical dimension "${e.key}" is missing "categories".`,valid:!1}}else if(e.type===s.Logarithmic&&(null==e.logBase||0===e.logBase))return{message:`Logarithmic dimension "${e.key}" is missing "logBase".`,valid:!1};return{message:"",valid:!0}}static validateDimensions(e){if(0===e.length)return{message:"Need at least one dimension defined.",valid:!1};for(let t=0;t<e.length;t++){const{message:i,valid:s}=pe.validateDimension(e[t]);if(!s)return{message:i,valid:s}}return{message:"",valid:!0}}setConfig(e={},t=!0){this.config=B(x,e),this.addObservers(),t&&this.redraw()}setData(e,t=!0){const i=pe.validateData(e,this.dimensionsOriginal);if(!i.valid)throw new R(i.message);this.data=e,this.dataInfo=(e=>{const t=Object.keys(e),i={hasInfinity:!1,hasNaN:!1,seriesCount:0};for(const s of t){i.seriesCount=i.seriesCount||e[s].length;for(const t of e[s])isNaN(t)&&(i.hasNaN=!0),isNaN(t)||isFinite(t)||(i.hasInfinity=!0)}return i})(this.data),this.setDimensions(this.dimensionsOriginal,!1),t&&this.redraw()}setDimensions(e,t=!0){const i=pe.validateDimensions(e);if(!i.valid)throw new R(i.message);const n=this.config.direction===a.Horizontal?a.Vertical:a.Horizontal;this.dimensionsOriginal=e,this.dimensions=I(e).map((e=>{const t=e.key,i=this.data[t]||[],a={...e,labelTruncated:F(e.label,{size:this.config.style.dimension.label.truncate}),rangeActual:void 0,rangeFinite:void 0,scale:new _(n,0,100,0,100)};if(e.type===s.Linear||e.type===s.Logarithmic){const t=E(i,e.type);e.type===s.Linear?a.scale=new _(n,t.finite[0],t.finite[1],t.actual[0],t.actual[1],e):e.type===s.Logarithmic&&(a.scale=new $(n,t.finite[0],t.finite[1],t.actual[0],t.actual[1],e.logBase,e))}else e.type===s.Categorical&&(a.scale=new T(n,e.categories,e));return a})),t&&this.redraw()}setSize(e,t,i=!0){var s,a;const n={h:this.size.h,w:this.size.w},l=Math.round(e*devicePixelRatio),r=Math.round(t*devicePixelRatio);this.canvas.width=l,this.canvas.height=r,this.canvas.style.width=`${e}px`,this.canvas.style.height=`${t}px`,this.size={h:r,w:l},null===(a=(s=this.config.hooks).onResize)||void 0===a||a.call(s,this.size,n),i&&this.redraw()}disable(){this.removeListeners(),this.removeObservers(),this.ix=I(v),this.updateCursor(),this.redraw()}enable(){this.addListeners(),this.addObservers()}redraw(){0===this.size.w&&0===this.size.h||(this.calculate(),this.clear(),this.config.debug&&this.drawDebugOutline(),this.draw())}destroy(){this.removeListeners(),this.removeObservers(),this.canvas&&this.element.contains(this.canvas)&&this.element.removeChild(this.canvas)}addListeners(){this.element.addEventListener("dblclick",this.listeners.dblclick),this.element.addEventListener("mousedown",this.listeners.mousedown),window.addEventListener("mousemove",this.listeners.mousemove),window.addEventListener("mouseup",this.listeners.mouseup)}addObservers(){this.resizeObserver&&(this.resizeObserver.unobserve(this.element),this.resizeObserver=void 0),this.resizeObserver=new ResizeObserver(0===this.config.interactions.throttleDelayResize?this.handleResize.bind(this):ne((e=>this.handleResize.bind(this)(e)),this.config.interactions.throttleDelayResize)),this.resizeObserver.observe(this.element)}removeListeners(){this.element.removeEventListener("dblclick",this.listeners.dblclick),this.element.removeEventListener("mousedown",this.listeners.mousedown),window.removeEventListener("mousemove",this.listeners.mousemove),window.removeEventListener("mouseup",this.listeners.mouseup)}removeObservers(){var e;null===(e=this.resizeObserver)||void 0===e||e.unobserve(this.element),this.resizeObserver=void 0}calculate(){this.calculateLayout(),this.calculateStyles()}calculateLayout(){var e,t;const s={dims:{list:new Array(this.dimensions.length).fill(void 0).map((()=>({axes:{},label:{},layout:{}}))),map:this.dimensions.reduce(((e,t,i)=>(e[t.key]=i,e)),{}),shared:{axes:{},label:{},layout:{}}},layout:{drawRect:{},padding:Q(this.config.style.padding)}},{h:n,w:r}=this.size,o=s.layout,h=s.dims.shared.axes,c=s.dims.shared.label,d=s.dims.shared.layout,u=this.dimensions.length,f=this.config.direction===a.Horizontal,p=this.config.style.dimension.label,y=this.config.style.dimension.label.boundaryPadding,g=this.config.style.dimension.layout,x=this.config.style.axes.label,m=this.config.style.axes.axis,v=this.config.style.axes.axis.boundaryPadding,b=p.placement===l.Before,N=null!=p.angle,S=x.placement===l.Before;if(o.drawRect={h:n-o.padding[0]-o.padding[2],w:r-o.padding[1]-o.padding[3],x:o.padding[3],y:o.padding[0]},c.cos=N?Math.cos(null!==(e=p.angle)&&void 0!==e?e:0):void 0,c.sin=N?Math.sin(null!==(t=p.angle)&&void 0!==t?t:0):void 0,c.rad=p.angle||(f?void 0:b?-Math.PI:0),c.maxLengthCos=0,c.maxLengthSin=0,this.dimensions.forEach(((e,t)=>{const i=K(this.ctx,e.labelTruncated,p.font),a=s.dims.list[t].label;a.w=i.w,a.h=i.h,a.lengthCos=N?i.w*c.cos:i.w,a.lengthSin=N?i.w*c.sin:i.h,Math.abs(a.lengthCos)>Math.abs(c.maxLengthCos)&&(c.maxLengthCos=a.lengthCos),Math.abs(a.lengthSin)>Math.abs(c.maxLengthSin)&&(c.maxLengthSin=a.lengthSin)})),h.start=h.stop=0,h.startInfinity=h.stopInfinity=h.startNaN=h.stopNaN=void 0,f){if(b){const e=Math.max(0,c.maxLengthSin);h.start=o.padding[0]+e+p.offset,h.stop=n-o.padding[2]}else{const e=N?Math.max(0,-c.maxLengthSin):c.maxLengthSin;h.start=o.padding[0],h.stop=n-o.padding[2]-e-p.offset}h.stopNaN=this.dataInfo.hasNaN?h.stop:void 0,h.startInfinity=h.start,h.stopInfinity=h.stop-(this.dataInfo.hasNaN?m.nanGap:0),h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}else{if(b){const e=N?Math.max(0,-c.maxLengthCos):c.maxLengthCos;h.start=o.padding[3]+e+p.offset,h.stop=r-o.padding[1]}else{const e=Math.max(0,c.maxLengthCos);h.start=o.padding[3],h.stop=r-o.padding[1]-e-p.offset}h.startNaN=this.dataInfo.hasNaN?h.start:void 0,h.startInfinity=h.start+(this.dataInfo.hasNaN?m.nanGap:0),h.stopInfinity=h.stop,h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}if(h.length=h.stop-h.start,h.labelFactor=S?-1:1,d.totalBoundSpace=0,this.dimensions.forEach(((e,t)=>{const i=s.dims.list[t].axes,a=s.dims.list[t].label,l=s.dims.list[t].layout,c=e.scale;i.tickLabels=[],i.tickPos=[],i.maxLength=0,c&&(c.setAxisLength(h.stopData-h.startData),i.tickLabels=c.tickLabels.slice(),i.tickPos=c.tickPos.slice(),c.tickLabels.forEach((e=>{const t=K(this.ctx,e,x.font);i.maxLength=Math.max(t.w,i.maxLength)}))),N?(l.spaceBefore=f?a.lengthCos<0?-a.lengthCos:0:a.lengthSin>0?a.lengthSin:0,l.spaceAfter=f?a.lengthCos>0?a.lengthCos:0:a.lengthSin<0?-a.lengthSin:0):(l.spaceBefore=(f?a.lengthCos:a.lengthSin)/2,l.spaceAfter=(f?a.lengthCos:a.lengthSin)/2),S?l.spaceBefore=Math.max(l.spaceBefore,i.maxLength):l.spaceAfter=Math.max(l.spaceAfter,i.maxLength),f?(l.bound={h:n-o.padding[0]-o.padding[2],w:l.spaceBefore+l.spaceAfter,x:0,y:o.padding[0]},d.totalBoundSpace+=l.bound.w):(l.bound={h:l.spaceBefore+l.spaceAfter,w:r-o.padding[1]-o.padding[3],x:o.padding[3],y:0},d.totalBoundSpace+=l.bound.h)})),f){const e=o.drawRect.w-d.totalBoundSpace;d.gap=u>1?Math.max(e,0)/(u-1):0,d.offset=o.padding[3],d.space=u>1?o.drawRect.w/(u-1):0}else{const e=o.drawRect.h-d.totalBoundSpace;d.gap=u>1?Math.max(e,0)/(u-1):0,d.offset=o.padding[0],d.space=u>1?o.drawRect.h/(u-1):0}let k=d.offset;for(let e=0;e<s.dims.list.length;e++){const t=s.dims.list[e].label,a=s.dims.list[e].layout;f?(g===i.AxisEvenlySpaced?(a.bound.x=k-a.spaceBefore,k+=d.space):g===i.Equidistant&&(a.bound.x=k,k+=d.gap+a.bound.w),a.axisBoundaryStart={x:a.spaceBefore,y:h.start-o.padding[0]},a.axisBoundaryStop={x:a.spaceBefore,y:h.stop-o.padding[0]},a.axisInfinityStart={x:a.spaceBefore,y:h.startInfinity-o.padding[0]},a.axisInfinityStop={x:a.spaceBefore,y:h.stopInfinity-o.padding[0]},a.axisDataStart={x:a.spaceBefore,y:h.startData-o.padding[0]},a.axisDataStop={x:a.spaceBefore,y:h.stopData-o.padding[0]},a.labelPoint={x:a.spaceBefore,y:b?h.start-p.offset-o.padding[0]:h.stop+p.offset-o.padding[0]}):(g===i.AxisEvenlySpaced?(a.bound.y=k-a.spaceBefore,k+=d.space):g===i.Equidistant&&(a.bound.y=k,k+=d.gap+a.bound.h),a.axisBoundaryStart={x:h.start-o.padding[3],y:a.spaceBefore},a.axisBoundaryStop={x:h.stop-o.padding[3],y:a.spaceBefore},a.axisInfinityStart={x:h.startInfinity-o.padding[3],y:a.spaceBefore},a.axisInfinityStop={x:h.stopInfinity-o.padding[3],y:a.spaceBefore},a.axisDataStart={x:h.startData-o.padding[3],y:a.spaceBefore},a.axisDataStop={x:h.stopData-o.padding[3],y:a.spaceBefore},a.labelPoint={x:b?h.start-p.offset-o.padding[1]:h.stop+p.offset-o.padding[1],y:a.spaceBefore});const n=f?-t.w/2:0,l=f?b?-t.h:0:-t.h/2;a.labelBoundary=Y(a.bound.x+a.labelPoint.x,a.bound.y+a.labelPoint.y,t.w,t.h,c.rad,N?0:n,N?-t.h/2:l,y),a.axisBoundary=[{x:a.bound.x+a.axisBoundaryStart.x-(f?v:0),y:a.bound.y+a.axisBoundaryStart.y-(f?0:v)},{x:a.bound.x+a.axisBoundaryStart.x+(f?v:0),y:a.bound.y+a.axisBoundaryStart.y+(f?0:v)},{x:a.bound.x+a.axisBoundaryStop.x+(f?v:0),y:a.bound.y+a.axisBoundaryStop.y+(f?0:v)},{x:a.bound.x+a.axisBoundaryStop.x-(f?v:0),y:a.bound.y+a.axisBoundaryStop.y-(f?0:v)}]}this._=s}calculateStyles(){if(!this._)return;this._.styles=this._.styles||[];const e=this.config.style,i=e.axes,s=e.dimension,a=this._.dims.list,l=this._.styles,r=this.ix.shared.action,o=this.ix.shared.focus,h=r.type!==t.None;for(let e=0;e<a.length;e++){const a=this.dimensions[e].key,c=this.filters[a]||[],d=r.type===t.LabelMove&&r.dimIndex===e,u=(null==o?void 0:o.type)===n.DimensionLabel&&(null==o?void 0:o.dimIndex)===e,f=(r.type===t.FilterCreate||r.type===t.FilterMove||r.type===t.FilterResizeAfter||r.type===t.FilterResizeBefore)&&r.dimIndex===e,p=((null==o?void 0:o.type)===n.DimensionAxis||(null==o?void 0:o.type)===n.Filter||(null==o?void 0:o.type)===n.FilterResize)&&(null==o?void 0:o.dimIndex)===e;l[e]=l[e]||{},l[e].label={...s.label,...d||!u||h?{}:s.labelHover,...d?s.labelActive:{}},l[e].axis={...i.axis,...f||!p||h?{}:i.axisHover,...f?i.axisActive:{}},l[e].tick={...i.tick,...f||!p||h?{}:i.tickHover,...f?i.tickActive:{}},l[e].tickLabel={...i.label,...f||!p||h?{}:i.labelHover,...f?i.labelActive:{}},l[e].filters=c.map(((t,s)=>{const a=((null==o?void 0:o.type)===n.Filter||(null==o?void 0:o.type)===n.FilterResize)&&(null==o?void 0:o.dimIndex)===e&&(null==o?void 0:o.filterIndex)===s,l=f||p&&!a,h=a&&void 0===r.filterIndex,c=r.dimIndex===e&&r.filterIndex===s;return{...i.filter,...l?i.filterAxisHover:{},...h?i.filterHover:{},...c?i.filterActive:{}}}))}}getFocusByPoint(e){if(!this._)return;const t=this._.dims.shared.axes,i=this.config.direction===a.Horizontal?"y":"x",s=this._.dims.shared.axes.length;for(let a=0;a<this._.dims.list.length;a++){const l=this.dimensions[a].key,r=this._.dims.list[a].layout,o=r.labelBoundary;if((W(e,o[0],o[1],o[2])||W(e,o[2],o[3],o[0]))&&!this.dimensions[a].disableDrag)return{dimIndex:a,type:n.DimensionLabel};const h=r.axisBoundary;if(W(e,h[0],h[1],h[2])||W(e,h[2],h[3],h[0])){const o=this.filters[l]||[],h=r.bound[i]+r.axisBoundaryStart[i],c=(e[i]-h)/s,d=o.findIndex((e=>c>=e.p0&&c<=e.p1));let u=n.DimensionAxis;if(-1!==d){const e=3/t.length,i=o[d];u=c<=i.p0+e||c>=i.p1-e?n.FilterResize:n.Filter}return{dimIndex:a,filterIndex:d,type:u}}}}updateActiveLabel(){var e,i;if(!this._||this.ix.shared.action.type!==t.LabelMove)return;const s=this._.dims.list,n=this.ix,l=n.dimension,r=n.shared.action,o=this.config.direction===a.Horizontal,h=o?"x":"y";l.boundOffset={x:o?r.p1.x-r.p0.x:0,y:o?0:r.p1.y-r.p0.y};let c=-1;const d=l.axis+l.boundOffset[h];for(let e=0;e<s.length;e++){if(r.dimIndex===e||this.dimensions[e].disableDrag)continue;const t=s[e].layout,i=t.bound[h]+t.axisBoundaryStart[h],a=Math.abs(d-i)<30;if(r.dimIndex<e){if(d<i&&!a)break;c=e}if(r.dimIndex>e&&(d<i||a)){c=e;break}}if(-1!==c){const t=r.dimIndex,s=this.dimensions.splice(r.dimIndex,1);if(0===s.length)return;this.dimensions.splice(c,0,s[0]),r.dimIndex=c,null===(i=(e=this.config.hooks).onDimensionMove)||void 0===i||i.call(e,s[0],c,t)}}setConfigFilters(e={}){if(this.calculate(),!this._)return;const t=this._.dims.map;Object.keys(e).forEach((e=>{this.filters[e]=this.config.filters[e].map((i=>{const s={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:i[0],p1:i[1],percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN};return this.processFilter(s,t[e]),s}))})),this.redraw()}setActiveFilter(e,i){if(!this._)return;const s=this.filters,a=this.ix,n=a.shared.action,l=a.filters,r=this._.dims.shared.axes,o=(s[e]||[]).findIndex((e=>i>=e.p0&&i<=e.p1));-1!==o?(l.active=s[e][o],l.active.startP0=l.active.p0,l.active.startP1=l.active.p1,n.filterIndex=o,i>=l.active.p0&&i<=l.active.p0+3/r.length?n.type=t.FilterResizeBefore:i>=l.active.p1-3/r.length&&i<=l.active.p1?n.type=t.FilterResizeAfter:n.type=t.FilterMove):(n.type=t.FilterCreate,l.active={...m,p0:i,p1:i},s[e]=s[e]||[],s[e].push(l.active),n.filterIndex=s[e].length-1)}updateActiveFilter(e){var i,s,n,l,r,o,h,c,d,u,f,p;if(!this._)return;const y=this._.dims.list,g=this._.dims.shared.axes,x=this.ix,v=x.filters,b=x.shared.action,N=this.filters,S=b.dimIndex,k=this.config.direction===a.Horizontal?"y":"x";if(!(b.type===t.FilterCreate||b.type===t.FilterMove||b.type===t.FilterResizeAfter||b.type===t.FilterResizeBefore)||!v.key)return;const I=this.dimensions[b.dimIndex].key,B=y[b.dimIndex].layout.bound,E=y[b.dimIndex].layout.axisBoundaryStart[k];if(b.type===t.FilterMove){const e=null!==(i=v.active.startP0)&&void 0!==i?i:0,t=null!==(s=v.active.startP1)&&void 0!==s?s:0,a=t-e,n=(b.p1[k]-b.p0[k])/g.length;v.active.p0=e+n,v.active.p1=t+n,v.active.p0<=0?(v.active.p0=0,v.active.p1=a):v.active.p1>=1&&(v.active.p0=1-a,v.active.p1=1)}else b.type===t.FilterResizeBefore?(v.active.p0=(b.p1[k]-B[k]-E)/g.length,v.active.p0=M(v.active.p0,[0,1])):(v.active.p1=(b.p1[k]-B[k]-E)/g.length,v.active.p1=M(v.active.p1,[0,1]));if(this.processFilter(v.active,S),"mouseup"===e.type){if(D=b.p0,w=b.p1,Math.sqrt((w.x-D.x)**2+(w.y-D.y)**2)<1){const e=N[v.key]||[],t=(v.active.p1-v.active.p0)/2+v.active.p0,i=e.findIndex((e=>t>=e.p0&&t<=e.p1));if(-1!==i){const t=re(e[i]);null===(l=(n=this.config.hooks).onFilterRemove)||void 0===l||l.call(n,{[I]:[t]}),e.splice(i,1)}}else{if(v.active.p1<v.active.p0){const e=v.active.p1;v.active.p1=v.active.p0,v.active.p0=e,this.processFilter(v.active,S)}const e={[I]:[re(v.active)]};switch(b.type){case t.FilterCreate:null===(o=(r=this.config.hooks).onFilterCreate)||void 0===o||o.call(r,e);break;case t.FilterMove:null===(c=(h=this.config.hooks).onFilterMove)||void 0===c||c.call(h,e);break;case t.FilterResizeAfter:case t.FilterResizeBefore:null===(u=(d=this.config.hooks).onFilterResize)||void 0===u||u.call(d,e)}}var D,w,O;v.active={...m},v.key=void 0,this.cleanUpFilters(),null===(p=null===(f=this.config.hooks)||void 0===f?void 0:f.onFilterChange)||void 0===p||p.call(f,(O=this.filters,Object.keys(O).reduce(((e,t)=>(e[t]=O[t].map((e=>re(e))).sort(((e,t)=>L(e[0],t[0]))),e)),{})))}}processFilter(e,t){if(!this._)return;const i=this._.dims.list[t].layout,s=this.config.direction===a.Horizontal,n=Math.min(e.p0,e.p1),l=Math.max(e.p0,e.p1),r=i.axisBoundaryStop.x-i.axisBoundaryStart.x,o=i.axisBoundaryStop.y-i.axisBoundaryStart.y,h=s?(i.axisDataStart.y-i.axisBoundaryStart.y)/o:(i.axisDataStart.x-i.axisBoundaryStart.x)/r,c=s?(i.axisDataStop.y-i.axisBoundaryStart.y)/o:(i.axisDataStop.x-i.axisBoundaryStart.x)/r;if(this.dataInfo.hasInfinity)if(s){const t=(i.axisInfinityStop.y-i.axisBoundaryStart.y)/o;e.hasPositiveInfinity=0===n,e.hasNegativeInfinity=n<=t&&l>=t}else{const t=(i.axisInfinityStart.x-i.axisBoundaryStart.x)/r;e.hasNegativeInfinity=n<=t&&l>=t,e.hasPositiveInfinity=1===l}this.dataInfo.hasNaN&&(e.hasNaN=s&&1===l||!s&&0===n);const d=c-h;n<=h?e.percent0=0:n>h&&n<=c&&(e.percent0=(n-h)/d),l>=c?e.percent1=1:l>=h&&l<c&&(e.percent1=(l-h)/d),isNaN(e.percent0)||(e.value0=this.dimensions[t].scale.percentToValue(e.percent0)),isNaN(e.percent1)||(e.value1=this.dimensions[t].scale.percentToValue(e.percent1))}cleanUpFilters(){Object.keys(this.filters).forEach((e=>{const t=this.filters[e]||[];for(let e=0;e<t.length;e++)if((a=t[e]).p0>=a.p1)t[e]={...m};else for(let a=e+1;a<t.length;a++)oe(t[e])||oe(t[a])||(i=t[e],s=t[a],i.p0<=s.p1&&s.p0<=i.p1&&(t[a]=he(t[e],t[a]),t[e]={...m}));var i,s,a;this.filters[e]=t.filter((e=>!oe(e)))}))}updateCursor(){const e=this.ix,i=e.shared.action,s=e.shared.focus,l=this.config.direction===a.Horizontal;let r="default";i.type!==t.None?i.type===t.FilterMove||i.type===t.LabelMove?r="grabbing":i.type===t.FilterResizeAfter||i.type===t.FilterResizeBefore?r=l?"ns-resize":"ew-resize":i.type===t.FilterCreate&&(r="crosshair"):void 0!==s&&(s.type===n.DimensionLabel?r="grab":s.type===n.DimensionAxis?r="crosshair":s.type===n.Filter?r="grab":s.type===n.FilterResize&&(r=l?"ns-resize":"ew-resize")),this.canvas.style.cursor=r}clear(){const{h:e,w:t}=this.size;this.ctx.clearRect(0,0,t,e)}draw(){var e,t;if(!this._)return;const i=this._.dims.list,s=this._.dims.shared.axes,r=this._.dims.shared.label,o=this._.styles,h=this.ix,c=this.ix.shared.focus,d=this.filters,u=this.config.direction===a.Horizontal,f=this.config.style.axes,p=this.config.style.data,y=this.config.style.dimension,g=y.label.placement===l.Before,x=f.label.placement===l.Before;for(let s=0;s<this.dataInfo.seriesCount;s++){let a=p.default,n=!1,l=!1,r=!1,o=!1,c=!1;(null===(e=p.series)||void 0===e?void 0:e[s])&&(a=null===(t=p.series)||void 0===t?void 0:t[s]);const f=this.dimensions.map(((e,t)=>{var f,y,g,x,m,v;const N=e.key,S=i[t].layout,k=le(t,h,S.bound),I=this.data[N][s],M=b(I),L=M&&isNaN(I),B=M&&!L&&!isFinite(I),E=B&&I===-1/0,D=B&&I===1/0,w=L||B?0:null!==(y=null===(f=e.scale)||void 0===f?void 0:f.valueToPercent(I))&&void 0!==y?y:0;let O=k.x,P=k.y;if(L)O+=u?S.axisDataStart.x:S.axisBoundaryStart.x,P+=u?S.axisBoundaryStop.y:S.axisDataStart.y;else if(B){const e=E?S.axisInfinityStart.x:S.axisInfinityStop.x,t=D?S.axisInfinityStop.y:S.axisInfinityStart.y;O+=u?S.axisDataStart.x:e,P+=u?t:S.axisDataStart.y}else{const t=null!==(x=null===(g=e.scale)||void 0===g?void 0:g.valueToPos(I))&&void 0!==x?x:0;O+=S.axisDataStart.x+(u?0:t),P+=S.axisDataStart.y+(u?t:0)}if(N===p.targetDimensionKey){const t=null!==(v=null===(m=e.scale)||void 0===m?void 0:m.reverse)&&void 0!==v&&v,i=p.targetColorScale||[],s=ie(t?i.slice().reverse():i,w);a.strokeStyle=s}if(d[N]&&0!==d[N].length){n=!0;let e=!1;for(let t=0;t<d[N].length;t++){const i=d[N][t];L&&i.hasNaN?(e=!0,l=!0):E&&i.hasNegativeInfinity?(e=!0,r=!0):D&&i.hasPositiveInfinity&&(e=!0,o=!0),!L&&!B&&!isNaN(i.percent0)&&!isNaN(i.percent1)&&w>=i.percent0&&w<=i.percent1&&(e=!0)}e||(c=!0)}else L?l=!0:E?r=!0:D&&(o=!0);return{x:O,y:P}}));n&&c?a=p.filtered:l&&p.overrideNaN?a=p.overrideNaN:r&&p.overrideNegativeInfinity?a=p.overrideNegativeInfinity:o&&p.overridePositiveInfinity&&(a=p.overridePositiveInfinity),j(this.ctx,f,u,p.path,a)}const m=null==y.label.angle&&u,v={textAlign:m?"center":void 0,textBaseline:m?g?"bottom":"top":void 0};this.dimensions.forEach(((e,t)=>{var s;const a=le(t,h,i[t].layout.bound),n=i[t].layout.labelPoint,l=a.x+n.x,c=a.y+n.y,d={...o[t].label,...v};X(this.ctx,e.labelTruncated,l,c,null!==(s=r.rad)&&void 0!==s?s:0,d)}));const N=null==f.label.angle&&u,S={textAlign:N?void 0:"center",textBaseline:N?void 0:x?"bottom":"top"};i.forEach(((e,t)=>{var i;const a=this.dimensions[t].key,l=le(t,h,e.layout.bound),r=e.layout.axisBoundaryStart,p=e.layout.axisBoundaryStop,y=e.layout.axisInfinityStart,g=e.layout.axisInfinityStop,m=e.layout.axisDataStart,v=e.layout.axisDataStop,b=e.axes.tickLabels,N=e.axes.tickPos,k=x?-1:1,I={...o[t].tickLabel,...S},M=u?k*f.tick.length:0,L=u?0:k*f.tick.length,B=d[a]||[];if(q(this.ctx,l.x+m.x,l.y+m.y,l.x+v.x,l.y+v.y,o[t].axis),this.dataInfo.hasInfinity){q(this.ctx,l.x+y.x,l.y+y.y,l.x+m.x,l.y+m.y,{...o[t].axis,lineDash:f.axis.infLineDash}),q(this.ctx,l.x+v.x,l.y+v.y,l.x+g.x,l.y+g.y,{...o[t].axis,lineDash:f.axis.infLineDash,lineDashOffset:null!==(i=f.axis.infLineDash[0])&&void 0!==i?i:0});const e=l.x+y.x,s=l.y+y.y,a=e+M,n=s+L;q(this.ctx,e,s,a,n,o[t].tick);const r=l.x+g.x,h=l.y+g.y,c=r+M,d=h+L;q(this.ctx,r,h,c,d,o[t].tick);const p=u?a+k*f.label.offset:e,b=u?s:n+k*f.label.offset,N=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,S=u?"+Ꝏ":"-Ꝏ";X(this.ctx,S,p,b,N,I);const B=u?c+k*f.label.offset:r,E=u?h:d+k*f.label.offset,D=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,w=u?"-Ꝏ":"+Ꝏ";X(this.ctx,w,B,E,D,I)}if(this.dataInfo.hasNaN){const e=l.x+(u?p.x:r.x),i=l.y+(u?p.y:r.y),s=e+M,a=i+L;q(this.ctx,e,i,s,a,o[t].tick);const n=u?s+k*f.label.offset:e,h=u?i:a+k*f.label.offset,c=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0;X(this.ctx,"NaN",n,h,c,I)}for(let e=0;e<b.length;e++){let i=b[e];if("*"===i[0]){if((null==c?void 0:c.dimIndex)!==t||(null==c?void 0:c.type)!==n.DimensionAxis&&(null==c?void 0:c.type)!==n.Filter&&(null==c?void 0:c.type)!==n.FilterResize)continue;i=i.substring(1)}const s=u?0:N[e],a=u?N[e]:0,r=u?k*f.tick.length:0,h=u?0:k*f.tick.length,d=l.x+m.x+s,p=l.y+m.y+a,y=l.x+m.x+s+r,g=l.y+m.y+a+h;q(this.ctx,d,p,y,g,o[t].tick);const v=u?y+k*f.label.offset:d,I=u?p:g+k*f.label.offset,M=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,L={...o[t].tickLabel,...S};X(this.ctx,i,v,I,M,L)}B.forEach(((e,i)=>{const a=e.p0*s.length,n=e.p1*s.length,h=o[t].filters[i].width,c=h/2,d=l.x+r.x+(u?-c:a),f=l.y+r.y+(u?a:-c),p=u?h:n-a,y=u?n-a:h;U(this.ctx,d,f,p,y,o[t].filters[i])}))}))}drawDebugOutline(){if(!this._)return;const{h:e,w:t}=this.size,i=this._.layout,s=this._.dims.list,n=this._.dims.shared.layout,l=this.config.direction===a.Horizontal,r={strokeStyle:"#dddddd"};q(this.ctx,0,i.padding[0],t,i.padding[0],r),q(this.ctx,0,e-i.padding[2],t,e-i.padding[2],r),q(this.ctx,i.padding[3],0,i.padding[3],e,r),q(this.ctx,t-i.padding[1],0,t-i.padding[1],e,r);const o={strokeStyle:"#999999"},h={strokeStyle:"#ff0000"},c={strokeStyle:"#eeeeee"},d={strokeStyle:"#0099cc"},u={strokeStyle:"#ffcc00"};s.forEach(((e,t)=>{const s=e.layout.bound,a=e.layout.axisBoundary,r=e.layout.labelPoint,g=e.layout.labelBoundary;U(this.ctx,l?i.padding[3]+t*n.space:s.x,l?s.y:i.padding[0]+t*n.space,l?n.space:s.w,l?s.h:n.space,o),U(this.ctx,s.x,s.y,s.w,s.h,h),((e,t,i,s,a={})=>{e.save(),a.fillStyle&&(e.fillStyle=null==a?void 0:a.fillStyle,e.moveTo(t+s,i),e.beginPath(),e.arc(t,i,s,0,2*Math.PI),e.fill()),a.strokeStyle&&(e.lineCap=a.lineCap||f,e.lineDashOffset=a.lineDashOffset||0,e.lineJoin=a.lineJoin||p,e.lineWidth=a.lineWidth||1,e.miterLimit=a.miterLimit||y,e.strokeStyle=a.strokeStyle,e.moveTo(t+s,i),e.beginPath(),e.arc(t,i,s,0,2*Math.PI),e.stroke()),e.restore()})(this.ctx,s.x+r.x,s.y+r.y,3,d),J(this.ctx,g,u),J(this.ctx,a,c)}))}handleResize(e){const t=e.find((e=>e.target===this.element));if(!t)return;const{width:i,height:s}=t.contentRect;0===this.size.w&&0===this.size.h&&0!==i&&0!==s?(this.setSize(i,s),this.setConfigFilters(this.config.filters)):this.setSize(i,s)}handleDoubleClick(){var e,t;this.setDimensions(this.dimensionsOriginal,!1),this.filters={},this.ix=I(v),this.redraw(),null===(t=(e=this.config.hooks).onReset)||void 0===t||t.call(e)}handleMouseDown(e){var i,s;if(!this._)return;const l=this.ix.shared,r=this.ix.shared.action,o=this.ix.dimension,h=this.ix.filters,c=this._.dims.shared.axes,d=this.config.direction===a.Horizontal,u=d?"x":"y",f=d?"y":"x",p=ae(e,this.element);if(r.p0=p,r.p1=p,r.filterIndex=-1,l.focus=this.getFocusByPoint(p),l.focus){const e=l.focus.dimIndex,a=this._.dims.list[e].layout,d=a.bound,p=a.axisBoundaryStart;if((null===(i=l.focus)||void 0===i?void 0:i.type)===n.DimensionLabel)r.type=t.LabelMove,r.dimIndex=e,o.axis=d[u]+p[u],o.bound=d;else if([n.DimensionAxis,n.Filter,n.FilterResize].includes(null===(s=l.focus)||void 0===s?void 0:s.type)){r.type=t.FilterCreate,r.dimIndex=e,h.key=this.dimensions[e].key;const i=(r.p0[f]-d[f]-p[f])/c.length;this.setActiveFilter(h.key,i),this.processFilter(h.active,e)}}this.updateCursor(),this.redraw()}handleMouseMove(e){if(!this._)return;const t=ae(e,this.element);this.ix.shared.action.p1=t,this.ix.shared.focus=this.getFocusByPoint(t),this.updateActiveLabel(),this.updateActiveFilter(e),this.updateCursor(),this.redraw()}handleMouseUp(e){if(!this._)return;const t=ae(e,this.element);this.ix.shared.action.p1=t,this.updateActiveLabel(),this.updateActiveFilter(e),this.ix=I(v),this.ix.shared.focus=this.getFocusByPoint(t),this.updateCursor(),this.redraw()}}return e.ActionType=t,e.DimensionLayout=i,e.DimensionType=s,e.Direction=a,e.FocusType=n,e.LabelPlacement=l,e.PathType=r,e.default=pe,e}({});
