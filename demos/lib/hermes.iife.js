var Hermes=function(t){"use strict";const e={FilterCreate:"filter-create",FilterMove:"filter-move",FilterResizeAfter:"filter-resize-after",FilterResizeBefore:"filter-resize-before",LabelMove:"label-move",None:"none"},i={AxisEvenlySpaced:"axis-evenly-spaced",Equidistant:"equidistant"},s={Categorical:"categorical",Linear:"linear",Logarithmic:"logarithmic"},a={Horizontal:"horizontal",Vertical:"vertical"},n={DimensionAxis:"dimension-axis",DimensionLabel:"dimension-label",Filter:"filter",FilterResize:"filter-resize"},l={After:"after",Before:"before"},o={Bezier:"bezier",Straight:"straight"},r=Number.NaN,h={x:Number.NaN,y:Number.NaN},c={h:Number.NaN,w:Number.NaN,x:Number.NaN,y:Number.NaN},d={dimIndex:-1,p0:h,p1:h,type:e.None},u="normal 12px san-serif",f="butt",p="round",y=10,g="black",x={debug:!1,direction:a.Horizontal,filters:{},hooks:{},interactions:{throttleDelayMouseMove:50,throttleDelayResize:50},style:{axes:{axis:{boundaryPadding:15,infLineDash:[2,4],infOffset:24,lineWidth:1,nanGap:24,strokeStyle:"rgba(147, 147, 147, 1.0)"},axisActive:{lineWidth:3,strokeStyle:"rgba(99, 200, 255, 1.0)"},axisHover:{lineWidth:3,strokeStyle:"rgba(79, 180, 246, 1.0)"},filter:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",strokeStyle:"rgba(255, 255, 255, 1.0)",width:4},filterActive:{cornerRadius:3,fillStyle:"rgba(255, 120, 220, 1.0)",width:8},filterAxisHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:6},filterHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:8},label:{fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:4,placement:l.After,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(0, 0, 0, 1.0)"},labelHover:{fillStyle:"rgba(0, 0, 0, 1.0)"},tick:{length:4,lineWidth:1,strokeStyle:"rgba(147, 147, 147, 1.0)"},tickActive:{strokeStyle:"rgba(99, 200, 255, 1.0)"},tickHover:{strokeStyle:"rgba(79, 180, 246, 1.0)"}},data:{default:{lineWidth:1,strokeStyle:"rgba(82, 144, 244, 1.0)"},filtered:{lineWidth:1,strokeStyle:"rgba(0, 0, 0, 0.05)"},overrideNaN:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overrideNegativeInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overridePositiveInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},path:{options:{},type:o.Straight},series:[],targetColorScale:[],targetDimensionKey:void 0},dimension:{label:{angle:void 0,boundaryPadding:5,fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:16,placement:l.Before,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(99, 200, 255, 1.0)"},labelHover:{fillStyle:"rgba(79, 180, 246, 1.0)"},layout:i.AxisEvenlySpaced},padding:[32,64]}},m={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:Number.NaN,p1:Number.NaN,percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN},v=.01,b={dimension:{axis:0,bound:void 0,boundOffset:void 0,offset:0},filters:{active:m,key:void 0},shared:{action:d,focus:void 0}},S=t=>"number"==typeof t,N=t=>"object"==typeof t&&null!=t&&Object.getPrototypeOf(t)===Object.prototype&&!Array.isArray(t)&&!(t=>t instanceof Map)(t)&&!k(t),k=t=>t instanceof Set,I=t=>"string"==typeof t,M=t=>JSON.parse(JSON.stringify(t)),L=(t,e)=>Math.min(e[1],Math.max(e[0],t)),B=(...t)=>t.reduce(((t,e)=>(Object.keys(e).forEach((i=>{N(t[i])&&N(e[i])?t[i]=B(t[i],e[i]):(Array.isArray(t[i])&&Array.isArray(e[i]),t[i]=e[i])})),t)),{}),E=(t,e)=>t.reduce(((t,i)=>(S(i)&&!isNaN(i)&&((t=>e===s.Logarithmic?isFinite(Math.log(t)):isFinite(t))(i)&&(i<t.finite[0]&&(t.finite[0]=i),i>t.finite[1]&&(t.finite[1]=i)),i<t.actual[0]&&(t.actual[0]=i),i>t.actual[1]&&(t.actual[1]=i)),t)),{actual:[1/0,-1/0],finite:[Number.MAX_VALUE,-Number.MAX_VALUE]}),D=(t,e)=>t[e%t.length],w=(t,e,i,s,a={})=>{var n,l,o;const r=i>1?i-1:1,h=(t-e)/r;if(0!==Object.keys(a).length){const t=null!==(n=a.includeNaN)&&void 0!==n?n:0,e=(null!==(l=a.includeNegativeInfinity)&&void 0!==l?l:0)+t,r=(null!==(o=a.includePositiveInfinity)&&void 0!==o?o:0)+e,h=s/i;if(h<=t)return Number.NaN;if(h<=e)return Number.NEGATIVE_INFINITY;if(h<=r)return Number.POSITIVE_INFINITY}return s%(r+1)*h+e},P=t=>t[((t,e=0)=>Math.floor(Math.random()*(t-e))+e)(t.length)],z=(t,e,i={})=>{if(null!=i.includeNaN){const t=L(i.includeNaN,[0,1]);if(Math.random()<t)return Number.NaN}if(null!=i.includeNegativeInfinity){const t=L(i.includeNegativeInfinity,[0,1]);if(Math.random()<t)return-1/0}if(null!=i.includePositiveInfinity){const t=L(i.includePositiveInfinity,[0,1]);if(Math.random()<t)return 1/0}return Math.random()*(t-e)+e},O=t=>{let e=((t,e=6)=>{let i=t.toString();const s=Math.abs(t);return isNaN(t)?i="NaN":Number.isFinite(t)?0!==s&&(s<.01||s>999?i=t.toExponential(e):Number.isInteger(t)||(i=t.toFixed(e))):i=(t<0?"-":"")+"Infinity",i})(t);return e=e.replace(/(e)\+(\d+)/,"$1$2"),e=e.replace(/0+(e-?\d+)$/,"$1"),e=e.replace(/(\.[0-9]+?)0+$/,"$1"),e=e.replace(/\.(e)/,"$1"),e},F=(t,e={})=>{var i,s;const a=null!==(i=e.size)&&void 0!==i?i:24,n=null!==(s=e.suffix)&&void 0!==s?s:"...";return t.length<=a?t:`${t.substring(0,a)}${n}`},C=t=>I(t)?t:t.toString();class A{constructor(t,e,i,s={}){this.direction=t,this.minValue=e,this.maxValue=i,this.axisLength=1,this.maxTicks=1,this.dataOnEdge=true,this.range=0,this.reverse=false,this.tickLabels=[],this.tickPos=[],this.ticks=[],this.tickPadding=0,this.tickSpacing=0,this.max=i,this.min=e,null!=s.dataOnEdge&&(this.dataOnEdge=s.dataOnEdge),this.reverse=t===a.Horizontal?null!=s.reverse&&s.reverse:null==s.reverse||!s.reverse,this.setMinMaxValues(e,i,!1)}setAxisLength(t){this.axisLength=t,this.maxTicks=t/50,this.calculate()}setMinMaxValues(t,e,i=!0){if(t===e){const i=t;if(0===i)t=-1,e=1;else if(i<0){t=i-((e=-(2**(Math.log2(Math.abs(i))-1)))-i)}else{e=i+(i-(t=2**(Math.log2(i)-1)))}}this.minValue=t,this.maxValue=e,this.max=e,this.min=t,this.range=e-t,i&&this.calculate()}niceNum(t,e){const i=Math.abs(t),s=Math.floor(Math.log10(i)),a=i/10**s;let n;return n=e?a<1.5?1:a<3?2:a<7?5:10:a<=1?1:a<=2?2:a<=5?5:10,n*10**s}}class T extends A{constructor(t,e=[],i={}){super(t,0,0,i),this.direction=t,this.categories=e,this.reverse&&this.categories.reverse(),this.tickLabels=this.categories.map((t=>C(t)))}percentToValue(t){return this.posToValue(t*this.axisLength)}posToValue(t){let e=1/0,i=Number.NaN;for(let s=0;s<this.tickPos.length;s++){const a=this.tickPos[s],n=Math.abs(t-a);n<e&&(e=n,i=this.categories[s])}return i}valueToPercent(t){const e=C(t),i=this.tickLabels.findIndex((t=>t===e));return-1!==i?this.tickPos[i]/this.axisLength:0}valueToPos(t){return this.valueToPercent(t)*this.axisLength}calculate(){const t=this.tickLabels.length;let e=0;this.tickSpacing=this.axisLength/(this.dataOnEdge?t-1:t),this.tickPos=[];for(let i=0;i<t;i++)[0,t].includes(i)?e+=this.dataOnEdge?0:this.tickSpacing/2:e+=this.tickSpacing,this.tickPos.push(e)}}class R extends Error{constructor(t){super(`[Hermes] ${t instanceof Error?t.message:I(t)?t:"Critical error encountered!"}`)}}class _ extends A{constructor(t,e,i,s,a,n={}){super(t,e,i,n),this.direction=t,this.finiteMin=e,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.config=n,this.actualMax=a,this.actualMin=s}percentToValue(t){if(0===t)return this.reverse?this.actualMax:this.actualMin;if(1===t)return this.reverse?this.actualMin:this.actualMax;const e=this.dataOnEdge?this.minValue:this.min,i=this.dataOnEdge?this.maxValue:this.max;return(this.reverse?1-t:t)*(i-e)+e}posToValue(t){return this.percentToValue(t/this.axisLength)}valueToPercent(t){if(!S(t))return Number.NaN;if(t===this.actualMax)return this.reverse?0:1;if(t===this.actualMin)return this.reverse?1:0;const e=this.dataOnEdge?this.minValue:this.min,i=(t-e)/((this.dataOnEdge?this.maxValue:this.max)-e);return this.reverse?1-i:i}valueToPos(t){return this.valueToPercent(t)*this.axisLength}calculate(){this.range=this.niceNum(this.maxValue-this.minValue,!1),this.tickSpacing=this.niceNum(this.range/this.maxTicks,!0),this.min=Math.floor(this.minValue/this.tickSpacing)*this.tickSpacing,this.max=Math.ceil(this.maxValue/this.tickSpacing)*this.tickSpacing;const t=Math.round((this.max-this.min)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let e=0;e<=t;e++){let i=e*this.tickSpacing+this.min;this.dataOnEdge&&0===e&&(i=this.minValue),this.dataOnEdge&&e===t&&(i=this.maxValue),this.ticks.push(i);let s=O(i);this.dataOnEdge&&[0,t].includes(e)&&(s=`*${s}`),this.tickLabels.push(s)}this.tickPos=this.ticks.map((t=>this.valueToPos(t)))}}const V=t=>e=>Math.log(e)/Math.log(t);class H extends A{constructor(t,e,i,s,a,n=10,l={}){super(t,e,i,l),this.direction=t,this.finiteMin=e,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.logBase=n,this.maxExp=Number.NaN,this.maxExpExact=Number.NaN,this.minExp=Number.NaN,this.minExpExact=Number.NaN,this.log=V(n),this.logBase=n,this.actualMax=a,this.actualMin=s}setLogBase(t=10){this.logBase=t,this.calculate()}percentToValue(t){if(0===t)return this.reverse?this.actualMax:this.actualMin;if(1===t)return this.reverse?this.actualMin:this.actualMax;const e=this.dataOnEdge?this.minExpExact:this.minExp,i=(this.reverse?1-t:t)*this.rangeExp()+e;return this.logBase**i}posToValue(t){return this.percentToValue(t/this.axisLength)}valueToPercent(t){if(!S(t))return 0;const e=this.log(t),i=this.dataOnEdge?this.minExpExact:this.minExp,s=(e-i)/((this.dataOnEdge?this.maxExpExact:this.maxExp)-i);return this.reverse?1-s:s}valueToPos(t){return this.valueToPercent(t)*this.axisLength}rangeExp(){return this.dataOnEdge?this.maxExpExact-this.minExpExact:this.maxExp-this.minExp}calculate(){this.log=V(this.logBase),this.minExpExact=this.log(this.minValue),this.maxExpExact=this.log(this.maxValue),this.minExp=Math.floor(this.minExpExact),this.maxExp=Math.ceil(this.maxExpExact),this.range=this.logBase**this.maxExp-this.logBase**this.minExp,this.tickSpacing=1;const t=Math.round((this.maxExp-this.minExp)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let e=0;e<=t;e++){const i=e*this.tickSpacing+this.minExp;let s=this.logBase**i;this.dataOnEdge&&0===e&&(s=this.logBase**this.minExpExact),this.dataOnEdge&&e===t&&(s=this.logBase**this.maxExpExact),this.ticks.push(s);let a=O(s);this.dataOnEdge&&[0,t].includes(e)&&(a=`*${a}`),this.tickLabels.push(a)}this.tickPos=this.ticks.map((t=>this.valueToPos(t)))}}const $=(t,e)=>t.x*e.x+t.y*e.y,W=(t,e,i,s)=>{const a={x:s.x-e.x,y:s.y-e.y},n={x:i.x-e.x,y:i.y-e.y},l={x:t.x-e.x,y:t.y-e.y},o=$(a,a),r=$(a,n),h=$(a,l),c=$(n,n),d=$(n,l),u=1/(o*c-r*r),f=(c*h-r*d)*u,p=(o*d-r*h)*u;return f>=0&&p>=0&&f+p<1},J=(t,e,i={})=>{if(t.save(),i.fillStyle){t.fillStyle=i.fillStyle,t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let i=1;i<e.length;i++)t.lineTo(e[i].x,e[i].y);t.closePath(),t.fill()}if(i.strokeStyle){t.lineCap=i.lineCap||f,t.lineDashOffset=i.lineDashOffset||0,t.lineJoin=i.lineJoin||p,t.lineWidth=i.lineWidth||1,t.miterLimit=i.miterLimit||y,t.strokeStyle=i.strokeStyle,t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let i=1;i<e.length;i++)t.lineTo(e[i].x,e[i].y);t.closePath(),t.stroke()}t.restore()},j=(t,e,i,s,a={})=>{var n;if(e.length<2)return;t.save(),t.lineCap=a.lineCap||f,t.lineDashOffset=a.lineDashOffset||0,t.lineJoin=a.lineJoin||p,t.lineWidth=a.lineWidth||1,t.miterLimit=a.miterLimit||y,t.strokeStyle=a.strokeStyle||g,t.beginPath(),t.moveTo(e[0].x,e[0].y);const l=null!==(n=s.options.bezierFactor)&&void 0!==n?n:.3;for(let a=1;a<e.length;a++){const[n,r]=[e[a].x,e[a].y];if(s.type===o.Straight)t.lineTo(n,r);else if(s.type===o.Bezier){const[s,o]=[e[a-1].x,e[a-1].y],[h,c]=[s+(i?(n-s)*l:0),o+(i?0:(r-o)*l)],[d,u]=[n-(i?(n-s)*l:0),r-(i?0:(r-o)*l)];t.bezierCurveTo(h,c,d,u,n,r)}}t.stroke(),t.restore()},q=(t,e,i,s,a,n={})=>{t.save(),t.lineCap=n.lineCap||f,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||p,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||y,t.strokeStyle=n.strokeStyle||g,t.beginPath(),t.setLineDash(n.lineDash||[]),t.moveTo(tt(e),tt(i)),t.lineTo(tt(s),tt(a)),t.stroke(),t.restore()},U=(t,e,i,s,a,n={})=>{t.save();const l=tt(e),o=tt(i),r=n.cornerRadius||0;n.fillStyle&&(t.fillStyle=n.fillStyle,0===r?t.fillRect(l,o,s,a):(G(t,l,o,s,a,r),t.fill())),n.strokeStyle&&(t.lineCap=n.lineCap||f,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||p,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||y,t.strokeStyle=n.strokeStyle,0===r?t.strokeRect(l,o,s,a):(G(t,l,o,s,a,r),t.stroke())),t.restore()},G=(t,e,i,s,a,n)=>{t.beginPath(),t.moveTo(e+n,i),t.lineTo(e+s-n,i),t.quadraticCurveTo(e+s,i,e+s,i+n),t.lineTo(e+s,i+a-n),t.quadraticCurveTo(e+s,i+a,e+s-n,i+a),t.lineTo(e+n,i+a),t.quadraticCurveTo(e,i+a,e,i+a-n),t.lineTo(e,i+n),t.quadraticCurveTo(e,i,e+n,i),t.closePath()},X=(t,e,i,s,a,n={})=>{const l=Z(a),o=l>Math.PI/2&&l<=3*Math.PI/2,r=-a-(o?Math.PI:0);t.save(),et(t,n.font),t.direction=n.direction||"inherit",t.textAlign=n.textAlign||(o?"right":"left"),t.textBaseline=n.textBaseline||"middle",r%2*Math.PI!=0&&(t.translate(i,s),t.rotate(r),t.translate(-i,-s)),n.strokeStyle&&(t.lineCap=n.lineCap||f,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||p,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||y,t.strokeStyle=n.strokeStyle,t.strokeText(e,i,s)),n.fillStyle&&(t.fillStyle=n.fillStyle,t.fillText(e,i,s)),t.restore()},Y=(t,e,i,s,a,n=0,l=0,o=0)=>{const r=t+n-o,h=e+l-o,c=t+i+n+o,d=e+s+l+o,u=[{x:r,y:h},{x:c,y:h},{x:c,y:d},{x:r,y:d}];if(null!=a){const i=Z(a);return u.map((s=>((t,e,i,s=0,a=0)=>{const n=t-s,l=e-a,o=Math.cos(i),r=Math.sin(i);return{x:o*n-r*l+s,y:r*n+o*l+a}})(s.x,s.y,-i,t,e)))}return u},K=(t,e,i=u)=>{et(t,i);const s=t.measureText(e),a=s.actualBoundingBoxLeft+s.actualBoundingBoxRight;return{h:s.actualBoundingBoxAscent+s.actualBoundingBoxDescent,w:a}},Q=t=>{const e=devicePixelRatio<=1?1:2-.5**(devicePixelRatio-1);return Array.isArray(t)?2===t.length?[t[0]*e,t[1]*e,t[0]*e,t[1]*e]:t.map((t=>t*e)):new Array(4).fill(t*e)},Z=t=>(t+2*Math.PI)%(2*Math.PI),tt=t=>Math.round(t-.5)+.5,et=(t,e=u)=>{const i=new RegExp(/(-?\d*\.?\d+)px/),s=e.match(i);if(2===(null==s?void 0:s.length)){const a=Math.round(parseFloat(s[1])*devicePixelRatio);t.font=e.replace(i,`${a}px`)}else t.font=e},it=(t,e)=>{const i=t.length;if(i<1)return"#000000";if(1===i)return t[0];const s=e*(i-1),a=Math.floor(s),n=Math.ceil(s),l=((t,e,i)=>{const s=Math.round((e.r-t.r)*i+t.r),a=Math.round((e.g-t.g)*i+t.g),n=Math.round((e.b-t.b)*i+t.b);if(null!=t.a&&null!=e.a)return{a:(e.a-t.a)*i+t.a,b:n,g:a,r:s};return{b:n,g:a,r:s}})(st(t[a]),st(t[n]),s-a);return(t=>null!=t.a?`rgba(${t.r}, ${t.g}, ${t.b}, ${t.a})`:`rgb(${t.r}, ${t.g}, ${t.b})`)(l)},st=t=>{if(/^#/.test(t))return(t=>{const e={b:0,g:0,r:0},i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return i&&i.length>3&&(e.r=parseInt(i[1],16),e.g=parseInt(i[2],16),e.b=parseInt(i[3],16)),e})(t);const e=/^rgba?\(\s*?(\d+)\s*?,\s*?(\d+)\s*?,\s*?(\d+)\s*?(,\s*?([\d.]+)\s*?)?\)$/i.exec(t);if(e&&e.length>3){const t={a:1,b:0,g:0,r:0};return t.r=parseInt(e[1]),t.g=parseInt(e[2]),t.b=parseInt(e[3]),e.length>5&&void 0!==e[5]&&(t.a=parseFloat(e[5])),t}return{a:1,b:0,g:0,r:0}},at=(t,e)=>{const i=e.getBoundingClientRect();return{x:(t.clientX-i.x)*devicePixelRatio,y:(t.clientY-i.y)*devicePixelRatio}},nt=(t,e)=>{let i;return(...s)=>{null==i&&(i=setTimeout((()=>{t(...s),i=void 0}),e))}},lt=(t,i,s)=>{const a=i.shared.action,n=a.type===e.LabelMove&&a.dimIndex===t,l=i.dimension.bound||c,o=i.dimension.boundOffset||{x:0,y:0};return n?(h=o,{h:(r=l).h,w:r.w,x:r.x+h.x,y:r.y+h.y}):s;var r,h},ot=t=>isNaN(t.p0)&&isNaN(t.p1),rt=(t,e)=>{const i=M(m);return t.p0<e.p0?(i.p0=t.p0,i.percent0=t.percent0,i.value0=t.value0):(i.p0=e.p0,i.percent0=e.percent0,i.value0=e.value0),t.p1>e.p1?(i.p1=t.p1,i.percent1=t.percent1,i.value1=t.value1):(i.p1=e.p1,i.percent1=e.percent1,i.value1=e.value1),i.hasNaN=t.hasNaN||e.hasNaN,i.hasNegativeInfinity=t.hasNegativeInfinity||e.hasNegativeInfinity,i.hasPositiveInfinity=t.hasPositiveInfinity||e.hasPositiveInfinity,i},ht={accuracy:[.55,.99],dropout:[.2,.8],"global-batch-size":[5,30],"layer-free-decay":[.001,.1],"layer-split-factor":[1,16],"learning-rate":[1e-4,.1],"learning-rate-decay":[1e-6,.001],loss:[1.7,2.4],"metrics-base":[.5,.9],"n-filters":[8,64]},ct=[{dataOnEdge:!1,key:"dropout",label:"Dropout",type:s.Linear},{dataOnEdge:!1,key:"global-batch-size",label:"Global Batch Size",type:s.Linear},{categories:[4,8,16,32,64],dataOnEdge:!1,key:"layer-dense-size",label:"Layer Dense Size",type:s.Categorical},{dataOnEdge:!1,key:"layer-free-decay",label:"Layer Free Decay",logBase:10,type:s.Logarithmic},{categories:[!0,!1],dataOnEdge:!1,key:"layer-inverse",label:"Layer Inverse",type:s.Categorical},{dataOnEdge:!1,key:"learning-rate",label:"Learning Rate",logBase:10,type:s.Logarithmic},{dataOnEdge:!1,key:"learning-rate-decay",label:"Learning Rate Decay",logBase:10,type:s.Logarithmic},{dataOnEdge:!1,key:"layer-split-factor",label:"Layer Split Factor",logBase:2,type:s.Logarithmic},{dataOnEdge:!1,key:"metrics-base",label:"Metrics Base",type:s.Linear},{dataOnEdge:!1,key:"n-filters",label:"N Filters",type:s.Linear}],dt=[{dataOnEdge:!0,disableDrag:!0,key:"accuracy",label:"Accuracy",type:s.Linear},{dataOnEdge:!0,disableDrag:!0,key:"loss",label:"Loss",type:s.Logarithmic}];var ut=Object.freeze({__proto__:null,DEFAULT_DIMENSION_COUNT:10,dimensionRanges:ht,dimensionSamples:ct,metricDimensionSamples:dt,generateData:(t,e,i=!0,a={})=>t.reduce(((t,n)=>(t[n.key]=new Array(e).fill(null).map(((t,l)=>{if(n.type===s.Categorical){if(n.categories)return i?P(n.categories):D(n.categories,l)}else if(n.type===s.Linear){const t=ht[n.key];if(t)return i?z(t[1],t[0],a):w(t[1],t[0],e,l,a)}else if(n.type===s.Logarithmic){const t=ht[n.key];if(t&&n.logBase)return i?((t,e,i,s={})=>{const a=10===t?Math.log10:2===t?Math.log2:Math.log,n=a===Math.log?Math.log(t):1,l=a(e)/n,o=a(i)/n,r=z(l,o,s);return isNaN(r)||!isFinite(r)?r:t**r})(n.logBase,t[1],t[0],a):((t,e,i,s,a,n={})=>{const l=10===t?Math.log10:2===t?Math.log2:Math.log,o=l===Math.log?Math.log(t):1,r=l(e)/o,h=l(i)/o;return t**w(r,h,s,a,n)})(n.logBase,t[1],t[0],e,l)}return r})),t)),{}),generateDimensions:(t=10,e=!0)=>{const i=new Array(t-1).fill(null).map(((t,i)=>e?P(ct):D(ct,i))),s=e?P(dt):D(dt,0);return i.push(s),i}});class ft{constructor(t,e,i,s){this.config=x,this.data={},this.dataInfo={hasInfinity:!1,hasNaN:!1,seriesCount:0},this.dimensions=[],this.dimensionsOriginal=[],this.filters={},this.size={h:0,w:0},this.ix=M(b),this._=void 0;const a=(t=>I(t)?document.querySelector(t):t)(t);if(!a)throw new R("Target element selector did not match anything.");this.element=a;const n=this.element.getBoundingClientRect();if(0===n.width||0===n.height)throw new R("Target element width and height must both be greater than 0px.");const l=this.element.querySelectorAll("canvas");0===l.length?(this.canvas=document.createElement("canvas"),this.element.appendChild(this.canvas)):this.canvas=l[0];const o=this.canvas.getContext("2d");if(!o)throw new R("Unable to get context from target element.");this.ctx=o,e&&this.setDimensions(e,!1),i&&this.setConfig(i,!1),s&&this.setData(s,!1),(e||i||s)&&this.redraw(),this.listeners={dblclick:this.handleDoubleClick.bind(this),mousedown:this.handleMouseDown.bind(this),mousemove:0===this.config.interactions.throttleDelayMouseMove?this.handleMouseMove.bind(this):nt((t=>this.handleMouseMove.bind(this)(t)),this.config.interactions.throttleDelayMouseMove),mouseup:this.handleMouseUp.bind(this)},this.enable()}static deepMerge(...t){return B(...t)}static getTester(){return ut}static validateData(t,e){const i={count:0,message:"",valid:!0},s=Object.keys(t),a=Object.values(t);for(let t=0;t<a.length;t++){const e=a[t];if(0===t)i.count=e.length;else if(e.length!==i.count)return i.message=`Data length for "${s[t]}" is not uniform with other dimension data length.`,i.valid=!1,i;if(-1!==e.findIndex((t=>null==t))){const a=null===e;return i.message=`Data for "${s[t]}" has ${a?"null":"undefined"}`,i.valid=!1,i}}const n=Object.keys(t);for(let t=0;t<e.length;t++){const s=e[t].key;if(!n.includes(s))return i.message=`Data for "${s} is missing.`,i.valid=!1,i}return i}static validateDimension(t){if(t.type===s.Categorical){if(!t.categories||0===t.categories.length)return{message:`Categorical dimension "${t.key}" is missing "categories".`,valid:!1}}else if(t.type===s.Logarithmic&&(null==t.logBase||0===t.logBase))return{message:`Logarithmic dimension "${t.key}" is missing "logBase".`,valid:!1};return{message:"",valid:!0}}static validateDimensions(t){if(0===t.length)return{message:"Need at least one dimension defined.",valid:!1};for(let e=0;e<t.length;e++){const{message:i,valid:s}=ft.validateDimension(t[e]);if(!s)return{message:i,valid:s}}return{message:"",valid:!0}}setConfig(t={},e=!0){this.config=B(x,t),this.addObservers(),e&&this.redraw()}setData(t,e=!0){const i=ft.validateData(t,this.dimensionsOriginal);if(!i.valid)throw new R(i.message);this.data=t,this.dataInfo=(t=>{const e=Object.keys(t),i={hasInfinity:!1,hasNaN:!1,seriesCount:0};for(const s of e){i.seriesCount=i.seriesCount||t[s].length;for(const e of t[s])S(e)&&isNaN(e)&&(i.hasNaN=!0),!S(e)||isNaN(e)||isFinite(e)||(i.hasInfinity=!0)}return i})(this.data),this.setDimensions(this.dimensionsOriginal,!1),e&&this.redraw()}setDimensions(t,e=!0){const i=ft.validateDimensions(t);if(!i.valid)throw new R(i.message);const n=this.config.direction===a.Horizontal?a.Vertical:a.Horizontal;this.dimensionsOriginal=t,this.dimensions=M(t).map((t=>{const e=t.key,i=this.data[e]||[],a={...t,labelTruncated:F(t.label,{size:this.config.style.dimension.label.truncate}),rangeActual:void 0,rangeFinite:void 0,scale:new _(n,0,100,0,100)};if(t.type===s.Linear||t.type===s.Logarithmic){const e=E(i,t.type);t.type===s.Linear?a.scale=new _(n,e.finite[0],e.finite[1],e.actual[0],e.actual[1],t):t.type===s.Logarithmic&&(a.scale=new H(n,e.finite[0],e.finite[1],e.actual[0],e.actual[1],t.logBase,t))}else t.type===s.Categorical&&(a.scale=new T(n,t.categories,t));return a})),e&&this.redraw()}setSize(t,e,i=!0){var s,a;const n={h:this.size.h,w:this.size.w},l=Math.round(t*devicePixelRatio),o=Math.round(e*devicePixelRatio);this.canvas.width=l,this.canvas.height=o,this.canvas.style.width=`${t}px`,this.canvas.style.height=`${e}px`,this.size={h:o,w:l},null===(a=(s=this.config.hooks).onResize)||void 0===a||a.call(s,M(this.size),n),i&&this.redraw()}disable(){this.removeListeners(),this.removeObservers(),this.ix=M(b),this.updateCursor(),this.redraw()}enable(){this.addListeners(),this.addObservers()}redraw(){0===this.size.w&&0===this.size.h||(this.calculate(),this.clear(),this.config.debug&&this.drawDebugOutline(),this.draw())}destroy(){this.removeListeners(),this.removeObservers(),this.canvas&&this.element.contains(this.canvas)&&this.element.removeChild(this.canvas)}addListeners(){this.element.addEventListener("dblclick",this.listeners.dblclick),this.element.addEventListener("mousedown",this.listeners.mousedown),window.addEventListener("mousemove",this.listeners.mousemove),window.addEventListener("mouseup",this.listeners.mouseup)}addObservers(){this.resizeObserver&&(this.resizeObserver.unobserve(this.element),this.resizeObserver=void 0),this.resizeObserver=new ResizeObserver(0===this.config.interactions.throttleDelayResize?this.handleResize.bind(this):nt((t=>this.handleResize.bind(this)(t)),this.config.interactions.throttleDelayResize)),this.resizeObserver.observe(this.element)}removeListeners(){this.element.removeEventListener("dblclick",this.listeners.dblclick),this.element.removeEventListener("mousedown",this.listeners.mousedown),window.removeEventListener("mousemove",this.listeners.mousemove),window.removeEventListener("mouseup",this.listeners.mouseup)}removeObservers(){var t;null===(t=this.resizeObserver)||void 0===t||t.unobserve(this.element),this.resizeObserver=void 0}calculate(){this.calculateLayout(),this.calculateStyles()}calculateLayout(){var t,e;const s={dims:{list:new Array(this.dimensions.length).fill(void 0).map((()=>({axes:{},label:{},layout:{}}))),map:this.dimensions.reduce(((t,e,i)=>(t[e.key]=i,t)),{}),shared:{axes:{},label:{},layout:{}}},layout:{drawRect:{},padding:Q(this.config.style.padding)}},{h:n,w:o}=this.size,r=s.layout,h=s.dims.shared.axes,c=s.dims.shared.label,d=s.dims.shared.layout,u=this.dimensions.length,f=this.config.direction===a.Horizontal,p=this.config.style.dimension.label,y=this.config.style.dimension.label.boundaryPadding,g=this.config.style.dimension.layout,x=this.config.style.axes.label,m=this.config.style.axes.axis,v=this.config.style.axes.axis.boundaryPadding,b=p.placement===l.Before,S=null!=p.angle,N=x.placement===l.Before;if(r.drawRect={h:n-r.padding[0]-r.padding[2],w:o-r.padding[1]-r.padding[3],x:r.padding[3],y:r.padding[0]},c.cos=S?Math.cos(null!==(t=p.angle)&&void 0!==t?t:0):void 0,c.sin=S?Math.sin(null!==(e=p.angle)&&void 0!==e?e:0):void 0,c.rad=p.angle||(f?void 0:b?-Math.PI:0),c.maxLengthCos=0,c.maxLengthSin=0,this.dimensions.forEach(((t,e)=>{const i=K(this.ctx,t.labelTruncated,p.font),a=s.dims.list[e].label;a.w=i.w,a.h=i.h,a.lengthCos=S?i.w*c.cos:i.w,a.lengthSin=S?i.w*c.sin:i.h,Math.abs(a.lengthCos)>Math.abs(c.maxLengthCos)&&(c.maxLengthCos=a.lengthCos),Math.abs(a.lengthSin)>Math.abs(c.maxLengthSin)&&(c.maxLengthSin=a.lengthSin)})),h.start=h.stop=0,h.startInfinity=h.stopInfinity=h.startNaN=h.stopNaN=void 0,f){if(b){const t=Math.max(0,c.maxLengthSin);h.start=r.padding[0]+t+p.offset,h.stop=n-r.padding[2]}else{const t=S?Math.max(0,-c.maxLengthSin):c.maxLengthSin;h.start=r.padding[0],h.stop=n-r.padding[2]-t-p.offset}h.stopNaN=this.dataInfo.hasNaN?h.stop:void 0,h.startInfinity=h.start,h.stopInfinity=h.stop-(this.dataInfo.hasNaN?m.nanGap:0),h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}else{if(b){const t=S?Math.max(0,-c.maxLengthCos):c.maxLengthCos;h.start=r.padding[3]+t+p.offset,h.stop=o-r.padding[1]}else{const t=Math.max(0,c.maxLengthCos);h.start=r.padding[3],h.stop=o-r.padding[1]-t-p.offset}h.startNaN=this.dataInfo.hasNaN?h.start:void 0,h.startInfinity=h.start+(this.dataInfo.hasNaN?m.nanGap:0),h.stopInfinity=h.stop,h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}if(h.length=h.stop-h.start,h.labelFactor=N?-1:1,d.totalBoundSpace=0,this.dimensions.forEach(((t,e)=>{const i=s.dims.list[e].axes,a=s.dims.list[e].label,l=s.dims.list[e].layout,c=t.scale;i.tickLabels=[],i.tickPos=[],i.maxLength=0,c&&(c.setAxisLength(h.stopData-h.startData),i.tickLabels=c.tickLabels.slice(),i.tickPos=c.tickPos.slice(),c.tickLabels.forEach((t=>{const e=K(this.ctx,t,x.font);i.maxLength=Math.max(e.w,i.maxLength)}))),S?(l.spaceBefore=f?a.lengthCos<0?-a.lengthCos:0:a.lengthSin>0?a.lengthSin:0,l.spaceAfter=f?a.lengthCos>0?a.lengthCos:0:a.lengthSin<0?-a.lengthSin:0):(l.spaceBefore=(f?a.lengthCos:a.lengthSin)/2,l.spaceAfter=(f?a.lengthCos:a.lengthSin)/2),N?l.spaceBefore=Math.max(l.spaceBefore,i.maxLength):l.spaceAfter=Math.max(l.spaceAfter,i.maxLength),f?(l.bound={h:n-r.padding[0]-r.padding[2],w:l.spaceBefore+l.spaceAfter,x:0,y:r.padding[0]},d.totalBoundSpace+=l.bound.w):(l.bound={h:l.spaceBefore+l.spaceAfter,w:o-r.padding[1]-r.padding[3],x:r.padding[3],y:0},d.totalBoundSpace+=l.bound.h)})),f){const t=r.drawRect.w-d.totalBoundSpace;d.gap=u>1?Math.max(t,0)/(u-1):0,d.offset=r.padding[3],d.space=u>1?r.drawRect.w/(u-1):0}else{const t=r.drawRect.h-d.totalBoundSpace;d.gap=u>1?Math.max(t,0)/(u-1):0,d.offset=r.padding[0],d.space=u>1?r.drawRect.h/(u-1):0}let k=d.offset;for(let t=0;t<s.dims.list.length;t++){const e=s.dims.list[t].label,a=s.dims.list[t].layout;f?(g===i.AxisEvenlySpaced?(a.bound.x=k-a.spaceBefore,k+=d.space):g===i.Equidistant&&(a.bound.x=k,k+=d.gap+a.bound.w),a.axisBoundaryStart={x:a.spaceBefore,y:h.start-r.padding[0]},a.axisBoundaryStop={x:a.spaceBefore,y:h.stop-r.padding[0]},a.axisInfinityStart={x:a.spaceBefore,y:h.startInfinity-r.padding[0]},a.axisInfinityStop={x:a.spaceBefore,y:h.stopInfinity-r.padding[0]},a.axisDataStart={x:a.spaceBefore,y:h.startData-r.padding[0]},a.axisDataStop={x:a.spaceBefore,y:h.stopData-r.padding[0]},a.labelPoint={x:a.spaceBefore,y:b?h.start-p.offset-r.padding[0]:h.stop+p.offset-r.padding[0]}):(g===i.AxisEvenlySpaced?(a.bound.y=k-a.spaceBefore,k+=d.space):g===i.Equidistant&&(a.bound.y=k,k+=d.gap+a.bound.h),a.axisBoundaryStart={x:h.start-r.padding[3],y:a.spaceBefore},a.axisBoundaryStop={x:h.stop-r.padding[3],y:a.spaceBefore},a.axisInfinityStart={x:h.startInfinity-r.padding[3],y:a.spaceBefore},a.axisInfinityStop={x:h.stopInfinity-r.padding[3],y:a.spaceBefore},a.axisDataStart={x:h.startData-r.padding[3],y:a.spaceBefore},a.axisDataStop={x:h.stopData-r.padding[3],y:a.spaceBefore},a.labelPoint={x:b?h.start-p.offset-r.padding[1]:h.stop+p.offset-r.padding[1],y:a.spaceBefore});const n=f?-e.w/2:0,l=f?b?-e.h:0:-e.h/2;a.labelBoundary=Y(a.bound.x+a.labelPoint.x,a.bound.y+a.labelPoint.y,e.w,e.h,c.rad,S?0:n,S?-e.h/2:l,y),a.axisBoundary=[{x:a.bound.x+a.axisBoundaryStart.x-(f?v:0),y:a.bound.y+a.axisBoundaryStart.y-(f?0:v)},{x:a.bound.x+a.axisBoundaryStart.x+(f?v:0),y:a.bound.y+a.axisBoundaryStart.y+(f?0:v)},{x:a.bound.x+a.axisBoundaryStop.x+(f?v:0),y:a.bound.y+a.axisBoundaryStop.y+(f?0:v)},{x:a.bound.x+a.axisBoundaryStop.x-(f?v:0),y:a.bound.y+a.axisBoundaryStop.y-(f?0:v)}]}this._=s}calculateStyles(){if(!this._)return;this._.styles=this._.styles||[];const t=this.config.style,i=t.axes,s=t.dimension,a=this._.dims.list,l=this._.styles,o=this.ix.shared.action,r=this.ix.shared.focus,h=o.type!==e.None;for(let t=0;t<a.length;t++){const a=this.dimensions[t].key,c=this.filters[a]||[],d=o.type===e.LabelMove&&o.dimIndex===t,u=(null==r?void 0:r.type)===n.DimensionLabel&&(null==r?void 0:r.dimIndex)===t,f=(o.type===e.FilterCreate||o.type===e.FilterMove||o.type===e.FilterResizeAfter||o.type===e.FilterResizeBefore)&&o.dimIndex===t,p=((null==r?void 0:r.type)===n.DimensionAxis||(null==r?void 0:r.type)===n.Filter||(null==r?void 0:r.type)===n.FilterResize)&&(null==r?void 0:r.dimIndex)===t;l[t]=l[t]||{},l[t].label={...s.label,...d||!u||h?{}:s.labelHover,...d?s.labelActive:{}},l[t].axis={...i.axis,...f||!p||h?{}:i.axisHover,...f?i.axisActive:{}},l[t].tick={...i.tick,...f||!p||h?{}:i.tickHover,...f?i.tickActive:{}},l[t].tickLabel={...i.label,...f||!p||h?{}:i.labelHover,...f?i.labelActive:{}},l[t].filters=c.map(((e,s)=>{const a=((null==r?void 0:r.type)===n.Filter||(null==r?void 0:r.type)===n.FilterResize)&&(null==r?void 0:r.dimIndex)===t&&(null==r?void 0:r.filterIndex)===s,l=f||p&&!a,h=a&&void 0===o.filterIndex,c=o.dimIndex===t&&o.filterIndex===s;return{...i.filter,...l?i.filterAxisHover:{},...h?i.filterHover:{},...c?i.filterActive:{}}}))}}getFocusByPoint(t){if(!this._)return;const e=this._.dims.shared.axes,i=this.config.direction===a.Horizontal?"y":"x",s=this._.dims.shared.axes.length;for(let a=0;a<this._.dims.list.length;a++){const l=this.dimensions[a].key,o=this._.dims.list[a].layout,r=o.labelBoundary;if((W(t,r[0],r[1],r[2])||W(t,r[2],r[3],r[0]))&&!this.dimensions[a].disableDrag)return{dimIndex:a,type:n.DimensionLabel};const h=o.axisBoundary;if(W(t,h[0],h[1],h[2])||W(t,h[2],h[3],h[0])){const r=this.filters[l]||[],h=o.bound[i]+o.axisBoundaryStart[i],c=(t[i]-h)/s,d=r.findIndex((t=>c>=t.p0&&c<=t.p1));let u=n.DimensionAxis;if(-1!==d){const t=3/e.length,i=r[d];u=c<=i.p0+t||c>=i.p1-t?n.FilterResize:n.Filter}return{dimIndex:a,filterIndex:d,type:u}}}}updateActiveLabel(){var t,i;if(!this._||this.ix.shared.action.type!==e.LabelMove)return;const s=this._.dims.list,n=this.ix,l=n.dimension,o=n.shared.action,r=this.config.direction===a.Horizontal,h=r?"x":"y";l.boundOffset={x:r?o.p1.x-o.p0.x:0,y:r?0:o.p1.y-o.p0.y};let c=-1;const d=l.axis+l.boundOffset[h];for(let t=0;t<s.length;t++){if(o.dimIndex===t||this.dimensions[t].disableDrag)continue;const e=s[t].layout,i=e.bound[h]+e.axisBoundaryStart[h],a=Math.abs(d-i)<30;if(o.dimIndex<t){if(d<i&&!a)break;c=t}if(o.dimIndex>t&&(d<i||a)){c=t;break}}if(-1!==c){const e=o.dimIndex,s=this.dimensions.splice(o.dimIndex,1);if(0===s.length)return;this.dimensions.splice(c,0,s[0]),o.dimIndex=c,null===(i=(t=this.config.hooks).onDimensionMove)||void 0===i||i.call(t,M(s[0]),c,e)}}setConfigFilters(t={}){if(this.calculate(),!this._)return;const e=this._.dims.map;Object.keys(t).forEach((t=>{this.filters[t]=this.config.filters[t].map((i=>this.processConfigFilter(i,e[t]))).filter((t=>null!=t))})),this.redraw()}setActiveFilter(t,i){if(!this._)return;const s=this.filters,a=this.ix,n=a.shared.action,l=a.filters,o=this._.dims.shared.axes,r=(s[t]||[]).findIndex((t=>i>=t.p0&&i<=t.p1));-1!==r?(l.active=s[t][r],l.active.startP0=l.active.p0,l.active.startP1=l.active.p1,n.filterIndex=r,i>=l.active.p0&&i<=l.active.p0+3/o.length?n.type=e.FilterResizeBefore:i>=l.active.p1-3/o.length&&i<=l.active.p1?n.type=e.FilterResizeAfter:n.type=e.FilterMove):(n.type=e.FilterCreate,l.active={...m,p0:i,p1:i},s[t]=s[t]||[],s[t].push(l.active),n.filterIndex=s[t].length-1)}updateActiveFilter(t){var i,s,n,l,o,r,h,c,d,u,f,p;if(!this._)return;const y=this._.dims.list,g=this._.dims.shared.axes,x=this.ix,v=x.filters,b=x.shared.action,S=this.filters,N=b.dimIndex,k=this.config.direction===a.Horizontal?"y":"x";if(!(b.type===e.FilterCreate||b.type===e.FilterMove||b.type===e.FilterResizeAfter||b.type===e.FilterResizeBefore)||!v.key)return;const I=this.dimensions[b.dimIndex].key,B=y[b.dimIndex].layout.bound,E=y[b.dimIndex].layout.axisBoundaryStart[k];if(b.type===e.FilterMove){const t=null!==(i=v.active.startP0)&&void 0!==i?i:0,e=null!==(s=v.active.startP1)&&void 0!==s?s:0,a=e-t,n=(b.p1[k]-b.p0[k])/g.length;v.active.p0=t+n,v.active.p1=e+n,v.active.p0<=0?(v.active.p0=0,v.active.p1=a):v.active.p1>=1&&(v.active.p0=1-a,v.active.p1=1)}else b.type===e.FilterResizeBefore?(v.active.p0=(b.p1[k]-B[k]-E)/g.length,v.active.p0=L(v.active.p0,[0,1])):(v.active.p1=(b.p1[k]-B[k]-E)/g.length,v.active.p1=L(v.active.p1,[0,1]));if(this.processFilter(v.active,N),"mouseup"===t.type){if(D=b.p0,w=b.p1,Math.sqrt((w.x-D.x)**2+(w.y-D.y)**2)<1){const t=S[v.key]||[],e=(v.active.p1-v.active.p0)/2+v.active.p0,i=t.findIndex((t=>e>=t.p0&&e<=t.p1));if(-1!==i){const e=M(t[i]);null===(l=(n=this.config.hooks).onFilterRemove)||void 0===l||l.call(n,{[I]:[e]}),t.splice(i,1)}}else{if(v.active.p1<v.active.p0){const t=v.active.p1;v.active.p1=v.active.p0,v.active.p0=t,this.processFilter(v.active,N)}const t={[I]:[M(v.active)]};switch(b.type){case e.FilterCreate:null===(r=(o=this.config.hooks).onFilterCreate)||void 0===r||r.call(o,t);break;case e.FilterMove:null===(c=(h=this.config.hooks).onFilterMove)||void 0===c||c.call(h,t);break;case e.FilterResizeAfter:case e.FilterResizeBefore:null===(u=(d=this.config.hooks).onFilterResize)||void 0===u||u.call(d,t)}}var D,w;v.active={...m},v.key=void 0,this.cleanUpFilters(),null===(p=null===(f=this.config.hooks)||void 0===f?void 0:f.onFilterChange)||void 0===p||p.call(f,M(this.filters))}}getDimensionLayoutInfo(t){if(!this._||!this.dataInfo)return;const e=this._.dims.list[t].layout,i=this.config.direction===a.Horizontal,s=e.axisBoundaryStop.x-e.axisBoundaryStart.x,n=e.axisBoundaryStop.y-e.axisBoundaryStart.y,l=i?(e.axisDataStart.y-e.axisBoundaryStart.y)/n:(e.axisDataStart.x-e.axisBoundaryStart.x)/s,o=i?(e.axisDataStop.y-e.axisBoundaryStart.y)/n:(e.axisDataStop.x-e.axisBoundaryStart.x)/s,r=o-l;return{hasInfinity:this.dataInfo.hasInfinity,hasNaN:this.dataInfo.hasNaN,isHorizontal:i,layout:e,pLength:r,pStart:l,pStop:o,xLength:s,yLength:n}}processFilter(t,e){const i=this.getDimensionLayoutInfo(e);if(!i)return;const s=Math.min(t.p0,t.p1),a=Math.max(t.p0,t.p1);if(i.hasInfinity)if(i.isHorizontal){const e=(i.layout.axisInfinityStop.y-i.layout.axisBoundaryStart.y)/i.yLength;t.hasPositiveInfinity=0===s,t.hasNegativeInfinity=s<=e&&a>=e}else{const e=(i.layout.axisInfinityStart.x-i.layout.axisBoundaryStart.x)/i.xLength;t.hasNegativeInfinity=s<=e&&a>=e,t.hasPositiveInfinity=1===a}i.hasNaN&&(t.hasNaN=i.isHorizontal&&1===a||!i.isHorizontal&&0===s),s<=i.pStart?t.percent0=0:s>i.pStart&&s<=i.pStop&&(t.percent0=(s-i.pStart)/i.pLength),a>=i.pStop?t.percent1=1:a>=i.pStart&&a<i.pStop&&(t.percent1=(a-i.pStart)/i.pLength),isNaN(t.percent0)||(t.value0=this.dimensions[e].scale.percentToValue(t.percent0)),isNaN(t.percent1)||(t.value1=this.dimensions[e].scale.percentToValue(t.percent1))}processConfigFilter(t,e){const i=this.getDimensionLayoutInfo(e);if(!i)return;const s={...m,...t};if(null!=t.p0&&null!=t.p1)this.processFilter(s,e);else{const a=[],n=[];if(null!=t.value0&&null!=t.value1&&(s.percent0=this.dimensions[e].scale.valueToPercent(t.value0),s.percent1=this.dimensions[e].scale.valueToPercent(t.value1),a.push(s.percent0*i.pLength+i.pStart),n.push(s.percent1*i.pLength+i.pStart)),i.hasInfinity)if(i.isHorizontal){if(t.hasPositiveInfinity)a.push(0),n.push(.01);else if(t.hasNegativeInfinity){const t=(i.layout.axisInfinityStop.y-i.layout.axisBoundaryStart.y)/i.yLength;a.push(t-v),n.push(t+v)}}else if(t.hasPositiveInfinity)a.push(.99),n.push(1);else if(t.hasNegativeInfinity){const t=(i.layout.axisInfinityStart.x-i.layout.axisBoundaryStart.x)/i.xLength;a.push(t-v),n.push(t+v)}i.hasNaN&&t.hasNaN&&(i.isHorizontal?(a.push(.99),n.push(1)):(a.push(0),n.push(.01))),s.p0=Math.min(...a),s.p1=Math.max(...n)}return s}cleanUpFilters(){Object.keys(this.filters).forEach((t=>{const e=this.filters[t]||[];for(let t=0;t<e.length;t++)if((a=e[t]).p0>=a.p1)e[t]={...m};else for(let a=t+1;a<e.length;a++)ot(e[t])||ot(e[a])||(i=e[t],s=e[a],i.p0<=s.p1&&s.p0<=i.p1&&(e[a]=rt(e[t],e[a]),e[t]={...m}));var i,s,a;this.filters[t]=e.filter((t=>!ot(t)))}))}updateCursor(){const t=this.ix,i=t.shared.action,s=t.shared.focus,l=this.config.direction===a.Horizontal;let o="default";i.type!==e.None?i.type===e.FilterMove||i.type===e.LabelMove?o="grabbing":i.type===e.FilterResizeAfter||i.type===e.FilterResizeBefore?o=l?"ns-resize":"ew-resize":i.type===e.FilterCreate&&(o="crosshair"):void 0!==s&&(s.type===n.DimensionLabel?o="grab":s.type===n.DimensionAxis?o="crosshair":s.type===n.Filter?o="grab":s.type===n.FilterResize&&(o=l?"ns-resize":"ew-resize")),this.canvas.style.cursor=o}clear(){const{h:t,w:e}=this.size;this.ctx.clearRect(0,0,e,t)}draw(){var t,e;if(!this._)return;const i=this._.dims.list,s=this._.dims.shared.axes,o=this._.dims.shared.label,r=this._.styles,h=this.ix,c=this.ix.shared.focus,d=this.filters,u=this.config.direction===a.Horizontal,f=this.config.style.axes,p=this.config.style.data,y=this.config.style.dimension,g=y.label.placement===l.Before,x=f.label.placement===l.Before;for(let s=0;s<this.dataInfo.seriesCount;s++){let a=p.default,n=!1,l=!1,o=!1,r=!1,c=!1;const f=this.dimensions.map(((t,e)=>{var f,y,g,x,m,v;const b=t.key,N=i[e].layout,k=lt(e,h,N.bound),I=this.data[b][s],M=S(I),L=M&&isNaN(I),B=M&&!L&&!isFinite(I),E=B&&I===-1/0,D=B&&I===1/0,w=L||B?0:null!==(y=null===(f=t.scale)||void 0===f?void 0:f.valueToPercent(I))&&void 0!==y?y:0;let P=k.x,z=k.y;if(L)P+=u?N.axisDataStart.x:N.axisBoundaryStart.x,z+=u?N.axisBoundaryStop.y:N.axisDataStart.y;else if(B){const t=E?u?N.axisInfinityStop.x:N.axisInfinityStart.x:u?N.axisInfinityStart.x:N.axisInfinityStop.x,e=D?u?N.axisInfinityStart.y:N.axisInfinityStop.y:u?N.axisInfinityStop.y:N.axisInfinityStart.y;P+=u?N.axisDataStart.x:t,z+=u?e:N.axisDataStart.y}else{const e=null!==(x=null===(g=t.scale)||void 0===g?void 0:g.valueToPos(I))&&void 0!==x?x:0;P+=N.axisDataStart.x+(u?0:e),z+=N.axisDataStart.y+(u?e:0)}if(b===p.targetDimensionKey){const e=null!==(v=null===(m=t.scale)||void 0===m?void 0:m.reverse)&&void 0!==v&&v,i=p.targetColorScale||[],s=it(e?i.slice().reverse():i,w);a.strokeStyle=s}if(d[b]&&0!==d[b].length){n=!0;let t=!1;for(let e=0;e<d[b].length;e++){const i=d[b][e];L&&i.hasNaN?(t=!0,l=!0):E&&i.hasNegativeInfinity?(t=!0,o=!0):D&&i.hasPositiveInfinity&&(t=!0,r=!0),!L&&!B&&!isNaN(i.percent0)&&!isNaN(i.percent1)&&w>=i.percent0&&w<=i.percent1&&(t=!0)}t||(c=!0)}else L?l=!0:E?o=!0:D&&(r=!0);return{x:P,y:z}}));(null===(t=p.series)||void 0===t?void 0:t[s])&&(a=null===(e=p.series)||void 0===e?void 0:e[s]),n&&c?a=p.filtered:l&&p.overrideNaN?a=p.overrideNaN:o&&p.overrideNegativeInfinity?a=p.overrideNegativeInfinity:r&&p.overridePositiveInfinity&&(a=p.overridePositiveInfinity),j(this.ctx,f,u,p.path,a)}const m=null==y.label.angle&&u,v={textAlign:m?"center":void 0,textBaseline:m?g?"bottom":"top":void 0};this.dimensions.forEach(((t,e)=>{var s;const a=lt(e,h,i[e].layout.bound),n=i[e].layout.labelPoint,l=a.x+n.x,c=a.y+n.y,d={...r[e].label,...v};X(this.ctx,t.labelTruncated,l,c,null!==(s=o.rad)&&void 0!==s?s:0,d)}));const b=null==f.label.angle&&u,N={textAlign:b?void 0:"center",textBaseline:b?void 0:x?"bottom":"top"};i.forEach(((t,e)=>{var i;const a=this.dimensions[e].key,l=lt(e,h,t.layout.bound),o=t.layout.axisBoundaryStart,p=t.layout.axisBoundaryStop,y=t.layout.axisInfinityStart,g=t.layout.axisInfinityStop,m=t.layout.axisDataStart,v=t.layout.axisDataStop,b=t.axes.tickLabels,S=t.axes.tickPos,k=x?-1:1,I={...r[e].tickLabel,...N},M=u?k*f.tick.length:0,L=u?0:k*f.tick.length,B=d[a]||[];if(q(this.ctx,l.x+m.x,l.y+m.y,l.x+v.x,l.y+v.y,r[e].axis),this.dataInfo.hasInfinity){q(this.ctx,l.x+y.x,l.y+y.y,l.x+m.x,l.y+m.y,{...r[e].axis,lineDash:f.axis.infLineDash}),q(this.ctx,l.x+v.x,l.y+v.y,l.x+g.x,l.y+g.y,{...r[e].axis,lineDash:f.axis.infLineDash,lineDashOffset:null!==(i=f.axis.infLineDash[0])&&void 0!==i?i:0});const t=l.x+y.x,s=l.y+y.y,a=t+M,n=s+L;q(this.ctx,t,s,a,n,r[e].tick);const o=l.x+g.x,h=l.y+g.y,c=o+M,d=h+L;q(this.ctx,o,h,c,d,r[e].tick);const p=u?a+k*f.label.offset:t,b=u?s:n+k*f.label.offset,S=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,N=u?"+Ꝏ":"-Ꝏ";X(this.ctx,N,p,b,S,I);const B=u?c+k*f.label.offset:o,E=u?h:d+k*f.label.offset,D=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,w=u?"-Ꝏ":"+Ꝏ";X(this.ctx,w,B,E,D,I)}if(this.dataInfo.hasNaN){const t=l.x+(u?p.x:o.x),i=l.y+(u?p.y:o.y),s=t+M,a=i+L;q(this.ctx,t,i,s,a,r[e].tick);const n=u?s+k*f.label.offset:t,h=u?i:a+k*f.label.offset,c=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0;X(this.ctx,"NaN",n,h,c,I)}for(let t=0;t<b.length;t++){let i=b[t];if("*"===i[0]){if((null==c?void 0:c.dimIndex)!==e||(null==c?void 0:c.type)!==n.DimensionAxis&&(null==c?void 0:c.type)!==n.Filter&&(null==c?void 0:c.type)!==n.FilterResize)continue;i=i.substring(1)}const s=u?0:S[t],a=u?S[t]:0,o=u?k*f.tick.length:0,h=u?0:k*f.tick.length,d=l.x+m.x+s,p=l.y+m.y+a,y=l.x+m.x+s+o,g=l.y+m.y+a+h;q(this.ctx,d,p,y,g,r[e].tick);const v=u?y+k*f.label.offset:d,I=u?p:g+k*f.label.offset,M=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,L={...r[e].tickLabel,...N};X(this.ctx,i,v,I,M,L)}B.forEach(((t,i)=>{const a=t.p0*s.length,n=t.p1*s.length,h=r[e].filters[i].width,c=h/2,d=l.x+o.x+(u?-c:a),f=l.y+o.y+(u?a:-c),p=u?h:n-a,y=u?n-a:h;U(this.ctx,d,f,p,y,r[e].filters[i])}))}))}drawDebugOutline(){if(!this._)return;const{h:t,w:e}=this.size,i=this._.layout,s=this._.dims.list,n=this._.dims.shared.layout,l=this.config.direction===a.Horizontal,o={strokeStyle:"#dddddd"};q(this.ctx,0,i.padding[0],e,i.padding[0],o),q(this.ctx,0,t-i.padding[2],e,t-i.padding[2],o),q(this.ctx,i.padding[3],0,i.padding[3],t,o),q(this.ctx,e-i.padding[1],0,e-i.padding[1],t,o);const r={strokeStyle:"#999999"},h={strokeStyle:"#ff0000"},c={strokeStyle:"#eeeeee"},d={strokeStyle:"#0099cc"},u={strokeStyle:"#ffcc00"};s.forEach(((t,e)=>{const s=t.layout.bound,a=t.layout.axisBoundary,o=t.layout.labelPoint,g=t.layout.labelBoundary;U(this.ctx,l?i.padding[3]+e*n.space:s.x,l?s.y:i.padding[0]+e*n.space,l?n.space:s.w,l?s.h:n.space,r),U(this.ctx,s.x,s.y,s.w,s.h,h),((t,e,i,s,a={})=>{t.save(),a.fillStyle&&(t.fillStyle=null==a?void 0:a.fillStyle,t.moveTo(e+s,i),t.beginPath(),t.arc(e,i,s,0,2*Math.PI),t.fill()),a.strokeStyle&&(t.lineCap=a.lineCap||f,t.lineDashOffset=a.lineDashOffset||0,t.lineJoin=a.lineJoin||p,t.lineWidth=a.lineWidth||1,t.miterLimit=a.miterLimit||y,t.strokeStyle=a.strokeStyle,t.moveTo(e+s,i),t.beginPath(),t.arc(e,i,s,0,2*Math.PI),t.stroke()),t.restore()})(this.ctx,s.x+o.x,s.y+o.y,3,d),J(this.ctx,g,u),J(this.ctx,a,c)}))}handleResize(t){const e=t.find((t=>t.target===this.element));if(!e)return;const{width:i,height:s}=e.contentRect;0===this.size.w&&0===this.size.h&&0!==i&&0!==s?(this.setSize(i,s),this.setConfigFilters(this.config.filters)):this.setSize(i,s)}handleDoubleClick(){var t,e;this.setDimensions(this.dimensionsOriginal,!1),this.filters={},this.ix=M(b),this.redraw(),null===(e=(t=this.config.hooks).onReset)||void 0===e||e.call(t)}handleMouseDown(t){var i,s;if(!this._)return;const l=this.ix.shared,o=this.ix.shared.action,r=this.ix.dimension,h=this.ix.filters,c=this._.dims.shared.axes,d=this.config.direction===a.Horizontal,u=d?"x":"y",f=d?"y":"x",p=at(t,this.element);if(o.p0=p,o.p1=p,o.filterIndex=-1,l.focus=this.getFocusByPoint(p),l.focus){const t=l.focus.dimIndex,a=this._.dims.list[t].layout,d=a.bound,p=a.axisBoundaryStart;if((null===(i=l.focus)||void 0===i?void 0:i.type)===n.DimensionLabel)o.type=e.LabelMove,o.dimIndex=t,r.axis=d[u]+p[u],r.bound=d;else if([n.DimensionAxis,n.Filter,n.FilterResize].includes(null===(s=l.focus)||void 0===s?void 0:s.type)){o.type=e.FilterCreate,o.dimIndex=t,h.key=this.dimensions[t].key;const i=(o.p0[f]-d[f]-p[f])/c.length;this.setActiveFilter(h.key,i),this.processFilter(h.active,t)}}this.updateCursor(),this.redraw()}handleMouseMove(t){if(!this._)return;const e=at(t,this.element);this.ix.shared.action.p1=e,this.ix.shared.focus=this.getFocusByPoint(e),this.updateActiveLabel(),this.updateActiveFilter(t),this.updateCursor(),this.redraw()}handleMouseUp(t){if(!this._)return;const e=at(t,this.element);this.ix.shared.action.p1=e,this.updateActiveLabel(),this.updateActiveFilter(t),this.ix=M(b),this.ix.shared.focus=this.getFocusByPoint(e),this.updateCursor(),this.redraw()}}return t.ActionType=e,t.DimensionLayout=i,t.DimensionType=s,t.Direction=a,t.FocusType=n,t.LabelPlacement=l,t.PathType=o,t.default=ft,t}({});
