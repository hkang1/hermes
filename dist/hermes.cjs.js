"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t="filter-create",e="filter-move",i="filter-resize-after",s="filter-resize-before",a="label-move",n="none",l="axis-evenly-spaced",o="equidistant",r="categorical",h="linear",c="logarithmic",d="horizontal",u="vertical",f={DimensionAxis:"dimension-axis",DimensionLabel:"dimension-label",Filter:"filter",FilterResize:"filter-resize"},p="after",y="before",g="bezier",x="straight",m=Number.NaN,v={x:Number.NaN,y:Number.NaN},b={h:Number.NaN,w:Number.NaN,x:Number.NaN,y:Number.NaN},N={dimIndex:-1,p0:v,p1:v,type:n},k="normal 12px san-serif",S="butt",I="round",M=10,B="black",E={debug:!1,direction:d,filters:{},hooks:{},interactions:{throttleDelayMouseMove:50,throttleDelayResize:50},style:{axes:{axis:{boundaryPadding:15,infLineDash:[2,4],infOffset:24,lineWidth:1,nanGap:24,strokeStyle:"rgba(147, 147, 147, 1.0)"},axisActve:{lineWidth:3,strokeStyle:"rgba(99, 200, 255, 1.0)"},axisHover:{lineWidth:3,strokeStyle:"rgba(79, 180, 246, 1.0)"},filter:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",strokeStyle:"rgba(255, 255, 255, 1.0)",width:4},filterActive:{cornerRadius:3,fillStyle:"rgba(255, 120, 220, 1.0)",width:8},filterAxisHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:6},filterHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:8},label:{fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:4,placement:p,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(0, 0, 0, 1.0)"},labelHover:{fillStyle:"rgba(0, 0, 0, 1.0)"},tick:{length:4,lineWidth:1,strokeStyle:"rgba(147, 147, 147, 1.0)"},tickActive:{strokeStyle:"rgba(99, 200, 255, 1.0)"},tickHover:{strokeStyle:"rgba(79, 180, 246, 1.0)"}},data:{default:{lineWidth:1,strokeStyle:"rgba(82, 144, 244, 1.0)"},filtered:{lineWidth:1,strokeStyle:"rgba(0, 0, 0, 0.05)"},overrideNaN:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overrideNegativeInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overridePositiveInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},path:{options:{},type:x},series:[]},dimension:{label:{angle:void 0,boundaryPadding:5,fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:16,placement:y,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(99, 200, 255, 1.0)"},labelHover:{fillStyle:"rgba(79, 180, 246, 1.0)"},layout:l},padding:[32,64]}},w={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:Number.NaN,p1:Number.NaN,percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN},D={dimension:{axis:0,bound:void 0,boundOffset:void 0,offset:0},filters:{active:w,key:void 0},shared:{action:N,focus:void 0}},L=t=>"number"==typeof t,O=t=>"object"==typeof t&&null!=t&&Object.getPrototypeOf(t)===Object.prototype&&!Array.isArray(t)&&!(t=>t instanceof Map)(t)&&!P(t),P=t=>t instanceof Set,T=t=>"string"==typeof t,A=t=>JSON.parse(JSON.stringify(t)),C=(t,e)=>Math.min(e[1],Math.max(e[0],t)),z=(t,e)=>T(t)&&T(e)?t.localeCompare(e):t===e?0:t>e?1:-1,F=(...t)=>t.reduce(((t,e)=>(Object.keys(e).forEach((i=>{O(t[i])&&O(e[i])?t[i]=F(t[i],e[i]):(Array.isArray(t[i])&&Array.isArray(e[i]),t[i]=e[i])})),t)),{}),_=(t,e)=>t.reduce(((t,i)=>(L(i)&&!isNaN(i)&&((t=>e===c?isFinite(Math.log(t)):isFinite(t))(i)&&(i<t.finite[0]&&(t.finite[0]=i),i>t.finite[1]&&(t.finite[1]=i)),i<t.actual[0]&&(t.actual[0]=i),i>t.actual[1]&&(t.actual[1]=i)),t)),{actual:[1/0,-1/0],finite:[Number.MAX_VALUE,-Number.MAX_VALUE]}),R=(t,e)=>t[e%t.length],V=(t,e,i,s,a={})=>{var n,l,o;const r=i>1?i-1:1,h=(t-e)/r;if(0!==Object.keys(a).length){const t=null!==(n=a.includeNaN)&&void 0!==n?n:0,e=(null!==(l=a.includeNegativeInfinity)&&void 0!==l?l:0)+t,r=(null!==(o=a.includePositiveInfinity)&&void 0!==o?o:0)+e,h=s/i;if(h<=t)return Number.NaN;if(h<=e)return Number.NEGATIVE_INFINITY;if(h<=r)return Number.POSITIVE_INFINITY}return s%(r+1)*h+e},$=t=>t[((t,e=0)=>Math.floor(Math.random()*(t-e))+e)(t.length)],W=(t,e,i={})=>{if(null!=i.includeNaN){const t=C(i.includeNaN,[0,1]);if(Math.random()<t)return Number.NaN}if(null!=i.includeNegativeInfinity){const t=C(i.includeNegativeInfinity,[0,1]);if(Math.random()<t)return-1/0}if(null!=i.includePositiveInfinity){const t=C(i.includePositiveInfinity,[0,1]);if(Math.random()<t)return 1/0}return Math.random()*(t-e)+e},j=t=>{let e=((t,e=6)=>{let i=t.toString();const s=Math.abs(t);return isNaN(t)?i="NaN":Number.isFinite(t)?0!==s&&(s<.01||s>999?i=t.toExponential(e):Number.isInteger(t)||(i=t.toFixed(e))):i=(t<0?"-":"")+"Infinity",i})(t);return e=e.replace(/(e)\+(\d+)/,"$1$2"),e=e.replace(/0+(e-?\d+)$/,"$1"),e=e.replace(/(\.[0-9]+?)0+$/,"$1"),e=e.replace(/\.(e)/,"$1"),e},J=(t,e={})=>{var i,s;const a=null!==(i=e.size)&&void 0!==i?i:24,n=null!==(s=e.suffix)&&void 0!==s?s:"...";return t.length<=a?t:`${t.substring(0,a)}${n}`},H=t=>T(t)?t:t.toString();class U{constructor(t,e,i,s={}){this.direction=t,this.minValue=e,this.maxValue=i,this.range=0,this.reverse=false,this.tickLabels=[],this.tickPos=[],this.ticks=[],this.tickPadding=0,this.tickSpacing=0,this.axisLength=1,this.maxTicks=1,this.dataOnEdge=true,this.max=i,this.min=e,null!=s.dataOnEdge&&(this.dataOnEdge=s.dataOnEdge),this.reverse=t===d?null!=s.reverse&&s.reverse:null==s.reverse||!s.reverse,this.setMinMaxValues(e,i,!1)}setAxisLength(t){this.axisLength=t,this.maxTicks=t/50,this.calculate()}setMinMaxValues(t,e,i=!0){if(t===e){const i=t;if(0===i)t=-1,e=1;else if(i<0){t=i-((e=-(2**(Math.log2(Math.abs(i))-1)))-i)}else{e=i+(i-(t=2**(Math.log2(i)-1)))}}this.minValue=t,this.maxValue=e,this.max=e,this.min=t,this.range=e-t,i&&this.calculate()}niceNum(t,e){const i=Math.abs(t),s=Math.floor(Math.log10(i)),a=i/10**s;let n;return n=e?a<1.5?1:a<3?2:a<7?5:10:a<=1?1:a<=2?2:a<=5?5:10,n*10**s}}class q extends U{constructor(t,e=[],i={}){super(t,0,0,i),this.direction=t,this.categories=e,this.reverse&&this.categories.reverse(),this.tickLabels=this.categories.map((t=>H(t)))}percentToValue(t){return this.posToValue(t*this.axisLength)}posToValue(t){let e=1/0,i=Number.NaN;for(let s=0;s<this.tickPos.length;s++){const a=this.tickPos[s],n=Math.abs(t-a);n<e&&(e=n,i=this.categories[s])}return i}valueToPercent(t){const e=H(t),i=this.tickLabels.findIndex((t=>t===e));return-1!==i?this.tickPos[i]/this.axisLength:0}valueToPos(t){return this.valueToPercent(t)*this.axisLength}calculate(){const t=this.tickLabels.length;let e=0;this.tickSpacing=this.axisLength/(this.dataOnEdge?t-1:t),this.tickPos=[];for(let i=0;i<t;i++)[0,t].includes(i)?e+=this.dataOnEdge?0:this.tickSpacing/2:e+=this.tickSpacing,this.tickPos.push(e)}}class G extends Error{constructor(t){super(`[Hermes] ${t instanceof Error?t.message:T(t)?t:"Critical error encountered!"}`)}}class X extends U{constructor(t,e,i,s,a,n={}){super(t,e,i,n),this.direction=t,this.finiteMin=e,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.config=n,this.actualMax=a,this.actualMin=s}percentToValue(t){if(0===t)return this.reverse?this.actualMax:this.actualMin;if(1===t)return this.reverse?this.actualMin:this.actualMax;const e=this.dataOnEdge?this.minValue:this.min,i=this.dataOnEdge?this.maxValue:this.max;return(this.reverse?1-t:t)*(i-e)+e}posToValue(t){return this.percentToValue(t/this.axisLength)}valueToPercent(t){if(!L(t))return Number.NaN;if(t===this.actualMax)return this.reverse?0:1;if(t===this.actualMin)return this.reverse?1:0;const e=this.dataOnEdge?this.minValue:this.min,i=(t-e)/((this.dataOnEdge?this.maxValue:this.max)-e);return this.reverse?1-i:i}valueToPos(t){return this.valueToPercent(t)*this.axisLength}calculate(){this.range=this.niceNum(this.maxValue-this.minValue,!1),this.tickSpacing=this.niceNum(this.range/this.maxTicks,!0),this.min=Math.floor(this.minValue/this.tickSpacing)*this.tickSpacing,this.max=Math.ceil(this.maxValue/this.tickSpacing)*this.tickSpacing;const t=Math.round((this.max-this.min)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let e=0;e<=t;e++){let i=e*this.tickSpacing+this.min;this.dataOnEdge&&0===e&&(i=this.minValue),this.dataOnEdge&&e===t&&(i=this.maxValue),this.ticks.push(i);let s=j(i);this.dataOnEdge&&[0,t].includes(e)&&(s=`*${s}`),this.tickLabels.push(s)}this.tickPos=this.ticks.map((t=>this.valueToPos(t)))}}const Y=t=>e=>Math.log(e)/Math.log(t);class K extends U{constructor(t,e,i,s,a,n=10,l={}){super(t,e,i,l),this.direction=t,this.finiteMin=e,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.logBase=n,this.maxExp=Number.NaN,this.maxExpExact=Number.NaN,this.minExp=Number.NaN,this.minExpExact=Number.NaN,this.log=Y(n),this.logBase=n,this.actualMax=a,this.actualMin=s}setLogBase(t=10){this.logBase=t,this.calculate()}percentToValue(t){if(0===t)return this.reverse?this.actualMax:this.actualMin;if(1===t)return this.reverse?this.actualMin:this.actualMax;const e=this.dataOnEdge?this.minExpExact:this.minExp,i=(this.reverse?1-t:t)*this.rangeExp()+e;return this.logBase**i}posToValue(t){return this.percentToValue(t/this.axisLength)}valueToPercent(t){if(!L(t))return 0;const e=this.log(t),i=this.dataOnEdge?this.minExpExact:this.minExp,s=(e-i)/((this.dataOnEdge?this.maxExpExact:this.maxExp)-i);return this.reverse?1-s:s}valueToPos(t){return this.valueToPercent(t)*this.axisLength}rangeExp(){return this.dataOnEdge?this.maxExpExact-this.minExpExact:this.maxExp-this.minExp}calculate(){this.log=Y(this.logBase),this.minExpExact=this.log(this.minValue),this.maxExpExact=this.log(this.maxValue),this.minExp=Math.floor(this.minExpExact),this.maxExp=Math.ceil(this.maxExpExact),this.range=this.logBase**this.maxExp-this.logBase**this.minExp,this.tickSpacing=1;const t=Math.round((this.maxExp-this.minExp)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let e=0;e<=t;e++){const i=e*this.tickSpacing+this.minExp;let s=this.logBase**i;this.dataOnEdge&&0===e&&(s=this.logBase**this.minExpExact),this.dataOnEdge&&e===t&&(s=this.logBase**this.maxExpExact),this.ticks.push(s);let a=j(s);this.dataOnEdge&&[0,t].includes(e)&&(a=`*${a}`),this.tickLabels.push(a)}this.tickPos=this.ticks.map((t=>this.valueToPos(t)))}}const Q=(t,e)=>t.x*e.x+t.y*e.y,Z=(t,e,i,s)=>{const a={x:s.x-e.x,y:s.y-e.y},n={x:i.x-e.x,y:i.y-e.y},l={x:t.x-e.x,y:t.y-e.y},o=Q(a,a),r=Q(a,n),h=Q(a,l),c=Q(n,n),d=Q(n,l),u=1/(o*c-r*r),f=(c*h-r*d)*u,p=(o*d-r*h)*u;return f>=0&&p>=0&&f+p<1},tt=(t,e,i={})=>{if(t.save(),i.fillStyle){t.fillStyle=i.fillStyle,t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let i=1;i<e.length;i++)t.lineTo(e[i].x,e[i].y);t.closePath(),t.fill()}if(i.strokeStyle){t.lineCap=i.lineCap||S,t.lineDashOffset=i.lineDashOffset||0,t.lineJoin=i.lineJoin||I,t.lineWidth=i.lineWidth||1,t.miterLimit=i.miterLimit||M,t.strokeStyle=i.strokeStyle,t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let i=1;i<e.length;i++)t.lineTo(e[i].x,e[i].y);t.closePath(),t.stroke()}t.restore()},et=(t,e,i,s,a={})=>{var n;if(e.length<2)return;t.save(),t.lineCap=a.lineCap||S,t.lineDashOffset=a.lineDashOffset||0,t.lineJoin=a.lineJoin||I,t.lineWidth=a.lineWidth||1,t.miterLimit=a.miterLimit||M,t.strokeStyle=a.strokeStyle||B,t.beginPath(),t.moveTo(e[0].x,e[0].y);const l=null!==(n=s.options.bezierFactor)&&void 0!==n?n:.3;for(let a=1;a<e.length;a++){const[n,o]=[e[a].x,e[a].y];if(s.type===x)t.lineTo(n,o);else if(s.type===g){const[s,r]=[e[a-1].x,e[a-1].y],[h,c]=[s+(i?(n-s)*l:0),r+(i?0:(o-r)*l)],[d,u]=[n-(i?(n-s)*l:0),o-(i?0:(o-r)*l)];t.bezierCurveTo(h,c,d,u,n,o)}}t.stroke(),t.restore()},it=(t,e,i,s,a,n={})=>{t.save(),t.lineCap=n.lineCap||S,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||I,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||M,t.strokeStyle=n.strokeStyle||B,t.beginPath(),t.setLineDash(n.lineDash||[]),t.moveTo(ct(e),ct(i)),t.lineTo(ct(s),ct(a)),t.stroke(),t.restore()},st=(t,e,i,s,a,n={})=>{t.save();const l=ct(e),o=ct(i),r=n.cornerRadius||0;n.fillStyle&&(t.fillStyle=n.fillStyle,0===r?t.fillRect(l,o,s,a):(at(t,l,o,s,a,r),t.fill())),n.strokeStyle&&(t.lineCap=n.lineCap||S,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||I,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||M,t.strokeStyle=n.strokeStyle,0===r?t.strokeRect(l,o,s,a):(at(t,l,o,s,a,r),t.stroke())),t.restore()},at=(t,e,i,s,a,n)=>{t.beginPath(),t.moveTo(e+n,i),t.lineTo(e+s-n,i),t.quadraticCurveTo(e+s,i,e+s,i+n),t.lineTo(e+s,i+a-n),t.quadraticCurveTo(e+s,i+a,e+s-n,i+a),t.lineTo(e+n,i+a),t.quadraticCurveTo(e,i+a,e,i+a-n),t.lineTo(e,i+n),t.quadraticCurveTo(e,i,e+n,i),t.closePath()},nt=(t,e,i,s,a,n={})=>{const l=ht(a),o=l>Math.PI/2&&l<=3*Math.PI/2,r=-a-(o?Math.PI:0);t.save(),dt(t,n.font),t.direction=n.direction||"inherit",t.textAlign=n.textAlign||(o?"right":"left"),t.textBaseline=n.textBaseline||"middle",r%2*Math.PI!=0&&(t.translate(i,s),t.rotate(r),t.translate(-i,-s)),n.strokeStyle&&(t.lineCap=n.lineCap||S,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||I,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||M,t.strokeStyle=n.strokeStyle,t.strokeText(e,i,s)),n.fillStyle&&(t.fillStyle=n.fillStyle,t.fillText(e,i,s)),t.restore()},lt=(t,e,i,s,a,n=0,l=0,o=0)=>{const r=t+n-o,h=e+l-o,c=t+i+n+o,d=e+s+l+o,u=[{x:r,y:h},{x:c,y:h},{x:c,y:d},{x:r,y:d}];if(null!=a){const i=ht(a);return u.map((s=>((t,e,i,s=0,a=0)=>{const n=t-s,l=e-a,o=Math.cos(i),r=Math.sin(i);return{x:o*n-r*l+s,y:r*n+o*l+a}})(s.x,s.y,-i,t,e)))}return u},ot=(t,e,i=k)=>{dt(t,i);const s=t.measureText(e),a=s.actualBoundingBoxLeft+s.actualBoundingBoxRight;return{h:s.actualBoundingBoxAscent+s.actualBoundingBoxDescent,w:a}},rt=t=>{const e=devicePixelRatio<=1?1:2-.5**(devicePixelRatio-1);return Array.isArray(t)?2===t.length?[t[0]*e,t[1]*e,t[0]*e,t[1]*e]:t.map((t=>t*e)):new Array(4).fill(t*e)},ht=t=>(t+2*Math.PI)%(2*Math.PI),ct=t=>Math.round(t-.5)+.5,dt=(t,e=k)=>{const i=new RegExp(/(-?\d*\.?\d+)px/),s=e.match(i);if(2===(null==s?void 0:s.length)){const a=Math.round(parseFloat(s[1])*devicePixelRatio);t.font=e.replace(i,`${a}px`)}else t.font=e},ut=(t,e)=>{const i=t.length;if(i<1)return"#000000";if(1===i)return t[0];const s=e*(i-1),a=Math.floor(s),n=Math.ceil(s),l=((t,e,i)=>{const s=Math.round((e.r-t.r)*i+t.r),a=Math.round((e.g-t.g)*i+t.g),n=Math.round((e.b-t.b)*i+t.b);if(null!=t.a&&null!=e.a)return{a:(e.a-t.a)*i+t.a,b:n,g:a,r:s};return{b:n,g:a,r:s}})(ft(t[a]),ft(t[n]),s-a);return(t=>null!=t.a?`rgba(${t.r}, ${t.g}, ${t.b}, ${t.a})`:`rgb(${t.r}, ${t.g}, ${t.b})`)(l)},ft=t=>{if(/^#/.test(t))return(t=>{const e={b:0,g:0,r:0},i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return i&&i.length>3&&(e.r=parseInt(i[1],16),e.g=parseInt(i[2],16),e.b=parseInt(i[3],16)),e})(t);const e=/^rgba?\(\s*?(\d+)\s*?,\s*?(\d+)\s*?,\s*?(\d+)\s*?(,\s*?([\d.]+)\s*?)?\)$/i.exec(t);if(e&&e.length>3){const t={a:1,b:0,g:0,r:0};return t.r=parseInt(e[1]),t.g=parseInt(e[2]),t.b=parseInt(e[3]),e.length>5&&void 0!==e[5]&&(t.a=parseFloat(e[5])),t}return{a:1,b:0,g:0,r:0}},pt=(t,e)=>{const i=e.getBoundingClientRect();return{x:(t.clientX-i.x)*devicePixelRatio,y:(t.clientY-i.y)*devicePixelRatio}},yt=(t,e)=>{let i;return(...s)=>{null==i&&(i=setTimeout((()=>{t(...s),i=void 0}),e))}},gt=(t,e,i)=>{const s=e.shared.action,n=s.type===a&&s.dimIndex===t,l=e.dimension.bound||b,o=e.dimension.boundOffset||{x:0,y:0};return n?(h=o,{h:(r=l).h,w:r.w,x:r.x+h.x,y:r.y+h.y}):i;var r,h},xt=t=>1===z(t.p0,t.p1)?[t.p1,t.p0]:[t.p0,t.p1],mt=t=>isNaN(t.p0)&&isNaN(t.p1),vt=(t,e)=>{const i=A(w);return t.p0<e.p0?(i.p0=t.p0,i.percent0=t.percent0,i.value0=t.value0):(i.p0=e.p0,i.percent0=e.percent0,i.value0=e.value0),t.p1>e.p1?(i.p1=t.p1,i.percent1=t.percent1,i.value1=t.value1):(i.p1=e.p1,i.percent1=e.percent1,i.value1=e.value1),i.hasNaN=t.hasNaN||e.hasNaN,i.hasNegativeInfinity=t.hasNegativeInfinity||e.hasNegativeInfinity,i.hasPositiveInfinity=t.hasPositiveInfinity||e.hasPositiveInfinity,i},bt={accuracy:[.55,.99],dropout:[.2,.8],"global-batch-size":[5,30],"layer-free-decay":[.001,.1],"layer-split-factor":[1,16],"learning-rate":[1e-4,.1],"learning-rate-decay":[1e-6,.001],loss:[1.7,2.4],"metrics-base":[.5,.9],"n-filters":[8,64]},Nt=[{dataOnEdge:!1,key:"dropout",label:"Dropout",type:h},{dataOnEdge:!1,key:"global-batch-size",label:"Global Batch Size",type:h},{categories:[4,8,16,32,64],dataOnEdge:!1,key:"layer-dense-size",label:"Layer Dense Size",type:r},{dataOnEdge:!1,key:"layer-free-decay",label:"Layer Free Decay",logBase:10,type:c},{categories:[!0,!1],dataOnEdge:!1,key:"layer-inverse",label:"Layer Inverse",type:r},{dataOnEdge:!1,key:"learning-rate",label:"Learning Rate",logBase:10,type:c},{dataOnEdge:!1,key:"learning-rate-decay",label:"Learning Rate Decay",logBase:10,type:c},{dataOnEdge:!1,key:"layer-split-factor",label:"Layer Split Factor",logBase:2,type:c},{dataOnEdge:!1,key:"metrics-base",label:"Metrics Base",type:h},{dataOnEdge:!1,key:"n-filters",label:"N Filters",type:h}],kt=[{dataOnEdge:!0,disableDrag:!0,key:"accuracy",label:"Accuracy",type:h},{dataOnEdge:!0,disableDrag:!0,key:"loss",label:"Loss",type:c}];var St=Object.freeze({__proto__:null,DEFAULT_DIMENSION_COUNT:10,dimensionRanges:bt,dimensionSamples:Nt,metricDimensionSamples:kt,generateData:(t,e,i=!0,s={})=>t.reduce(((t,a)=>(t[a.key]=new Array(e).fill(null).map(((t,n)=>{if(a.type===r){if(a.categories)return i?$(a.categories):R(a.categories,n)}else if(a.type===h){const t=bt[a.key];if(t)return i?W(t[1],t[0],s):V(t[1],t[0],e,n,s)}else if(a.type===c){const t=bt[a.key];if(t&&a.logBase)return i?((t,e,i,s={})=>{const a=10===t?Math.log10:2===t?Math.log2:Math.log,n=a===Math.log?Math.log(t):1,l=a(e)/n,o=a(i)/n,r=W(l,o,s);return isNaN(r)||!isFinite(r)?r:t**r})(a.logBase,t[1],t[0],s):((t,e,i,s,a,n={})=>{const l=10===t?Math.log10:2===t?Math.log2:Math.log,o=l===Math.log?Math.log(t):1,r=l(e)/o,h=l(i)/o;return t**V(r,h,s,a,n)})(a.logBase,t[1],t[0],e,n)}return m})),t)),{}),generateDimensions:(t=10,e=!0)=>{const i=new Array(t-1).fill(null).map(((t,i)=>e?$(Nt):R(Nt,i))),s=e?$(kt):R(kt,0);return i.push(s),i}});class It{constructor(t,e,i,s){this.config=E,this.data={},this.dataInfo={hasInfinity:!1,hasNaN:!1,seriesCount:0},this.dimensions=[],this.dimensionsOriginal=[],this.filters={},this.size={h:0,w:0},this.ix=A(D),this._=void 0;const a=(t=>T(t)?document.querySelector(t):t)(t);if(!a)throw new G("Target element selector did not match anything.");this.element=a;const n=this.element.getBoundingClientRect();if(0===n.width||0===n.height)throw new G("Target element width and height must both be greater than 0px.");const l=this.element.querySelectorAll("canvas");0===l.length?(this.canvas=document.createElement("canvas"),this.element.appendChild(this.canvas)):this.canvas=l[0];const o=this.canvas.getContext("2d");if(!o)throw new G("Unable to get context from target element.");this.ctx=o,e&&this.setDimensions(e,!1),i&&this.setConfig(i,!1),s&&this.setData(s,!1),(e||i||s)&&this.redraw(),this.listeners={dblclick:this.handleDoubleClick.bind(this),mousedown:this.handleMouseDown.bind(this),mousemove:0===this.config.interactions.throttleDelayMouseMove?this.handleMouseMove.bind(this):yt((t=>this.handleMouseMove.bind(this)(t)),this.config.interactions.throttleDelayMouseMove),mouseup:this.handleMouseUp.bind(this)},this.enable()}static deepMerge(...t){return F(...t)}static getTester(){return St}static validateData(t,e){const i={count:0,message:"",valid:!0},s=Object.keys(t),a=Object.values(t);for(let t=0;t<a.length;t++){const e=a[t];if(0===t)i.count=e.length;else if(e.length!==i.count)return i.message="The dimension data are not uniform in size.",i.valid=!1,i;if(-1!==e.findIndex((t=>null==t))){const a=null===e;return i.message=`Data for "${s[t]}" has ${a?"null":"undefined"}`,i.valid=!1,i}}const n=Object.keys(t);for(let t=0;t<e.length;t++){const s=e[t].key;if(!n.includes(s))return i.message=`Data for "${s} is missing.`,i.valid=!1,i}return i}static validateDimension(t){if(t.type===r){if(!t.categories||0===t.categories.length)return{message:`Categorical dimension "${t.key}" is missing "categories".`,valid:!1}}else if(t.type===c&&(null==t.logBase||0===t.logBase))return{message:`Logarithmic dimension "${t.key}" is missing "logBase".`,valid:!1};return{message:"",valid:!0}}static validateDimensions(t){if(0===t.length)return{message:"Need at least one dimension defined.",valid:!1};for(let e=0;e<t.length;e++){const{message:i,valid:s}=It.validateDimension(t[e]);if(!s)return{message:i,valid:s}}return{message:"",valid:!0}}setConfig(t={},e=!0){this.config=F(E,t),this.addObservers(),e&&this.redraw()}setData(t,e=!0){const i=It.validateData(t,this.dimensionsOriginal);if(!i.valid)throw new G(i.message);this.data=t,this.dataInfo=(t=>{const e=Object.keys(t),i={hasInfinity:!1,hasNaN:!1,seriesCount:0};for(const s of e){i.seriesCount=i.seriesCount||t[s].length;for(const e of t[s])isNaN(e)&&(i.hasNaN=!0),isNaN(e)||isFinite(e)||(i.hasInfinity=!0)}return i})(this.data),this.setDimensions(this.dimensionsOriginal,!1),e&&this.redraw()}setDimensions(t,e=!0){const i=It.validateDimensions(t);if(!i.valid)throw new G(i.message);const s=this.config.direction===d?u:d;this.dimensionsOriginal=t,this.dimensions=A(t).map((t=>{const e=t.key,i=this.data[e]||[],a={...t,labelTruncated:J(t.label,{size:this.config.style.dimension.label.truncate}),rangeActual:void 0,rangeFinite:void 0,scale:new X(s,0,100,0,100)};if(t.type===h||t.type===c){const e=_(i,t.type);t.type===h?a.scale=new X(s,e.finite[0],e.finite[1],e.actual[0],e.actual[1],t):t.type===c&&(a.scale=new K(s,e.finite[0],e.finite[1],e.actual[0],e.actual[1],t.logBase,t))}else t.type===r&&(a.scale=new q(s,t.categories,t));return a})),e&&this.redraw()}setSize(t,e,i=!0){var s,a;const n={h:this.size.h,w:this.size.w},l=Math.round(t*devicePixelRatio),o=Math.round(e*devicePixelRatio);this.canvas.width=l,this.canvas.height=o,this.canvas.style.width=`${t}px`,this.canvas.style.height=`${e}px`,this.size={h:o,w:l},null===(a=(s=this.config.hooks).onResize)||void 0===a||a.call(s,this.size,n),i&&this.redraw()}disable(){this.removeListeners(),this.removeObservers(),this.ix=A(D),this.updateCursor(),this.redraw()}enable(){this.addListeners(),this.addObservers()}redraw(){0===this.size.w&&0===this.size.h||(this.calculate(),this.clear(),this.config.debug&&this.drawDebugOutline(),this.draw())}destroy(){this.removeListeners(),this.removeObservers(),this.canvas&&this.element.contains(this.canvas)&&this.element.removeChild(this.canvas)}addListeners(){this.element.addEventListener("dblclick",this.listeners.dblclick),this.element.addEventListener("mousedown",this.listeners.mousedown),window.addEventListener("mousemove",this.listeners.mousemove),window.addEventListener("mouseup",this.listeners.mouseup)}addObservers(){this.resizeObserver&&(this.resizeObserver.unobserve(this.element),this.resizeObserver=void 0),this.resizeObserver=new ResizeObserver(0===this.config.interactions.throttleDelayResize?this.handleResize.bind(this):yt((t=>this.handleResize.bind(this)(t)),this.config.interactions.throttleDelayResize)),this.resizeObserver.observe(this.element)}removeListeners(){this.element.removeEventListener("dblclick",this.listeners.dblclick),this.element.removeEventListener("mousedown",this.listeners.mousedown),window.removeEventListener("mousemove",this.listeners.mousemove),window.removeEventListener("mouseup",this.listeners.mouseup)}removeObservers(){var t;null===(t=this.resizeObserver)||void 0===t||t.unobserve(this.element),this.resizeObserver=void 0}calculate(){this.calculateLayout(),this.calculateStyles()}calculateLayout(){var t,e;const i={dims:{list:new Array(this.dimensions.length).fill(void 0).map((()=>({axes:{},label:{},layout:{}}))),map:this.dimensions.reduce(((t,e,i)=>(t[e.key]=i,t)),{}),shared:{axes:{},label:{},layout:{}}},layout:{drawRect:{},padding:rt(this.config.style.padding)}},{h:s,w:a}=this.size,n=i.layout,r=i.dims.shared.axes,h=i.dims.shared.label,c=i.dims.shared.layout,u=this.dimensions.length,f=this.config.direction===d,p=this.config.style.dimension.label,g=this.config.style.dimension.label.boundaryPadding,x=this.config.style.dimension.layout,m=this.config.style.axes.label,v=this.config.style.axes.axis,b=this.config.style.axes.axis.boundaryPadding,N=p.placement===y,k=null!=p.angle,S=m.placement===y;if(n.drawRect={h:s-n.padding[0]-n.padding[2],w:a-n.padding[1]-n.padding[3],x:n.padding[3],y:n.padding[0]},h.cos=k?Math.cos(null!==(t=p.angle)&&void 0!==t?t:0):void 0,h.sin=k?Math.sin(null!==(e=p.angle)&&void 0!==e?e:0):void 0,h.rad=p.angle||(f?void 0:N?-Math.PI:0),h.maxLengthCos=0,h.maxLengthSin=0,this.dimensions.forEach(((t,e)=>{const s=ot(this.ctx,t.labelTruncated,p.font),a=i.dims.list[e].label;a.w=s.w,a.h=s.h,a.lengthCos=k?s.w*h.cos:s.w,a.lengthSin=k?s.w*h.sin:s.h,Math.abs(a.lengthCos)>Math.abs(h.maxLengthCos)&&(h.maxLengthCos=a.lengthCos),Math.abs(a.lengthSin)>Math.abs(h.maxLengthSin)&&(h.maxLengthSin=a.lengthSin)})),r.start=r.stop=0,r.startInfinity=r.stopInfinity=r.startNaN=r.stopNaN=void 0,f){if(N){const t=Math.max(0,h.maxLengthSin);r.start=n.padding[0]+t+p.offset,r.stop=s-n.padding[2]}else{const t=k?Math.max(0,-h.maxLengthSin):h.maxLengthSin;r.start=n.padding[0],r.stop=s-n.padding[2]-t-p.offset}r.stopNaN=this.dataInfo.hasNaN?r.stop:void 0,r.startInfinity=r.start,r.stopInfinity=r.stop-(this.dataInfo.hasNaN?v.nanGap:0),r.startData=r.startInfinity+(this.dataInfo.hasInfinity?v.infOffset:0),r.stopData=r.stopInfinity-(this.dataInfo.hasInfinity?v.infOffset:0)}else{if(N){const t=k?Math.max(0,-h.maxLengthCos):h.maxLengthCos;r.start=n.padding[3]+t+p.offset,r.stop=a-n.padding[1]}else{const t=Math.max(0,h.maxLengthCos);r.start=n.padding[3],r.stop=a-n.padding[1]-t-p.offset}r.startNaN=this.dataInfo.hasNaN?r.start:void 0,r.startInfinity=r.start+(this.dataInfo.hasNaN?v.nanGap:0),r.stopInfinity=r.stop,r.startData=r.startInfinity+(this.dataInfo.hasInfinity?v.infOffset:0),r.stopData=r.stopInfinity-(this.dataInfo.hasInfinity?v.infOffset:0)}if(r.length=r.stop-r.start,r.labelFactor=S?-1:1,c.totalBoundSpace=0,this.dimensions.forEach(((t,e)=>{const l=i.dims.list[e].axes,o=i.dims.list[e].label,h=i.dims.list[e].layout,d=t.scale;l.tickLabels=[],l.tickPos=[],l.maxLength=0,d&&(d.setAxisLength(r.stopData-r.startData),l.tickLabels=d.tickLabels.slice(),l.tickPos=d.tickPos.slice(),d.tickLabels.forEach((t=>{const e=ot(this.ctx,t,m.font);l.maxLength=Math.max(e.w,l.maxLength)}))),k?(h.spaceBefore=f?o.lengthCos<0?-o.lengthCos:0:o.lengthSin>0?o.lengthSin:0,h.spaceAfter=f?o.lengthCos>0?o.lengthCos:0:o.lengthSin<0?-o.lengthSin:0):(h.spaceBefore=(f?o.lengthCos:o.lengthSin)/2,h.spaceAfter=(f?o.lengthCos:o.lengthSin)/2),S?h.spaceBefore=Math.max(h.spaceBefore,l.maxLength):h.spaceAfter=Math.max(h.spaceAfter,l.maxLength),f?(h.bound={h:s-n.padding[0]-n.padding[2],w:h.spaceBefore+h.spaceAfter,x:0,y:n.padding[0]},c.totalBoundSpace+=h.bound.w):(h.bound={h:h.spaceBefore+h.spaceAfter,w:a-n.padding[1]-n.padding[3],x:n.padding[3],y:0},c.totalBoundSpace+=h.bound.h)})),f){const t=n.drawRect.w-c.totalBoundSpace;c.gap=u>1?Math.max(t,0)/(u-1):0,c.offset=n.padding[3],c.space=u>1?n.drawRect.w/(u-1):0}else{const t=n.drawRect.h-c.totalBoundSpace;c.gap=u>1?Math.max(t,0)/(u-1):0,c.offset=n.padding[0],c.space=u>1?n.drawRect.h/(u-1):0}let I=c.offset;for(let t=0;t<i.dims.list.length;t++){const e=i.dims.list[t].label,s=i.dims.list[t].layout;f?(x===l?(s.bound.x=I-s.spaceBefore,I+=c.space):x===o&&(s.bound.x=I,I+=c.gap+s.bound.w),s.axisBoundaryStart={x:s.spaceBefore,y:r.start-n.padding[0]},s.axisBoundaryStop={x:s.spaceBefore,y:r.stop-n.padding[0]},s.axisInfinityStart={x:s.spaceBefore,y:r.startInfinity-n.padding[0]},s.axisInfinityStop={x:s.spaceBefore,y:r.stopInfinity-n.padding[0]},s.axisDataStart={x:s.spaceBefore,y:r.startData-n.padding[0]},s.axisDataStop={x:s.spaceBefore,y:r.stopData-n.padding[0]},s.labelPoint={x:s.spaceBefore,y:N?r.start-p.offset-n.padding[0]:r.stop+p.offset-n.padding[0]}):(x===l?(s.bound.y=I-s.spaceBefore,I+=c.space):x===o&&(s.bound.y=I,I+=c.gap+s.bound.h),s.axisBoundaryStart={x:r.start-n.padding[3],y:s.spaceBefore},s.axisBoundaryStop={x:r.stop-n.padding[3],y:s.spaceBefore},s.axisInfinityStart={x:r.startInfinity-n.padding[3],y:s.spaceBefore},s.axisInfinityStop={x:r.stopInfinity-n.padding[3],y:s.spaceBefore},s.axisDataStart={x:r.startData-n.padding[3],y:s.spaceBefore},s.axisDataStop={x:r.stopData-n.padding[3],y:s.spaceBefore},s.labelPoint={x:N?r.start-p.offset-n.padding[1]:r.stop+p.offset-n.padding[1],y:s.spaceBefore});const a=f?-e.w/2:0,d=f?N?-e.h:0:-e.h/2;s.labelBoundary=lt(s.bound.x+s.labelPoint.x,s.bound.y+s.labelPoint.y,e.w,e.h,h.rad,k?0:a,k?-e.h/2:d,g),s.axisBoundary=[{x:s.bound.x+s.axisBoundaryStart.x-(f?b:0),y:s.bound.y+s.axisBoundaryStart.y-(f?0:b)},{x:s.bound.x+s.axisBoundaryStart.x+(f?b:0),y:s.bound.y+s.axisBoundaryStart.y+(f?0:b)},{x:s.bound.x+s.axisBoundaryStop.x+(f?b:0),y:s.bound.y+s.axisBoundaryStop.y+(f?0:b)},{x:s.bound.x+s.axisBoundaryStop.x-(f?b:0),y:s.bound.y+s.axisBoundaryStop.y-(f?0:b)}]}this._=i}calculateStyles(){if(!this._)return;this._.styles=this._.styles||[];const l=this.config.style,o=l.axes,r=l.dimension,h=this._.dims.list,c=this._.styles,d=this.ix.shared.action,u=this.ix.shared.focus,p=d.type!==n;for(let n=0;n<h.length;n++){const l=this.dimensions[n].key,h=this.filters[l]||[],y=d.type===a&&d.dimIndex===n,g=(null==u?void 0:u.type)===f.DimensionLabel&&(null==u?void 0:u.dimIndex)===n,x=(d.type===t||d.type===e||d.type===i||d.type===s)&&d.dimIndex===n,m=((null==u?void 0:u.type)===f.DimensionAxis||(null==u?void 0:u.type)===f.Filter||(null==u?void 0:u.type)===f.FilterResize)&&(null==u?void 0:u.dimIndex)===n;c[n]=c[n]||{},c[n].label={...r.label,...y||!g||p?{}:r.labelHover,...y?r.labelActive:{}},c[n].axis={...o.axis,...x||!m||p?{}:o.axisHover,...x?o.axisActve:{}},c[n].tick={...o.tick,...x||!m||p?{}:o.tickHover,...x?o.tickActive:{}},c[n].tickLabel={...o.label,...x||!m||p?{}:o.labelHover,...x?o.labelActive:{}},c[n].filters=h.map(((t,e)=>{const i=((null==u?void 0:u.type)===f.Filter||(null==u?void 0:u.type)===f.FilterResize)&&(null==u?void 0:u.dimIndex)===n&&(null==u?void 0:u.filterIndex)===e,s=x||m&&!i,a=i&&void 0===d.filterIndex,l=d.dimIndex===n&&d.filterIndex===e;return{...o.filter,...s?o.filterAxisHover:{},...a?o.filterHover:{},...l?o.filterActive:{}}}))}}getFocusByPoint(t){if(!this._)return;const e=this._.dims.shared.axes,i=this.config.direction===d?"y":"x",s=this._.dims.shared.axes.length;for(let a=0;a<this._.dims.list.length;a++){const n=this.dimensions[a].key,l=this._.dims.list[a].layout,o=l.labelBoundary;if((Z(t,o[0],o[1],o[2])||Z(t,o[2],o[3],o[0]))&&!this.dimensions[a].disableDrag)return{dimIndex:a,type:f.DimensionLabel};const r=l.axisBoundary;if(Z(t,r[0],r[1],r[2])||Z(t,r[2],r[3],r[0])){const o=this.filters[n]||[],r=l.bound[i]+l.axisBoundaryStart[i],h=(t[i]-r)/s,c=o.findIndex((t=>h>=t.p0&&h<=t.p1));let d=f.DimensionAxis;if(-1!==c){const t=3/e.length,i=o[c];d=h<=i.p0+t||h>=i.p1-t?f.FilterResize:f.Filter}return{dimIndex:a,filterIndex:c,type:d}}}}updateActiveLabel(){var t,e;if(!this._||this.ix.shared.action.type!==a)return;const i=this._.dims.list,s=this.ix,n=s.dimension,l=s.shared.action,o=this.config.direction===d,r=o?"x":"y";n.boundOffset={x:o?l.p1.x-l.p0.x:0,y:o?0:l.p1.y-l.p0.y};let h=-1;const c=n.axis+n.boundOffset[r];for(let t=0;t<i.length;t++){if(l.dimIndex===t||this.dimensions[t].disableDrag)continue;const e=i[t].layout,s=e.bound[r]+e.axisBoundaryStart[r],a=Math.abs(c-s)<30;if(l.dimIndex<t){if(c<s&&!a)break;h=t}if(l.dimIndex>t&&(c<s||a)){h=t;break}}if(-1!==h){const i=l.dimIndex,s=this.dimensions.splice(l.dimIndex,1);if(0===s.length)return;this.dimensions.splice(h,0,s[0]),l.dimIndex=h,null===(e=(t=this.config.hooks).onDimensionMove)||void 0===e||e.call(t,s[0],h,i)}}setConfigFilters(t={}){if(this.calculate(),!this._)return;const e=this._.dims.map;Object.keys(t).forEach((t=>{this.filters[t]=this.config.filters[t].map((i=>{const s={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:i[0],p1:i[1],percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN};return this.processFilter(s,e[t]),s}))})),this.redraw()}setActiveFilter(a,n){if(!this._)return;const l=this.filters,o=this.ix,r=o.shared.action,h=o.filters,c=this._.dims.shared.axes,d=(l[a]||[]).findIndex((t=>n>=t.p0&&n<=t.p1));-1!==d?(h.active=l[a][d],h.active.startP0=h.active.p0,h.active.startP1=h.active.p1,r.filterIndex=d,n>=h.active.p0&&n<=h.active.p0+3/c.length?r.type=s:n>=h.active.p1-3/c.length&&n<=h.active.p1?r.type=i:r.type=e):(r.type=t,h.active={...w,p0:n,p1:n},l[a]=l[a]||[],l[a].push(h.active),r.filterIndex=l[a].length-1)}updateActiveFilter(a){var n,l,o,r,h,c,u,f,p,y,g,x;if(!this._)return;const m=this._.dims.list,v=this._.dims.shared.axes,b=this.ix,N=b.filters,k=b.shared.action,S=this.filters,I=k.dimIndex,M=this.config.direction===d?"y":"x";if(!(k.type===t||k.type===e||k.type===i||k.type===s)||!N.key)return;const B=this.dimensions[k.dimIndex].key,E=m[k.dimIndex].layout.bound,D=m[k.dimIndex].layout.axisBoundaryStart[M];if(k.type===e){const t=null!==(n=N.active.startP0)&&void 0!==n?n:0,e=null!==(l=N.active.startP1)&&void 0!==l?l:0,i=e-t,s=(k.p1[M]-k.p0[M])/v.length;N.active.p0=t+s,N.active.p1=e+s,N.active.p0<=0?(N.active.p0=0,N.active.p1=i):N.active.p1>=1&&(N.active.p0=1-i,N.active.p1=1)}else k.type===s?(N.active.p0=(k.p1[M]-E[M]-D)/v.length,N.active.p0=C(N.active.p0,[0,1])):(N.active.p1=(k.p1[M]-E[M]-D)/v.length,N.active.p1=C(N.active.p1,[0,1]));if(this.processFilter(N.active,I),"mouseup"===a.type){if(L=k.p0,O=k.p1,Math.sqrt((O.x-L.x)**2+(O.y-L.y)**2)<1){const t=S[N.key]||[],e=(N.active.p1-N.active.p0)/2+N.active.p0,i=t.findIndex((t=>e>=t.p0&&e<=t.p1));if(-1!==i){const e=xt(t[i]);null===(r=(o=this.config.hooks).onFilterRemove)||void 0===r||r.call(o,{[B]:[e]}),t.splice(i,1)}}else{if(N.active.p1<N.active.p0){const t=N.active.p1;N.active.p1=N.active.p0,N.active.p0=t,this.processFilter(N.active,I)}const a={[B]:[xt(N.active)]};switch(k.type){case t:null===(c=(h=this.config.hooks).onFilterCreate)||void 0===c||c.call(h,a);break;case e:null===(f=(u=this.config.hooks).onFilterMove)||void 0===f||f.call(u,a);break;case i:case s:null===(y=(p=this.config.hooks).onFilterResize)||void 0===y||y.call(p,a)}}var L,O,P;N.active={...w},N.key=void 0,this.cleanUpFilters(),null===(x=null===(g=this.config.hooks)||void 0===g?void 0:g.onFilterChange)||void 0===x||x.call(g,(P=this.filters,Object.keys(P).reduce(((t,e)=>(t[e]=P[e].map((t=>xt(t))).sort(((t,e)=>z(t[0],e[0]))),t)),{})))}}processFilter(t,e){if(!this._)return;const i=this._.dims.list[e].layout,s=this.config.direction===d,a=Math.min(t.p0,t.p1),n=Math.max(t.p0,t.p1),l=i.axisBoundaryStop.x-i.axisBoundaryStart.x,o=i.axisBoundaryStop.y-i.axisBoundaryStart.y,r=s?(i.axisDataStart.y-i.axisBoundaryStart.y)/o:(i.axisDataStart.x-i.axisBoundaryStart.x)/l,h=s?(i.axisDataStop.y-i.axisBoundaryStart.y)/o:(i.axisDataStop.x-i.axisBoundaryStart.x)/l;if(this.dataInfo.hasInfinity)if(s){const e=(i.axisInfinityStop.y-i.axisBoundaryStart.y)/o;t.hasPositiveInfinity=0===a,t.hasNegativeInfinity=a<=e&&n>=e}else{const e=(i.axisInfinityStart.x-i.axisBoundaryStart.x)/l;t.hasNegativeInfinity=a<=e&&n>=e,t.hasPositiveInfinity=1===n}this.dataInfo.hasNaN&&(t.hasNaN=s&&1===n||!s&&0===a);const c=h-r;a<=r?t.percent0=0:a>r&&a<=h&&(t.percent0=(a-r)/c),n>=h?t.percent1=1:n>=r&&n<h&&(t.percent1=(n-r)/c),isNaN(t.percent0)||(t.value0=this.dimensions[e].scale.percentToValue(t.percent0)),isNaN(t.percent1)||(t.value1=this.dimensions[e].scale.percentToValue(t.percent1))}cleanUpFilters(){Object.keys(this.filters).forEach((t=>{const e=this.filters[t]||[];for(let t=0;t<e.length;t++)if((a=e[t]).p0>=a.p1)e[t]={...w};else for(let a=t+1;a<e.length;a++)mt(e[t])||mt(e[a])||(i=e[t],s=e[a],i.p0<=s.p1&&s.p0<=i.p1&&(e[a]=vt(e[t],e[a]),e[t]={...w}));var i,s,a;this.filters[t]=e.filter((t=>!mt(t)))}))}updateCursor(){const l=this.ix,o=l.shared.action,r=l.shared.focus,h=this.config.direction===d;let c="default";o.type!==n?o.type===e||o.type===a?c="grabbing":o.type===i||o.type===s?c=h?"ns-resize":"ew-resize":o.type===t&&(c="crosshair"):void 0!==r&&(r.type===f.DimensionLabel?c="grab":r.type===f.DimensionAxis?c="crosshair":r.type===f.Filter?c="grab":r.type===f.FilterResize&&(c=h?"ns-resize":"ew-resize")),this.canvas.style.cursor=c}clear(){const{h:t,w:e}=this.size;this.ctx.clearRect(0,0,e,t)}draw(){var t,e;if(!this._)return;const i=this._.dims.list,s=this._.dims.shared.axes,a=this._.dims.shared.label,n=this._.styles,l=this.ix,o=this.ix.shared.focus,r=this.filters,h=this.config.direction===d,c=this.config.style.axes,u=this.config.style.data,p=this.config.style.dimension,g=p.label.placement===y,x=c.label.placement===y;for(let s=0;s<this.dataInfo.seriesCount;s++){let a=u.default,n=!1,o=!1,c=!1,d=!1,f=!1;(null===(t=u.series)||void 0===t?void 0:t[s])&&(a=null===(e=u.series)||void 0===e?void 0:e[s]);const p=this.dimensions.map(((t,e)=>{var p,y,g,x,m,v;const b=t.key,N=i[e].layout,k=gt(e,l,N.bound),S=this.data[b][s],I=L(S),M=I&&isNaN(S),B=I&&!M&&!isFinite(S),E=B&&S===-1/0,w=B&&S===1/0,D=M||B?0:null!==(y=null===(p=t.scale)||void 0===p?void 0:p.valueToPercent(S))&&void 0!==y?y:0;let O=k.x,P=k.y;if(M)O+=h?N.axisDataStart.x:N.axisBoundaryStart.x,P+=h?N.axisBoundaryStop.y:N.axisDataStart.y;else if(B){const t=E?N.axisInfinityStart.x:N.axisInfinityStop.x,e=w?N.axisInfinityStop.y:N.axisInfinityStart.y;O+=h?N.axisDataStart.x:t,P+=h?e:N.axisDataStart.y}else{const e=null!==(x=null===(g=t.scale)||void 0===g?void 0:g.valueToPos(S))&&void 0!==x?x:0;O+=N.axisDataStart.x+(h?0:e),P+=N.axisDataStart.y+(h?e:0)}if(b===u.targetDimensionKey){const e=null!==(v=null===(m=t.scale)||void 0===m?void 0:m.reverse)&&void 0!==v&&v,i=u.targetColorScale||[],s=ut(e?i.slice().reverse():i,D);a.strokeStyle=s}if(r[b]&&0!==r[b].length){n=!0;let t=!1;for(let e=0;e<r[b].length;e++){const i=r[b][e];M&&i.hasNaN?(t=!0,o=!0):E&&i.hasNegativeInfinity?(t=!0,c=!0):w&&i.hasPositiveInfinity&&(t=!0,d=!0),!M&&!B&&!isNaN(i.percent0)&&!isNaN(i.percent1)&&D>=i.percent0&&D<=i.percent1&&(t=!0)}t||(f=!0)}else M?o=!0:E?c=!0:w&&(d=!0);return{x:O,y:P}}));n&&f?a=u.filtered:o&&u.overrideNaN?a=u.overrideNaN:c&&u.overrideNegativeInfinity?a=u.overrideNegativeInfinity:d&&u.overridePositiveInfinity&&(a=u.overridePositiveInfinity),et(this.ctx,p,h,u.path,a)}const m=null==p.label.angle&&h,v={textAlign:m?"center":void 0,textBaseline:m?g?"bottom":"top":void 0};this.dimensions.forEach(((t,e)=>{var s;const o=gt(e,l,i[e].layout.bound),r=i[e].layout.labelPoint,h=o.x+r.x,c=o.y+r.y,d={...n[e].label,...v};nt(this.ctx,t.labelTruncated,h,c,null!==(s=a.rad)&&void 0!==s?s:0,d)}));const b=null==c.label.angle&&h,N={textAlign:b?void 0:"center",textBaseline:b?void 0:x?"bottom":"top"};i.forEach(((t,e)=>{var i;const a=this.dimensions[e].key,d=gt(e,l,t.layout.bound),u=t.layout.axisBoundaryStart,p=t.layout.axisBoundaryStop,y=t.layout.axisInfinityStart,g=t.layout.axisInfinityStop,m=t.layout.axisDataStart,v=t.layout.axisDataStop,b=t.axes.tickLabels,k=t.axes.tickPos,S=x?-1:1,I={...n[e].tickLabel,...N},M=h?S*c.tick.length:0,B=h?0:S*c.tick.length,E=r[a]||[];if(it(this.ctx,d.x+m.x,d.y+m.y,d.x+v.x,d.y+v.y,n[e].axis),this.dataInfo.hasInfinity){it(this.ctx,d.x+y.x,d.y+y.y,d.x+m.x,d.y+m.y,{...n[e].axis,lineDash:c.axis.infLineDash}),it(this.ctx,d.x+v.x,d.y+v.y,d.x+g.x,d.y+g.y,{...n[e].axis,lineDash:c.axis.infLineDash,lineDashOffset:null!==(i=c.axis.infLineDash[0])&&void 0!==i?i:0});const t=d.x+y.x,s=d.y+y.y,a=t+M,l=s+B;it(this.ctx,t,s,a,l,n[e].tick);const o=d.x+g.x,r=d.y+g.y,u=o+M,f=r+B;it(this.ctx,o,r,u,f,n[e].tick);const p=h?a+S*c.label.offset:t,b=h?s:l+S*c.label.offset,N=null!=c.label.angle?c.label.angle:h&&x?Math.PI:0,k=h?"+Ꝏ":"-Ꝏ";nt(this.ctx,k,p,b,N,I);const E=h?u+S*c.label.offset:o,w=h?r:f+S*c.label.offset,D=null!=c.label.angle?c.label.angle:h&&x?Math.PI:0,L=h?"-Ꝏ":"+Ꝏ";nt(this.ctx,L,E,w,D,I)}if(this.dataInfo.hasNaN){const t=d.x+(h?p.x:u.x),i=d.y+(h?p.y:u.y),s=t+M,a=i+B;it(this.ctx,t,i,s,a,n[e].tick);const l=h?s+S*c.label.offset:t,o=h?i:a+S*c.label.offset,r=null!=c.label.angle?c.label.angle:h&&x?Math.PI:0;nt(this.ctx,"NaN",l,o,r,I)}for(let t=0;t<b.length;t++){let i=b[t];if("*"===i[0]){if((null==o?void 0:o.dimIndex)!==e||(null==o?void 0:o.type)!==f.DimensionAxis&&(null==o?void 0:o.type)!==f.Filter&&(null==o?void 0:o.type)!==f.FilterResize)continue;i=i.substring(1)}const s=h?0:k[t],a=h?k[t]:0,l=h?S*c.tick.length:0,r=h?0:S*c.tick.length,u=d.x+m.x+s,p=d.y+m.y+a,y=d.x+m.x+s+l,g=d.y+m.y+a+r;it(this.ctx,u,p,y,g,n[e].tick);const v=h?y+S*c.label.offset:u,I=h?p:g+S*c.label.offset,M=null!=c.label.angle?c.label.angle:h&&x?Math.PI:0,B={...n[e].tickLabel,...N};nt(this.ctx,i,v,I,M,B)}E.forEach(((t,i)=>{const a=t.p0*s.length,l=t.p1*s.length,o=n[e].filters[i].width,r=o/2,c=d.x+u.x+(h?-r:a),f=d.y+u.y+(h?a:-r),p=h?o:l-a,y=h?l-a:o;st(this.ctx,c,f,p,y,n[e].filters[i])}))}))}drawDebugOutline(){if(!this._)return;const{h:t,w:e}=this.size,i=this._.layout,s=this._.dims.list,a=this._.dims.shared.layout,n=this.config.direction===d,l={strokeStyle:"#dddddd"};it(this.ctx,0,i.padding[0],e,i.padding[0],l),it(this.ctx,0,t-i.padding[2],e,t-i.padding[2],l),it(this.ctx,i.padding[3],0,i.padding[3],t,l),it(this.ctx,e-i.padding[1],0,e-i.padding[1],t,l);const o={strokeStyle:"#999999"},r={strokeStyle:"#ff0000"},h={strokeStyle:"#eeeeee"},c={strokeStyle:"#0099cc"},u={strokeStyle:"#ffcc00"};s.forEach(((t,e)=>{const s=t.layout.bound,l=t.layout.axisBoundary,d=t.layout.labelPoint,f=t.layout.labelBoundary;st(this.ctx,n?i.padding[3]+e*a.space:s.x,n?s.y:i.padding[0]+e*a.space,n?a.space:s.w,n?s.h:a.space,o),st(this.ctx,s.x,s.y,s.w,s.h,r),((t,e,i,s,a={})=>{t.save(),a.fillStyle&&(t.fillStyle=null==a?void 0:a.fillStyle,t.moveTo(e+s,i),t.beginPath(),t.arc(e,i,s,0,2*Math.PI),t.fill()),a.strokeStyle&&(t.lineCap=a.lineCap||S,t.lineDashOffset=a.lineDashOffset||0,t.lineJoin=a.lineJoin||I,t.lineWidth=a.lineWidth||1,t.miterLimit=a.miterLimit||M,t.strokeStyle=a.strokeStyle,t.moveTo(e+s,i),t.beginPath(),t.arc(e,i,s,0,2*Math.PI),t.stroke()),t.restore()})(this.ctx,s.x+d.x,s.y+d.y,3,c),tt(this.ctx,f,u),tt(this.ctx,l,h)}))}handleResize(t){const e=t.find((t=>t.target===this.element));if(!e)return;const{width:i,height:s}=e.contentRect;0===this.size.w&&0===this.size.h&&0!==i&&0!==s?(this.setSize(i,s),this.setConfigFilters(this.config.filters)):this.setSize(i,s)}handleDoubleClick(){var t,e;this.setDimensions(this.dimensionsOriginal,!1),this.filters={},this.ix=A(D),this.redraw(),null===(e=(t=this.config.hooks).onReset)||void 0===e||e.call(t)}handleMouseDown(e){var i,s;if(!this._)return;const n=this.ix.shared,l=this.ix.shared.action,o=this.ix.dimension,r=this.ix.filters,h=this._.dims.shared.axes,c=this.config.direction===d,u=c?"x":"y",p=c?"y":"x",y=pt(e,this.element);if(l.p0=y,l.p1=y,l.filterIndex=-1,n.focus=this.getFocusByPoint(y),n.focus){const e=n.focus.dimIndex,c=this._.dims.list[e].layout,d=c.bound,y=c.axisBoundaryStart;if((null===(i=n.focus)||void 0===i?void 0:i.type)===f.DimensionLabel)l.type=a,l.dimIndex=e,o.axis=d[u]+y[u],o.bound=d;else if([f.DimensionAxis,f.Filter,f.FilterResize].includes(null===(s=n.focus)||void 0===s?void 0:s.type)){l.type=t,l.dimIndex=e,r.key=this.dimensions[e].key;const i=(l.p0[p]-d[p]-y[p])/h.length;this.setActiveFilter(r.key,i),this.processFilter(r.active,e)}}this.updateCursor(),this.redraw()}handleMouseMove(t){if(!this._)return;const e=pt(t,this.element);this.ix.shared.action.p1=e,this.ix.shared.focus=this.getFocusByPoint(e),this.updateActiveLabel(),this.updateActiveFilter(t),this.updateCursor(),this.redraw()}handleMouseUp(t){if(!this._)return;const e=pt(t,this.element);this.ix.shared.action.p1=e,this.updateActiveLabel(),this.updateActiveFilter(t),this.ix=A(D),this.ix.shared.focus=this.getFocusByPoint(e),this.updateCursor(),this.redraw()}}exports.default=It;
