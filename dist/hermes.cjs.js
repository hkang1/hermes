"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const e={FilterCreate:"filter-create",FilterMove:"filter-move",FilterResizeAfter:"filter-resize-after",FilterResizeBefore:"filter-resize-before",LabelMove:"label-move",None:"none"},t={AxisEvenlySpaced:"axis-evenly-spaced",Equidistant:"equidistant"},i={Categorical:"categorical",Linear:"linear",Logarithmic:"logarithmic"},s={Horizontal:"horizontal",Vertical:"vertical"},a={DimensionAxis:"dimension-axis",DimensionLabel:"dimension-label",Filter:"filter",FilterResize:"filter-resize"},n={After:"after",Before:"before"},l={Bezier:"bezier",Straight:"straight"},r=Number.NaN,o={x:Number.NaN,y:Number.NaN},h={h:Number.NaN,w:Number.NaN,x:Number.NaN,y:Number.NaN},c={dimIndex:-1,p0:o,p1:o,type:e.None},d="normal 12px san-serif",u="butt",f="round",p=10,y="black",g={debug:!1,direction:s.Horizontal,filters:{},hooks:{},interactions:{throttleDelayMouseMove:50,throttleDelayResize:50},style:{axes:{axis:{boundaryPadding:15,infLineDash:[2,4],infOffset:24,lineWidth:1,nanGap:24,strokeStyle:"rgba(147, 147, 147, 1.0)"},axisActive:{lineWidth:3,strokeStyle:"rgba(99, 200, 255, 1.0)"},axisHover:{lineWidth:3,strokeStyle:"rgba(79, 180, 246, 1.0)"},filter:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",strokeStyle:"rgba(255, 255, 255, 1.0)",width:4},filterActive:{cornerRadius:3,fillStyle:"rgba(255, 120, 220, 1.0)",width:8},filterAxisHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:6},filterHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:8},label:{fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:4,placement:n.After,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(0, 0, 0, 1.0)"},labelHover:{fillStyle:"rgba(0, 0, 0, 1.0)"},tick:{length:4,lineWidth:1,strokeStyle:"rgba(147, 147, 147, 1.0)"},tickActive:{strokeStyle:"rgba(99, 200, 255, 1.0)"},tickHover:{strokeStyle:"rgba(79, 180, 246, 1.0)"}},data:{default:{lineWidth:1,strokeStyle:"rgba(82, 144, 244, 1.0)"},filtered:{lineWidth:1,strokeStyle:"rgba(0, 0, 0, 0.05)"},overrideNaN:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overrideNegativeInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overridePositiveInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},path:{options:{},type:l.Straight},series:[]},dimension:{label:{angle:void 0,boundaryPadding:5,fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:16,placement:n.Before,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(99, 200, 255, 1.0)"},labelHover:{fillStyle:"rgba(79, 180, 246, 1.0)"},layout:t.AxisEvenlySpaced},padding:[32,64]}},x={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:Number.NaN,p1:Number.NaN,percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN},m={dimension:{axis:0,bound:void 0,boundOffset:void 0,offset:0},filters:{active:x,key:void 0},shared:{action:c,focus:void 0}},v=e=>"number"==typeof e,b=e=>"object"==typeof e&&null!=e&&Object.getPrototypeOf(e)===Object.prototype&&!Array.isArray(e)&&!(e=>e instanceof Map)(e)&&!N(e),N=e=>e instanceof Set,S=e=>"string"==typeof e,k=e=>JSON.parse(JSON.stringify(e)),I=(e,t)=>Math.min(t[1],Math.max(t[0],e)),M=(e,t)=>S(e)&&S(t)?e.localeCompare(t):e===t?0:e>t?1:-1,L=(...e)=>e.reduce(((e,t)=>(Object.keys(t).forEach((i=>{b(e[i])&&b(t[i])?e[i]=L(e[i],t[i]):(Array.isArray(e[i])&&Array.isArray(t[i]),e[i]=t[i])})),e)),{}),B=(e,t)=>e.reduce(((e,s)=>(v(s)&&!isNaN(s)&&((e=>t===i.Logarithmic?isFinite(Math.log(e)):isFinite(e))(s)&&(s<e.finite[0]&&(e.finite[0]=s),s>e.finite[1]&&(e.finite[1]=s)),s<e.actual[0]&&(e.actual[0]=s),s>e.actual[1]&&(e.actual[1]=s)),e)),{actual:[1/0,-1/0],finite:[Number.MAX_VALUE,-Number.MAX_VALUE]}),E=(e,t)=>e[t%e.length],D=(e,t,i,s,a={})=>{var n,l,r;const o=i>1?i-1:1,h=(e-t)/o;if(0!==Object.keys(a).length){const e=null!==(n=a.includeNaN)&&void 0!==n?n:0,t=(null!==(l=a.includeNegativeInfinity)&&void 0!==l?l:0)+e,o=(null!==(r=a.includePositiveInfinity)&&void 0!==r?r:0)+t,h=s/i;if(h<=e)return Number.NaN;if(h<=t)return Number.NEGATIVE_INFINITY;if(h<=o)return Number.POSITIVE_INFINITY}return s%(o+1)*h+t},w=e=>e[((e,t=0)=>Math.floor(Math.random()*(e-t))+t)(e.length)],O=(e,t,i={})=>{if(null!=i.includeNaN){const e=I(i.includeNaN,[0,1]);if(Math.random()<e)return Number.NaN}if(null!=i.includeNegativeInfinity){const e=I(i.includeNegativeInfinity,[0,1]);if(Math.random()<e)return-1/0}if(null!=i.includePositiveInfinity){const e=I(i.includePositiveInfinity,[0,1]);if(Math.random()<e)return 1/0}return Math.random()*(e-t)+t},P=e=>{let t=((e,t=6)=>{let i=e.toString();const s=Math.abs(e);return isNaN(e)?i="NaN":Number.isFinite(e)?0!==s&&(s<.01||s>999?i=e.toExponential(t):Number.isInteger(e)||(i=e.toFixed(t))):i=(e<0?"-":"")+"Infinity",i})(e);return t=t.replace(/(e)\+(\d+)/,"$1$2"),t=t.replace(/0+(e-?\d+)$/,"$1"),t=t.replace(/(\.[0-9]+?)0+$/,"$1"),t=t.replace(/\.(e)/,"$1"),t},z=(e,t={})=>{var i,s;const a=null!==(i=t.size)&&void 0!==i?i:24,n=null!==(s=t.suffix)&&void 0!==s?s:"...";return e.length<=a?e:`${e.substring(0,a)}${n}`},F=e=>S(e)?e:e.toString();class A{constructor(e,t,i,a={}){this.direction=e,this.minValue=t,this.maxValue=i,this.range=0,this.reverse=false,this.tickLabels=[],this.tickPos=[],this.ticks=[],this.tickPadding=0,this.tickSpacing=0,this.axisLength=1,this.maxTicks=1,this.dataOnEdge=true,this.max=i,this.min=t,null!=a.dataOnEdge&&(this.dataOnEdge=a.dataOnEdge),this.reverse=e===s.Horizontal?null!=a.reverse&&a.reverse:null==a.reverse||!a.reverse,this.setMinMaxValues(t,i,!1)}setAxisLength(e){this.axisLength=e,this.maxTicks=e/50,this.calculate()}setMinMaxValues(e,t,i=!0){if(e===t){const i=e;if(0===i)e=-1,t=1;else if(i<0){e=i-((t=-(2**(Math.log2(Math.abs(i))-1)))-i)}else{t=i+(i-(e=2**(Math.log2(i)-1)))}}this.minValue=e,this.maxValue=t,this.max=t,this.min=e,this.range=t-e,i&&this.calculate()}niceNum(e,t){const i=Math.abs(e),s=Math.floor(Math.log10(i)),a=i/10**s;let n;return n=t?a<1.5?1:a<3?2:a<7?5:10:a<=1?1:a<=2?2:a<=5?5:10,n*10**s}}class C extends A{constructor(e,t=[],i={}){super(e,0,0,i),this.direction=e,this.categories=t,this.reverse&&this.categories.reverse(),this.tickLabels=this.categories.map((e=>F(e)))}percentToValue(e){return this.posToValue(e*this.axisLength)}posToValue(e){let t=1/0,i=Number.NaN;for(let s=0;s<this.tickPos.length;s++){const a=this.tickPos[s],n=Math.abs(e-a);n<t&&(t=n,i=this.categories[s])}return i}valueToPercent(e){const t=F(e),i=this.tickLabels.findIndex((e=>e===t));return-1!==i?this.tickPos[i]/this.axisLength:0}valueToPos(e){return this.valueToPercent(e)*this.axisLength}calculate(){const e=this.tickLabels.length;let t=0;this.tickSpacing=this.axisLength/(this.dataOnEdge?e-1:e),this.tickPos=[];for(let i=0;i<e;i++)[0,e].includes(i)?t+=this.dataOnEdge?0:this.tickSpacing/2:t+=this.tickSpacing,this.tickPos.push(t)}}class T extends Error{constructor(e){super(`[Hermes] ${e instanceof Error?e.message:S(e)?e:"Critical error encountered!"}`)}}class R extends A{constructor(e,t,i,s,a,n={}){super(e,t,i,n),this.direction=e,this.finiteMin=t,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.config=n,this.actualMax=a,this.actualMin=s}percentToValue(e){if(0===e)return this.reverse?this.actualMax:this.actualMin;if(1===e)return this.reverse?this.actualMin:this.actualMax;const t=this.dataOnEdge?this.minValue:this.min,i=this.dataOnEdge?this.maxValue:this.max;return(this.reverse?1-e:e)*(i-t)+t}posToValue(e){return this.percentToValue(e/this.axisLength)}valueToPercent(e){if(!v(e))return Number.NaN;if(e===this.actualMax)return this.reverse?0:1;if(e===this.actualMin)return this.reverse?1:0;const t=this.dataOnEdge?this.minValue:this.min,i=(e-t)/((this.dataOnEdge?this.maxValue:this.max)-t);return this.reverse?1-i:i}valueToPos(e){return this.valueToPercent(e)*this.axisLength}calculate(){this.range=this.niceNum(this.maxValue-this.minValue,!1),this.tickSpacing=this.niceNum(this.range/this.maxTicks,!0),this.min=Math.floor(this.minValue/this.tickSpacing)*this.tickSpacing,this.max=Math.ceil(this.maxValue/this.tickSpacing)*this.tickSpacing;const e=Math.round((this.max-this.min)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let t=0;t<=e;t++){let i=t*this.tickSpacing+this.min;this.dataOnEdge&&0===t&&(i=this.minValue),this.dataOnEdge&&t===e&&(i=this.maxValue),this.ticks.push(i);let s=P(i);this.dataOnEdge&&[0,e].includes(t)&&(s=`*${s}`),this.tickLabels.push(s)}this.tickPos=this.ticks.map((e=>this.valueToPos(e)))}}const _=e=>t=>Math.log(t)/Math.log(e);class V extends A{constructor(e,t,i,s,a,n=10,l={}){super(e,t,i,l),this.direction=e,this.finiteMin=t,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.logBase=n,this.maxExp=Number.NaN,this.maxExpExact=Number.NaN,this.minExp=Number.NaN,this.minExpExact=Number.NaN,this.log=_(n),this.logBase=n,this.actualMax=a,this.actualMin=s}setLogBase(e=10){this.logBase=e,this.calculate()}percentToValue(e){if(0===e)return this.reverse?this.actualMax:this.actualMin;if(1===e)return this.reverse?this.actualMin:this.actualMax;const t=this.dataOnEdge?this.minExpExact:this.minExp,i=(this.reverse?1-e:e)*this.rangeExp()+t;return this.logBase**i}posToValue(e){return this.percentToValue(e/this.axisLength)}valueToPercent(e){if(!v(e))return 0;const t=this.log(e),i=this.dataOnEdge?this.minExpExact:this.minExp,s=(t-i)/((this.dataOnEdge?this.maxExpExact:this.maxExp)-i);return this.reverse?1-s:s}valueToPos(e){return this.valueToPercent(e)*this.axisLength}rangeExp(){return this.dataOnEdge?this.maxExpExact-this.minExpExact:this.maxExp-this.minExp}calculate(){this.log=_(this.logBase),this.minExpExact=this.log(this.minValue),this.maxExpExact=this.log(this.maxValue),this.minExp=Math.floor(this.minExpExact),this.maxExp=Math.ceil(this.maxExpExact),this.range=this.logBase**this.maxExp-this.logBase**this.minExp,this.tickSpacing=1;const e=Math.round((this.maxExp-this.minExp)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let t=0;t<=e;t++){const i=t*this.tickSpacing+this.minExp;let s=this.logBase**i;this.dataOnEdge&&0===t&&(s=this.logBase**this.minExpExact),this.dataOnEdge&&t===e&&(s=this.logBase**this.maxExpExact),this.ticks.push(s);let a=P(s);this.dataOnEdge&&[0,e].includes(t)&&(a=`*${a}`),this.tickLabels.push(a)}this.tickPos=this.ticks.map((e=>this.valueToPos(e)))}}const $=(e,t)=>e.x*t.x+e.y*t.y,H=(e,t,i,s)=>{const a={x:s.x-t.x,y:s.y-t.y},n={x:i.x-t.x,y:i.y-t.y},l={x:e.x-t.x,y:e.y-t.y},r=$(a,a),o=$(a,n),h=$(a,l),c=$(n,n),d=$(n,l),u=1/(r*c-o*o),f=(c*h-o*d)*u,p=(r*d-o*h)*u;return f>=0&&p>=0&&f+p<1},W=(e,t,i={})=>{if(e.save(),i.fillStyle){e.fillStyle=i.fillStyle,e.beginPath(),e.moveTo(t[0].x,t[0].y);for(let i=1;i<t.length;i++)e.lineTo(t[i].x,t[i].y);e.closePath(),e.fill()}if(i.strokeStyle){e.lineCap=i.lineCap||u,e.lineDashOffset=i.lineDashOffset||0,e.lineJoin=i.lineJoin||f,e.lineWidth=i.lineWidth||1,e.miterLimit=i.miterLimit||p,e.strokeStyle=i.strokeStyle,e.beginPath(),e.moveTo(t[0].x,t[0].y);for(let i=1;i<t.length;i++)e.lineTo(t[i].x,t[i].y);e.closePath(),e.stroke()}e.restore()},j=(e,t,i,s,a={})=>{var n;if(t.length<2)return;e.save(),e.lineCap=a.lineCap||u,e.lineDashOffset=a.lineDashOffset||0,e.lineJoin=a.lineJoin||f,e.lineWidth=a.lineWidth||1,e.miterLimit=a.miterLimit||p,e.strokeStyle=a.strokeStyle||y,e.beginPath(),e.moveTo(t[0].x,t[0].y);const r=null!==(n=s.options.bezierFactor)&&void 0!==n?n:.3;for(let a=1;a<t.length;a++){const[n,o]=[t[a].x,t[a].y];if(s.type===l.Straight)e.lineTo(n,o);else if(s.type===l.Bezier){const[s,l]=[t[a-1].x,t[a-1].y],[h,c]=[s+(i?(n-s)*r:0),l+(i?0:(o-l)*r)],[d,u]=[n-(i?(n-s)*r:0),o-(i?0:(o-l)*r)];e.bezierCurveTo(h,c,d,u,n,o)}}e.stroke(),e.restore()},J=(e,t,i,s,a,n={})=>{e.save(),e.lineCap=n.lineCap||u,e.lineDashOffset=n.lineDashOffset||0,e.lineJoin=n.lineJoin||f,e.lineWidth=n.lineWidth||1,e.miterLimit=n.miterLimit||p,e.strokeStyle=n.strokeStyle||y,e.beginPath(),e.setLineDash(n.lineDash||[]),e.moveTo(Z(t),Z(i)),e.lineTo(Z(s),Z(a)),e.stroke(),e.restore()},q=(e,t,i,s,a,n={})=>{e.save();const l=Z(t),r=Z(i),o=n.cornerRadius||0;n.fillStyle&&(e.fillStyle=n.fillStyle,0===o?e.fillRect(l,r,s,a):(U(e,l,r,s,a,o),e.fill())),n.strokeStyle&&(e.lineCap=n.lineCap||u,e.lineDashOffset=n.lineDashOffset||0,e.lineJoin=n.lineJoin||f,e.lineWidth=n.lineWidth||1,e.miterLimit=n.miterLimit||p,e.strokeStyle=n.strokeStyle,0===o?e.strokeRect(l,r,s,a):(U(e,l,r,s,a,o),e.stroke())),e.restore()},U=(e,t,i,s,a,n)=>{e.beginPath(),e.moveTo(t+n,i),e.lineTo(t+s-n,i),e.quadraticCurveTo(t+s,i,t+s,i+n),e.lineTo(t+s,i+a-n),e.quadraticCurveTo(t+s,i+a,t+s-n,i+a),e.lineTo(t+n,i+a),e.quadraticCurveTo(t,i+a,t,i+a-n),e.lineTo(t,i+n),e.quadraticCurveTo(t,i,t+n,i),e.closePath()},G=(e,t,i,s,a,n={})=>{const l=Q(a),r=l>Math.PI/2&&l<=3*Math.PI/2,o=-a-(r?Math.PI:0);e.save(),ee(e,n.font),e.direction=n.direction||"inherit",e.textAlign=n.textAlign||(r?"right":"left"),e.textBaseline=n.textBaseline||"middle",o%2*Math.PI!=0&&(e.translate(i,s),e.rotate(o),e.translate(-i,-s)),n.strokeStyle&&(e.lineCap=n.lineCap||u,e.lineDashOffset=n.lineDashOffset||0,e.lineJoin=n.lineJoin||f,e.lineWidth=n.lineWidth||1,e.miterLimit=n.miterLimit||p,e.strokeStyle=n.strokeStyle,e.strokeText(t,i,s)),n.fillStyle&&(e.fillStyle=n.fillStyle,e.fillText(t,i,s)),e.restore()},X=(e,t,i,s,a,n=0,l=0,r=0)=>{const o=e+n-r,h=t+l-r,c=e+i+n+r,d=t+s+l+r,u=[{x:o,y:h},{x:c,y:h},{x:c,y:d},{x:o,y:d}];if(null!=a){const i=Q(a);return u.map((s=>((e,t,i,s=0,a=0)=>{const n=e-s,l=t-a,r=Math.cos(i),o=Math.sin(i);return{x:r*n-o*l+s,y:o*n+r*l+a}})(s.x,s.y,-i,e,t)))}return u},Y=(e,t,i=d)=>{ee(e,i);const s=e.measureText(t),a=s.actualBoundingBoxLeft+s.actualBoundingBoxRight;return{h:s.actualBoundingBoxAscent+s.actualBoundingBoxDescent,w:a}},K=e=>{const t=devicePixelRatio<=1?1:2-.5**(devicePixelRatio-1);return Array.isArray(e)?2===e.length?[e[0]*t,e[1]*t,e[0]*t,e[1]*t]:e.map((e=>e*t)):new Array(4).fill(e*t)},Q=e=>(e+2*Math.PI)%(2*Math.PI),Z=e=>Math.round(e-.5)+.5,ee=(e,t=d)=>{const i=new RegExp(/(-?\d*\.?\d+)px/),s=t.match(i);if(2===(null==s?void 0:s.length)){const a=Math.round(parseFloat(s[1])*devicePixelRatio);e.font=t.replace(i,`${a}px`)}else e.font=t},te=(e,t)=>{const i=e.length;if(i<1)return"#000000";if(1===i)return e[0];const s=t*(i-1),a=Math.floor(s),n=Math.ceil(s),l=((e,t,i)=>{const s=Math.round((t.r-e.r)*i+e.r),a=Math.round((t.g-e.g)*i+e.g),n=Math.round((t.b-e.b)*i+e.b);if(null!=e.a&&null!=t.a)return{a:(t.a-e.a)*i+e.a,b:n,g:a,r:s};return{b:n,g:a,r:s}})(ie(e[a]),ie(e[n]),s-a);return(e=>null!=e.a?`rgba(${e.r}, ${e.g}, ${e.b}, ${e.a})`:`rgb(${e.r}, ${e.g}, ${e.b})`)(l)},ie=e=>{if(/^#/.test(e))return(e=>{const t={b:0,g:0,r:0},i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return i&&i.length>3&&(t.r=parseInt(i[1],16),t.g=parseInt(i[2],16),t.b=parseInt(i[3],16)),t})(e);const t=/^rgba?\(\s*?(\d+)\s*?,\s*?(\d+)\s*?,\s*?(\d+)\s*?(,\s*?([\d.]+)\s*?)?\)$/i.exec(e);if(t&&t.length>3){const e={a:1,b:0,g:0,r:0};return e.r=parseInt(t[1]),e.g=parseInt(t[2]),e.b=parseInt(t[3]),t.length>5&&void 0!==t[5]&&(e.a=parseFloat(t[5])),e}return{a:1,b:0,g:0,r:0}},se=(e,t)=>{const i=t.getBoundingClientRect();return{x:(e.clientX-i.x)*devicePixelRatio,y:(e.clientY-i.y)*devicePixelRatio}},ae=(e,t)=>{let i;return(...s)=>{null==i&&(i=setTimeout((()=>{e(...s),i=void 0}),t))}},ne=(t,i,s)=>{const a=i.shared.action,n=a.type===e.LabelMove&&a.dimIndex===t,l=i.dimension.bound||h,r=i.dimension.boundOffset||{x:0,y:0};return n?(c=r,{h:(o=l).h,w:o.w,x:o.x+c.x,y:o.y+c.y}):s;var o,c},le=e=>1===M(e.p0,e.p1)?[e.p1,e.p0]:[e.p0,e.p1],re=e=>isNaN(e.p0)&&isNaN(e.p1),oe=(e,t)=>{const i=k(x);return e.p0<t.p0?(i.p0=e.p0,i.percent0=e.percent0,i.value0=e.value0):(i.p0=t.p0,i.percent0=t.percent0,i.value0=t.value0),e.p1>t.p1?(i.p1=e.p1,i.percent1=e.percent1,i.value1=e.value1):(i.p1=t.p1,i.percent1=t.percent1,i.value1=t.value1),i.hasNaN=e.hasNaN||t.hasNaN,i.hasNegativeInfinity=e.hasNegativeInfinity||t.hasNegativeInfinity,i.hasPositiveInfinity=e.hasPositiveInfinity||t.hasPositiveInfinity,i},he={accuracy:[.55,.99],dropout:[.2,.8],"global-batch-size":[5,30],"layer-free-decay":[.001,.1],"layer-split-factor":[1,16],"learning-rate":[1e-4,.1],"learning-rate-decay":[1e-6,.001],loss:[1.7,2.4],"metrics-base":[.5,.9],"n-filters":[8,64]},ce=[{dataOnEdge:!1,key:"dropout",label:"Dropout",type:i.Linear},{dataOnEdge:!1,key:"global-batch-size",label:"Global Batch Size",type:i.Linear},{categories:[4,8,16,32,64],dataOnEdge:!1,key:"layer-dense-size",label:"Layer Dense Size",type:i.Categorical},{dataOnEdge:!1,key:"layer-free-decay",label:"Layer Free Decay",logBase:10,type:i.Logarithmic},{categories:[!0,!1],dataOnEdge:!1,key:"layer-inverse",label:"Layer Inverse",type:i.Categorical},{dataOnEdge:!1,key:"learning-rate",label:"Learning Rate",logBase:10,type:i.Logarithmic},{dataOnEdge:!1,key:"learning-rate-decay",label:"Learning Rate Decay",logBase:10,type:i.Logarithmic},{dataOnEdge:!1,key:"layer-split-factor",label:"Layer Split Factor",logBase:2,type:i.Logarithmic},{dataOnEdge:!1,key:"metrics-base",label:"Metrics Base",type:i.Linear},{dataOnEdge:!1,key:"n-filters",label:"N Filters",type:i.Linear}],de=[{dataOnEdge:!0,disableDrag:!0,key:"accuracy",label:"Accuracy",type:i.Linear},{dataOnEdge:!0,disableDrag:!0,key:"loss",label:"Loss",type:i.Logarithmic}];var ue=Object.freeze({__proto__:null,DEFAULT_DIMENSION_COUNT:10,dimensionRanges:he,dimensionSamples:ce,metricDimensionSamples:de,generateData:(e,t,s=!0,a={})=>e.reduce(((e,n)=>(e[n.key]=new Array(t).fill(null).map(((e,l)=>{if(n.type===i.Categorical){if(n.categories)return s?w(n.categories):E(n.categories,l)}else if(n.type===i.Linear){const e=he[n.key];if(e)return s?O(e[1],e[0],a):D(e[1],e[0],t,l,a)}else if(n.type===i.Logarithmic){const e=he[n.key];if(e&&n.logBase)return s?((e,t,i,s={})=>{const a=10===e?Math.log10:2===e?Math.log2:Math.log,n=a===Math.log?Math.log(e):1,l=a(t)/n,r=a(i)/n,o=O(l,r,s);return isNaN(o)||!isFinite(o)?o:e**o})(n.logBase,e[1],e[0],a):((e,t,i,s,a,n={})=>{const l=10===e?Math.log10:2===e?Math.log2:Math.log,r=l===Math.log?Math.log(e):1,o=l(t)/r,h=l(i)/r;return e**D(o,h,s,a,n)})(n.logBase,e[1],e[0],t,l)}return r})),e)),{}),generateDimensions:(e=10,t=!0)=>{const i=new Array(e-1).fill(null).map(((e,i)=>t?w(ce):E(ce,i))),s=t?w(de):E(de,0);return i.push(s),i}});class fe{constructor(e,t,i,s){this.config=g,this.data={},this.dataInfo={hasInfinity:!1,hasNaN:!1,seriesCount:0},this.dimensions=[],this.dimensionsOriginal=[],this.filters={},this.size={h:0,w:0},this.ix=k(m),this._=void 0;const a=(e=>S(e)?document.querySelector(e):e)(e);if(!a)throw new T("Target element selector did not match anything.");this.element=a;const n=this.element.getBoundingClientRect();if(0===n.width||0===n.height)throw new T("Target element width and height must both be greater than 0px.");const l=this.element.querySelectorAll("canvas");0===l.length?(this.canvas=document.createElement("canvas"),this.element.appendChild(this.canvas)):this.canvas=l[0];const r=this.canvas.getContext("2d");if(!r)throw new T("Unable to get context from target element.");this.ctx=r,t&&this.setDimensions(t,!1),i&&this.setConfig(i,!1),s&&this.setData(s,!1),(t||i||s)&&this.redraw(),this.listeners={dblclick:this.handleDoubleClick.bind(this),mousedown:this.handleMouseDown.bind(this),mousemove:0===this.config.interactions.throttleDelayMouseMove?this.handleMouseMove.bind(this):ae((e=>this.handleMouseMove.bind(this)(e)),this.config.interactions.throttleDelayMouseMove),mouseup:this.handleMouseUp.bind(this)},this.enable()}static deepMerge(...e){return L(...e)}static getTester(){return ue}static validateData(e,t){const i={count:0,message:"",valid:!0},s=Object.keys(e),a=Object.values(e);for(let e=0;e<a.length;e++){const t=a[e];if(0===e)i.count=t.length;else if(t.length!==i.count)return i.message="The dimension data are not uniform in size.",i.valid=!1,i;if(-1!==t.findIndex((e=>null==e))){const a=null===t;return i.message=`Data for "${s[e]}" has ${a?"null":"undefined"}`,i.valid=!1,i}}const n=Object.keys(e);for(let e=0;e<t.length;e++){const s=t[e].key;if(!n.includes(s))return i.message=`Data for "${s} is missing.`,i.valid=!1,i}return i}static validateDimension(e){if(e.type===i.Categorical){if(!e.categories||0===e.categories.length)return{message:`Categorical dimension "${e.key}" is missing "categories".`,valid:!1}}else if(e.type===i.Logarithmic&&(null==e.logBase||0===e.logBase))return{message:`Logarithmic dimension "${e.key}" is missing "logBase".`,valid:!1};return{message:"",valid:!0}}static validateDimensions(e){if(0===e.length)return{message:"Need at least one dimension defined.",valid:!1};for(let t=0;t<e.length;t++){const{message:i,valid:s}=fe.validateDimension(e[t]);if(!s)return{message:i,valid:s}}return{message:"",valid:!0}}setConfig(e={},t=!0){this.config=L(g,e),this.addObservers(),t&&this.redraw()}setData(e,t=!0){const i=fe.validateData(e,this.dimensionsOriginal);if(!i.valid)throw new T(i.message);this.data=e,this.dataInfo=(e=>{const t=Object.keys(e),i={hasInfinity:!1,hasNaN:!1,seriesCount:0};for(const s of t){i.seriesCount=i.seriesCount||e[s].length;for(const t of e[s])isNaN(t)&&(i.hasNaN=!0),isNaN(t)||isFinite(t)||(i.hasInfinity=!0)}return i})(this.data),this.setDimensions(this.dimensionsOriginal,!1),t&&this.redraw()}setDimensions(e,t=!0){const a=fe.validateDimensions(e);if(!a.valid)throw new T(a.message);const n=this.config.direction===s.Horizontal?s.Vertical:s.Horizontal;this.dimensionsOriginal=e,this.dimensions=k(e).map((e=>{const t=e.key,s=this.data[t]||[],a={...e,labelTruncated:z(e.label,{size:this.config.style.dimension.label.truncate}),rangeActual:void 0,rangeFinite:void 0,scale:new R(n,0,100,0,100)};if(e.type===i.Linear||e.type===i.Logarithmic){const t=B(s,e.type);e.type===i.Linear?a.scale=new R(n,t.finite[0],t.finite[1],t.actual[0],t.actual[1],e):e.type===i.Logarithmic&&(a.scale=new V(n,t.finite[0],t.finite[1],t.actual[0],t.actual[1],e.logBase,e))}else e.type===i.Categorical&&(a.scale=new C(n,e.categories,e));return a})),t&&this.redraw()}setSize(e,t,i=!0){var s,a;const n={h:this.size.h,w:this.size.w},l=Math.round(e*devicePixelRatio),r=Math.round(t*devicePixelRatio);this.canvas.width=l,this.canvas.height=r,this.canvas.style.width=`${e}px`,this.canvas.style.height=`${t}px`,this.size={h:r,w:l},null===(a=(s=this.config.hooks).onResize)||void 0===a||a.call(s,this.size,n),i&&this.redraw()}disable(){this.removeListeners(),this.removeObservers(),this.ix=k(m),this.updateCursor(),this.redraw()}enable(){this.addListeners(),this.addObservers()}redraw(){0===this.size.w&&0===this.size.h||(this.calculate(),this.clear(),this.config.debug&&this.drawDebugOutline(),this.draw())}destroy(){this.removeListeners(),this.removeObservers(),this.canvas&&this.element.contains(this.canvas)&&this.element.removeChild(this.canvas)}addListeners(){this.element.addEventListener("dblclick",this.listeners.dblclick),this.element.addEventListener("mousedown",this.listeners.mousedown),window.addEventListener("mousemove",this.listeners.mousemove),window.addEventListener("mouseup",this.listeners.mouseup)}addObservers(){this.resizeObserver&&(this.resizeObserver.unobserve(this.element),this.resizeObserver=void 0),this.resizeObserver=new ResizeObserver(0===this.config.interactions.throttleDelayResize?this.handleResize.bind(this):ae((e=>this.handleResize.bind(this)(e)),this.config.interactions.throttleDelayResize)),this.resizeObserver.observe(this.element)}removeListeners(){this.element.removeEventListener("dblclick",this.listeners.dblclick),this.element.removeEventListener("mousedown",this.listeners.mousedown),window.removeEventListener("mousemove",this.listeners.mousemove),window.removeEventListener("mouseup",this.listeners.mouseup)}removeObservers(){var e;null===(e=this.resizeObserver)||void 0===e||e.unobserve(this.element),this.resizeObserver=void 0}calculate(){this.calculateLayout(),this.calculateStyles()}calculateLayout(){var e,i;const a={dims:{list:new Array(this.dimensions.length).fill(void 0).map((()=>({axes:{},label:{},layout:{}}))),map:this.dimensions.reduce(((e,t,i)=>(e[t.key]=i,e)),{}),shared:{axes:{},label:{},layout:{}}},layout:{drawRect:{},padding:K(this.config.style.padding)}},{h:l,w:r}=this.size,o=a.layout,h=a.dims.shared.axes,c=a.dims.shared.label,d=a.dims.shared.layout,u=this.dimensions.length,f=this.config.direction===s.Horizontal,p=this.config.style.dimension.label,y=this.config.style.dimension.label.boundaryPadding,g=this.config.style.dimension.layout,x=this.config.style.axes.label,m=this.config.style.axes.axis,v=this.config.style.axes.axis.boundaryPadding,b=p.placement===n.Before,N=null!=p.angle,S=x.placement===n.Before;if(o.drawRect={h:l-o.padding[0]-o.padding[2],w:r-o.padding[1]-o.padding[3],x:o.padding[3],y:o.padding[0]},c.cos=N?Math.cos(null!==(e=p.angle)&&void 0!==e?e:0):void 0,c.sin=N?Math.sin(null!==(i=p.angle)&&void 0!==i?i:0):void 0,c.rad=p.angle||(f?void 0:b?-Math.PI:0),c.maxLengthCos=0,c.maxLengthSin=0,this.dimensions.forEach(((e,t)=>{const i=Y(this.ctx,e.labelTruncated,p.font),s=a.dims.list[t].label;s.w=i.w,s.h=i.h,s.lengthCos=N?i.w*c.cos:i.w,s.lengthSin=N?i.w*c.sin:i.h,Math.abs(s.lengthCos)>Math.abs(c.maxLengthCos)&&(c.maxLengthCos=s.lengthCos),Math.abs(s.lengthSin)>Math.abs(c.maxLengthSin)&&(c.maxLengthSin=s.lengthSin)})),h.start=h.stop=0,h.startInfinity=h.stopInfinity=h.startNaN=h.stopNaN=void 0,f){if(b){const e=Math.max(0,c.maxLengthSin);h.start=o.padding[0]+e+p.offset,h.stop=l-o.padding[2]}else{const e=N?Math.max(0,-c.maxLengthSin):c.maxLengthSin;h.start=o.padding[0],h.stop=l-o.padding[2]-e-p.offset}h.stopNaN=this.dataInfo.hasNaN?h.stop:void 0,h.startInfinity=h.start,h.stopInfinity=h.stop-(this.dataInfo.hasNaN?m.nanGap:0),h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}else{if(b){const e=N?Math.max(0,-c.maxLengthCos):c.maxLengthCos;h.start=o.padding[3]+e+p.offset,h.stop=r-o.padding[1]}else{const e=Math.max(0,c.maxLengthCos);h.start=o.padding[3],h.stop=r-o.padding[1]-e-p.offset}h.startNaN=this.dataInfo.hasNaN?h.start:void 0,h.startInfinity=h.start+(this.dataInfo.hasNaN?m.nanGap:0),h.stopInfinity=h.stop,h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}if(h.length=h.stop-h.start,h.labelFactor=S?-1:1,d.totalBoundSpace=0,this.dimensions.forEach(((e,t)=>{const i=a.dims.list[t].axes,s=a.dims.list[t].label,n=a.dims.list[t].layout,c=e.scale;i.tickLabels=[],i.tickPos=[],i.maxLength=0,c&&(c.setAxisLength(h.stopData-h.startData),i.tickLabels=c.tickLabels.slice(),i.tickPos=c.tickPos.slice(),c.tickLabels.forEach((e=>{const t=Y(this.ctx,e,x.font);i.maxLength=Math.max(t.w,i.maxLength)}))),N?(n.spaceBefore=f?s.lengthCos<0?-s.lengthCos:0:s.lengthSin>0?s.lengthSin:0,n.spaceAfter=f?s.lengthCos>0?s.lengthCos:0:s.lengthSin<0?-s.lengthSin:0):(n.spaceBefore=(f?s.lengthCos:s.lengthSin)/2,n.spaceAfter=(f?s.lengthCos:s.lengthSin)/2),S?n.spaceBefore=Math.max(n.spaceBefore,i.maxLength):n.spaceAfter=Math.max(n.spaceAfter,i.maxLength),f?(n.bound={h:l-o.padding[0]-o.padding[2],w:n.spaceBefore+n.spaceAfter,x:0,y:o.padding[0]},d.totalBoundSpace+=n.bound.w):(n.bound={h:n.spaceBefore+n.spaceAfter,w:r-o.padding[1]-o.padding[3],x:o.padding[3],y:0},d.totalBoundSpace+=n.bound.h)})),f){const e=o.drawRect.w-d.totalBoundSpace;d.gap=u>1?Math.max(e,0)/(u-1):0,d.offset=o.padding[3],d.space=u>1?o.drawRect.w/(u-1):0}else{const e=o.drawRect.h-d.totalBoundSpace;d.gap=u>1?Math.max(e,0)/(u-1):0,d.offset=o.padding[0],d.space=u>1?o.drawRect.h/(u-1):0}let k=d.offset;for(let e=0;e<a.dims.list.length;e++){const i=a.dims.list[e].label,s=a.dims.list[e].layout;f?(g===t.AxisEvenlySpaced?(s.bound.x=k-s.spaceBefore,k+=d.space):g===t.Equidistant&&(s.bound.x=k,k+=d.gap+s.bound.w),s.axisBoundaryStart={x:s.spaceBefore,y:h.start-o.padding[0]},s.axisBoundaryStop={x:s.spaceBefore,y:h.stop-o.padding[0]},s.axisInfinityStart={x:s.spaceBefore,y:h.startInfinity-o.padding[0]},s.axisInfinityStop={x:s.spaceBefore,y:h.stopInfinity-o.padding[0]},s.axisDataStart={x:s.spaceBefore,y:h.startData-o.padding[0]},s.axisDataStop={x:s.spaceBefore,y:h.stopData-o.padding[0]},s.labelPoint={x:s.spaceBefore,y:b?h.start-p.offset-o.padding[0]:h.stop+p.offset-o.padding[0]}):(g===t.AxisEvenlySpaced?(s.bound.y=k-s.spaceBefore,k+=d.space):g===t.Equidistant&&(s.bound.y=k,k+=d.gap+s.bound.h),s.axisBoundaryStart={x:h.start-o.padding[3],y:s.spaceBefore},s.axisBoundaryStop={x:h.stop-o.padding[3],y:s.spaceBefore},s.axisInfinityStart={x:h.startInfinity-o.padding[3],y:s.spaceBefore},s.axisInfinityStop={x:h.stopInfinity-o.padding[3],y:s.spaceBefore},s.axisDataStart={x:h.startData-o.padding[3],y:s.spaceBefore},s.axisDataStop={x:h.stopData-o.padding[3],y:s.spaceBefore},s.labelPoint={x:b?h.start-p.offset-o.padding[1]:h.stop+p.offset-o.padding[1],y:s.spaceBefore});const n=f?-i.w/2:0,l=f?b?-i.h:0:-i.h/2;s.labelBoundary=X(s.bound.x+s.labelPoint.x,s.bound.y+s.labelPoint.y,i.w,i.h,c.rad,N?0:n,N?-i.h/2:l,y),s.axisBoundary=[{x:s.bound.x+s.axisBoundaryStart.x-(f?v:0),y:s.bound.y+s.axisBoundaryStart.y-(f?0:v)},{x:s.bound.x+s.axisBoundaryStart.x+(f?v:0),y:s.bound.y+s.axisBoundaryStart.y+(f?0:v)},{x:s.bound.x+s.axisBoundaryStop.x+(f?v:0),y:s.bound.y+s.axisBoundaryStop.y+(f?0:v)},{x:s.bound.x+s.axisBoundaryStop.x-(f?v:0),y:s.bound.y+s.axisBoundaryStop.y-(f?0:v)}]}this._=a}calculateStyles(){if(!this._)return;this._.styles=this._.styles||[];const t=this.config.style,i=t.axes,s=t.dimension,n=this._.dims.list,l=this._.styles,r=this.ix.shared.action,o=this.ix.shared.focus,h=r.type!==e.None;for(let t=0;t<n.length;t++){const n=this.dimensions[t].key,c=this.filters[n]||[],d=r.type===e.LabelMove&&r.dimIndex===t,u=(null==o?void 0:o.type)===a.DimensionLabel&&(null==o?void 0:o.dimIndex)===t,f=(r.type===e.FilterCreate||r.type===e.FilterMove||r.type===e.FilterResizeAfter||r.type===e.FilterResizeBefore)&&r.dimIndex===t,p=((null==o?void 0:o.type)===a.DimensionAxis||(null==o?void 0:o.type)===a.Filter||(null==o?void 0:o.type)===a.FilterResize)&&(null==o?void 0:o.dimIndex)===t;l[t]=l[t]||{},l[t].label={...s.label,...d||!u||h?{}:s.labelHover,...d?s.labelActive:{}},l[t].axis={...i.axis,...f||!p||h?{}:i.axisHover,...f?i.axisActive:{}},l[t].tick={...i.tick,...f||!p||h?{}:i.tickHover,...f?i.tickActive:{}},l[t].tickLabel={...i.label,...f||!p||h?{}:i.labelHover,...f?i.labelActive:{}},l[t].filters=c.map(((e,s)=>{const n=((null==o?void 0:o.type)===a.Filter||(null==o?void 0:o.type)===a.FilterResize)&&(null==o?void 0:o.dimIndex)===t&&(null==o?void 0:o.filterIndex)===s,l=f||p&&!n,h=n&&void 0===r.filterIndex,c=r.dimIndex===t&&r.filterIndex===s;return{...i.filter,...l?i.filterAxisHover:{},...h?i.filterHover:{},...c?i.filterActive:{}}}))}}getFocusByPoint(e){if(!this._)return;const t=this._.dims.shared.axes,i=this.config.direction===s.Horizontal?"y":"x",n=this._.dims.shared.axes.length;for(let s=0;s<this._.dims.list.length;s++){const l=this.dimensions[s].key,r=this._.dims.list[s].layout,o=r.labelBoundary;if((H(e,o[0],o[1],o[2])||H(e,o[2],o[3],o[0]))&&!this.dimensions[s].disableDrag)return{dimIndex:s,type:a.DimensionLabel};const h=r.axisBoundary;if(H(e,h[0],h[1],h[2])||H(e,h[2],h[3],h[0])){const o=this.filters[l]||[],h=r.bound[i]+r.axisBoundaryStart[i],c=(e[i]-h)/n,d=o.findIndex((e=>c>=e.p0&&c<=e.p1));let u=a.DimensionAxis;if(-1!==d){const e=3/t.length,i=o[d];u=c<=i.p0+e||c>=i.p1-e?a.FilterResize:a.Filter}return{dimIndex:s,filterIndex:d,type:u}}}}updateActiveLabel(){var t,i;if(!this._||this.ix.shared.action.type!==e.LabelMove)return;const a=this._.dims.list,n=this.ix,l=n.dimension,r=n.shared.action,o=this.config.direction===s.Horizontal,h=o?"x":"y";l.boundOffset={x:o?r.p1.x-r.p0.x:0,y:o?0:r.p1.y-r.p0.y};let c=-1;const d=l.axis+l.boundOffset[h];for(let e=0;e<a.length;e++){if(r.dimIndex===e||this.dimensions[e].disableDrag)continue;const t=a[e].layout,i=t.bound[h]+t.axisBoundaryStart[h],s=Math.abs(d-i)<30;if(r.dimIndex<e){if(d<i&&!s)break;c=e}if(r.dimIndex>e&&(d<i||s)){c=e;break}}if(-1!==c){const e=r.dimIndex,s=this.dimensions.splice(r.dimIndex,1);if(0===s.length)return;this.dimensions.splice(c,0,s[0]),r.dimIndex=c,null===(i=(t=this.config.hooks).onDimensionMove)||void 0===i||i.call(t,s[0],c,e)}}setConfigFilters(e={}){if(this.calculate(),!this._)return;const t=this._.dims.map;Object.keys(e).forEach((e=>{this.filters[e]=this.config.filters[e].map((i=>{const s={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:i[0],p1:i[1],percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN};return this.processFilter(s,t[e]),s}))})),this.redraw()}setActiveFilter(t,i){if(!this._)return;const s=this.filters,a=this.ix,n=a.shared.action,l=a.filters,r=this._.dims.shared.axes,o=(s[t]||[]).findIndex((e=>i>=e.p0&&i<=e.p1));-1!==o?(l.active=s[t][o],l.active.startP0=l.active.p0,l.active.startP1=l.active.p1,n.filterIndex=o,i>=l.active.p0&&i<=l.active.p0+3/r.length?n.type=e.FilterResizeBefore:i>=l.active.p1-3/r.length&&i<=l.active.p1?n.type=e.FilterResizeAfter:n.type=e.FilterMove):(n.type=e.FilterCreate,l.active={...x,p0:i,p1:i},s[t]=s[t]||[],s[t].push(l.active),n.filterIndex=s[t].length-1)}updateActiveFilter(t){var i,a,n,l,r,o,h,c,d,u,f,p;if(!this._)return;const y=this._.dims.list,g=this._.dims.shared.axes,m=this.ix,v=m.filters,b=m.shared.action,N=this.filters,S=b.dimIndex,k=this.config.direction===s.Horizontal?"y":"x";if(!(b.type===e.FilterCreate||b.type===e.FilterMove||b.type===e.FilterResizeAfter||b.type===e.FilterResizeBefore)||!v.key)return;const L=this.dimensions[b.dimIndex].key,B=y[b.dimIndex].layout.bound,E=y[b.dimIndex].layout.axisBoundaryStart[k];if(b.type===e.FilterMove){const e=null!==(i=v.active.startP0)&&void 0!==i?i:0,t=null!==(a=v.active.startP1)&&void 0!==a?a:0,s=t-e,n=(b.p1[k]-b.p0[k])/g.length;v.active.p0=e+n,v.active.p1=t+n,v.active.p0<=0?(v.active.p0=0,v.active.p1=s):v.active.p1>=1&&(v.active.p0=1-s,v.active.p1=1)}else b.type===e.FilterResizeBefore?(v.active.p0=(b.p1[k]-B[k]-E)/g.length,v.active.p0=I(v.active.p0,[0,1])):(v.active.p1=(b.p1[k]-B[k]-E)/g.length,v.active.p1=I(v.active.p1,[0,1]));if(this.processFilter(v.active,S),"mouseup"===t.type){if(D=b.p0,w=b.p1,Math.sqrt((w.x-D.x)**2+(w.y-D.y)**2)<1){const e=N[v.key]||[],t=(v.active.p1-v.active.p0)/2+v.active.p0,i=e.findIndex((e=>t>=e.p0&&t<=e.p1));if(-1!==i){const t=le(e[i]);null===(l=(n=this.config.hooks).onFilterRemove)||void 0===l||l.call(n,{[L]:[t]}),e.splice(i,1)}}else{if(v.active.p1<v.active.p0){const e=v.active.p1;v.active.p1=v.active.p0,v.active.p0=e,this.processFilter(v.active,S)}const t={[L]:[le(v.active)]};switch(b.type){case e.FilterCreate:null===(o=(r=this.config.hooks).onFilterCreate)||void 0===o||o.call(r,t);break;case e.FilterMove:null===(c=(h=this.config.hooks).onFilterMove)||void 0===c||c.call(h,t);break;case e.FilterResizeAfter:case e.FilterResizeBefore:null===(u=(d=this.config.hooks).onFilterResize)||void 0===u||u.call(d,t)}}var D,w,O;v.active={...x},v.key=void 0,this.cleanUpFilters(),null===(p=null===(f=this.config.hooks)||void 0===f?void 0:f.onFilterChange)||void 0===p||p.call(f,(O=this.filters,Object.keys(O).reduce(((e,t)=>(e[t]=O[t].map((e=>le(e))).sort(((e,t)=>M(e[0],t[0]))),e)),{})))}}processFilter(e,t){if(!this._)return;const i=this._.dims.list[t].layout,a=this.config.direction===s.Horizontal,n=Math.min(e.p0,e.p1),l=Math.max(e.p0,e.p1),r=i.axisBoundaryStop.x-i.axisBoundaryStart.x,o=i.axisBoundaryStop.y-i.axisBoundaryStart.y,h=a?(i.axisDataStart.y-i.axisBoundaryStart.y)/o:(i.axisDataStart.x-i.axisBoundaryStart.x)/r,c=a?(i.axisDataStop.y-i.axisBoundaryStart.y)/o:(i.axisDataStop.x-i.axisBoundaryStart.x)/r;if(this.dataInfo.hasInfinity)if(a){const t=(i.axisInfinityStop.y-i.axisBoundaryStart.y)/o;e.hasPositiveInfinity=0===n,e.hasNegativeInfinity=n<=t&&l>=t}else{const t=(i.axisInfinityStart.x-i.axisBoundaryStart.x)/r;e.hasNegativeInfinity=n<=t&&l>=t,e.hasPositiveInfinity=1===l}this.dataInfo.hasNaN&&(e.hasNaN=a&&1===l||!a&&0===n);const d=c-h;n<=h?e.percent0=0:n>h&&n<=c&&(e.percent0=(n-h)/d),l>=c?e.percent1=1:l>=h&&l<c&&(e.percent1=(l-h)/d),isNaN(e.percent0)||(e.value0=this.dimensions[t].scale.percentToValue(e.percent0)),isNaN(e.percent1)||(e.value1=this.dimensions[t].scale.percentToValue(e.percent1))}cleanUpFilters(){Object.keys(this.filters).forEach((e=>{const t=this.filters[e]||[];for(let e=0;e<t.length;e++)if((a=t[e]).p0>=a.p1)t[e]={...x};else for(let a=e+1;a<t.length;a++)re(t[e])||re(t[a])||(i=t[e],s=t[a],i.p0<=s.p1&&s.p0<=i.p1&&(t[a]=oe(t[e],t[a]),t[e]={...x}));var i,s,a;this.filters[e]=t.filter((e=>!re(e)))}))}updateCursor(){const t=this.ix,i=t.shared.action,n=t.shared.focus,l=this.config.direction===s.Horizontal;let r="default";i.type!==e.None?i.type===e.FilterMove||i.type===e.LabelMove?r="grabbing":i.type===e.FilterResizeAfter||i.type===e.FilterResizeBefore?r=l?"ns-resize":"ew-resize":i.type===e.FilterCreate&&(r="crosshair"):void 0!==n&&(n.type===a.DimensionLabel?r="grab":n.type===a.DimensionAxis?r="crosshair":n.type===a.Filter?r="grab":n.type===a.FilterResize&&(r=l?"ns-resize":"ew-resize")),this.canvas.style.cursor=r}clear(){const{h:e,w:t}=this.size;this.ctx.clearRect(0,0,t,e)}draw(){var e,t;if(!this._)return;const i=this._.dims.list,l=this._.dims.shared.axes,r=this._.dims.shared.label,o=this._.styles,h=this.ix,c=this.ix.shared.focus,d=this.filters,u=this.config.direction===s.Horizontal,f=this.config.style.axes,p=this.config.style.data,y=this.config.style.dimension,g=y.label.placement===n.Before,x=f.label.placement===n.Before;for(let s=0;s<this.dataInfo.seriesCount;s++){let a=p.default,n=!1,l=!1,r=!1,o=!1,c=!1;(null===(e=p.series)||void 0===e?void 0:e[s])&&(a=null===(t=p.series)||void 0===t?void 0:t[s]);const f=this.dimensions.map(((e,t)=>{var f,y,g,x,m,b;const N=e.key,S=i[t].layout,k=ne(t,h,S.bound),I=this.data[N][s],M=v(I),L=M&&isNaN(I),B=M&&!L&&!isFinite(I),E=B&&I===-1/0,D=B&&I===1/0,w=L||B?0:null!==(y=null===(f=e.scale)||void 0===f?void 0:f.valueToPercent(I))&&void 0!==y?y:0;let O=k.x,P=k.y;if(L)O+=u?S.axisDataStart.x:S.axisBoundaryStart.x,P+=u?S.axisBoundaryStop.y:S.axisDataStart.y;else if(B){const e=E?S.axisInfinityStart.x:S.axisInfinityStop.x,t=D?S.axisInfinityStop.y:S.axisInfinityStart.y;O+=u?S.axisDataStart.x:e,P+=u?t:S.axisDataStart.y}else{const t=null!==(x=null===(g=e.scale)||void 0===g?void 0:g.valueToPos(I))&&void 0!==x?x:0;O+=S.axisDataStart.x+(u?0:t),P+=S.axisDataStart.y+(u?t:0)}if(N===p.targetDimensionKey){const t=null!==(b=null===(m=e.scale)||void 0===m?void 0:m.reverse)&&void 0!==b&&b,i=p.targetColorScale||[],s=te(t?i.slice().reverse():i,w);a.strokeStyle=s}if(d[N]&&0!==d[N].length){n=!0;let e=!1;for(let t=0;t<d[N].length;t++){const i=d[N][t];L&&i.hasNaN?(e=!0,l=!0):E&&i.hasNegativeInfinity?(e=!0,r=!0):D&&i.hasPositiveInfinity&&(e=!0,o=!0),!L&&!B&&!isNaN(i.percent0)&&!isNaN(i.percent1)&&w>=i.percent0&&w<=i.percent1&&(e=!0)}e||(c=!0)}else L?l=!0:E?r=!0:D&&(o=!0);return{x:O,y:P}}));n&&c?a=p.filtered:l&&p.overrideNaN?a=p.overrideNaN:r&&p.overrideNegativeInfinity?a=p.overrideNegativeInfinity:o&&p.overridePositiveInfinity&&(a=p.overridePositiveInfinity),j(this.ctx,f,u,p.path,a)}const m=null==y.label.angle&&u,b={textAlign:m?"center":void 0,textBaseline:m?g?"bottom":"top":void 0};this.dimensions.forEach(((e,t)=>{var s;const a=ne(t,h,i[t].layout.bound),n=i[t].layout.labelPoint,l=a.x+n.x,c=a.y+n.y,d={...o[t].label,...b};G(this.ctx,e.labelTruncated,l,c,null!==(s=r.rad)&&void 0!==s?s:0,d)}));const N=null==f.label.angle&&u,S={textAlign:N?void 0:"center",textBaseline:N?void 0:x?"bottom":"top"};i.forEach(((e,t)=>{var i;const s=this.dimensions[t].key,n=ne(t,h,e.layout.bound),r=e.layout.axisBoundaryStart,p=e.layout.axisBoundaryStop,y=e.layout.axisInfinityStart,g=e.layout.axisInfinityStop,m=e.layout.axisDataStart,v=e.layout.axisDataStop,b=e.axes.tickLabels,N=e.axes.tickPos,k=x?-1:1,I={...o[t].tickLabel,...S},M=u?k*f.tick.length:0,L=u?0:k*f.tick.length,B=d[s]||[];if(J(this.ctx,n.x+m.x,n.y+m.y,n.x+v.x,n.y+v.y,o[t].axis),this.dataInfo.hasInfinity){J(this.ctx,n.x+y.x,n.y+y.y,n.x+m.x,n.y+m.y,{...o[t].axis,lineDash:f.axis.infLineDash}),J(this.ctx,n.x+v.x,n.y+v.y,n.x+g.x,n.y+g.y,{...o[t].axis,lineDash:f.axis.infLineDash,lineDashOffset:null!==(i=f.axis.infLineDash[0])&&void 0!==i?i:0});const e=n.x+y.x,s=n.y+y.y,a=e+M,l=s+L;J(this.ctx,e,s,a,l,o[t].tick);const r=n.x+g.x,h=n.y+g.y,c=r+M,d=h+L;J(this.ctx,r,h,c,d,o[t].tick);const p=u?a+k*f.label.offset:e,b=u?s:l+k*f.label.offset,N=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,S=u?"+Ꝏ":"-Ꝏ";G(this.ctx,S,p,b,N,I);const B=u?c+k*f.label.offset:r,E=u?h:d+k*f.label.offset,D=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,w=u?"-Ꝏ":"+Ꝏ";G(this.ctx,w,B,E,D,I)}if(this.dataInfo.hasNaN){const e=n.x+(u?p.x:r.x),i=n.y+(u?p.y:r.y),s=e+M,a=i+L;J(this.ctx,e,i,s,a,o[t].tick);const l=u?s+k*f.label.offset:e,h=u?i:a+k*f.label.offset,c=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0;G(this.ctx,"NaN",l,h,c,I)}for(let e=0;e<b.length;e++){let i=b[e];if("*"===i[0]){if((null==c?void 0:c.dimIndex)!==t||(null==c?void 0:c.type)!==a.DimensionAxis&&(null==c?void 0:c.type)!==a.Filter&&(null==c?void 0:c.type)!==a.FilterResize)continue;i=i.substring(1)}const s=u?0:N[e],l=u?N[e]:0,r=u?k*f.tick.length:0,h=u?0:k*f.tick.length,d=n.x+m.x+s,p=n.y+m.y+l,y=n.x+m.x+s+r,g=n.y+m.y+l+h;J(this.ctx,d,p,y,g,o[t].tick);const v=u?y+k*f.label.offset:d,I=u?p:g+k*f.label.offset,M=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,L={...o[t].tickLabel,...S};G(this.ctx,i,v,I,M,L)}B.forEach(((e,i)=>{const s=e.p0*l.length,a=e.p1*l.length,h=o[t].filters[i].width,c=h/2,d=n.x+r.x+(u?-c:s),f=n.y+r.y+(u?s:-c),p=u?h:a-s,y=u?a-s:h;q(this.ctx,d,f,p,y,o[t].filters[i])}))}))}drawDebugOutline(){if(!this._)return;const{h:e,w:t}=this.size,i=this._.layout,a=this._.dims.list,n=this._.dims.shared.layout,l=this.config.direction===s.Horizontal,r={strokeStyle:"#dddddd"};J(this.ctx,0,i.padding[0],t,i.padding[0],r),J(this.ctx,0,e-i.padding[2],t,e-i.padding[2],r),J(this.ctx,i.padding[3],0,i.padding[3],e,r),J(this.ctx,t-i.padding[1],0,t-i.padding[1],e,r);const o={strokeStyle:"#999999"},h={strokeStyle:"#ff0000"},c={strokeStyle:"#eeeeee"},d={strokeStyle:"#0099cc"},y={strokeStyle:"#ffcc00"};a.forEach(((e,t)=>{const s=e.layout.bound,a=e.layout.axisBoundary,r=e.layout.labelPoint,g=e.layout.labelBoundary;q(this.ctx,l?i.padding[3]+t*n.space:s.x,l?s.y:i.padding[0]+t*n.space,l?n.space:s.w,l?s.h:n.space,o),q(this.ctx,s.x,s.y,s.w,s.h,h),((e,t,i,s,a={})=>{e.save(),a.fillStyle&&(e.fillStyle=null==a?void 0:a.fillStyle,e.moveTo(t+s,i),e.beginPath(),e.arc(t,i,s,0,2*Math.PI),e.fill()),a.strokeStyle&&(e.lineCap=a.lineCap||u,e.lineDashOffset=a.lineDashOffset||0,e.lineJoin=a.lineJoin||f,e.lineWidth=a.lineWidth||1,e.miterLimit=a.miterLimit||p,e.strokeStyle=a.strokeStyle,e.moveTo(t+s,i),e.beginPath(),e.arc(t,i,s,0,2*Math.PI),e.stroke()),e.restore()})(this.ctx,s.x+r.x,s.y+r.y,3,d),W(this.ctx,g,y),W(this.ctx,a,c)}))}handleResize(e){const t=e.find((e=>e.target===this.element));if(!t)return;const{width:i,height:s}=t.contentRect;0===this.size.w&&0===this.size.h&&0!==i&&0!==s?(this.setSize(i,s),this.setConfigFilters(this.config.filters)):this.setSize(i,s)}handleDoubleClick(){var e,t;this.setDimensions(this.dimensionsOriginal,!1),this.filters={},this.ix=k(m),this.redraw(),null===(t=(e=this.config.hooks).onReset)||void 0===t||t.call(e)}handleMouseDown(t){var i,n;if(!this._)return;const l=this.ix.shared,r=this.ix.shared.action,o=this.ix.dimension,h=this.ix.filters,c=this._.dims.shared.axes,d=this.config.direction===s.Horizontal,u=d?"x":"y",f=d?"y":"x",p=se(t,this.element);if(r.p0=p,r.p1=p,r.filterIndex=-1,l.focus=this.getFocusByPoint(p),l.focus){const t=l.focus.dimIndex,s=this._.dims.list[t].layout,d=s.bound,p=s.axisBoundaryStart;if((null===(i=l.focus)||void 0===i?void 0:i.type)===a.DimensionLabel)r.type=e.LabelMove,r.dimIndex=t,o.axis=d[u]+p[u],o.bound=d;else if([a.DimensionAxis,a.Filter,a.FilterResize].includes(null===(n=l.focus)||void 0===n?void 0:n.type)){r.type=e.FilterCreate,r.dimIndex=t,h.key=this.dimensions[t].key;const i=(r.p0[f]-d[f]-p[f])/c.length;this.setActiveFilter(h.key,i),this.processFilter(h.active,t)}}this.updateCursor(),this.redraw()}handleMouseMove(e){if(!this._)return;const t=se(e,this.element);this.ix.shared.action.p1=t,this.ix.shared.focus=this.getFocusByPoint(t),this.updateActiveLabel(),this.updateActiveFilter(e),this.updateCursor(),this.redraw()}handleMouseUp(e){if(!this._)return;const t=se(e,this.element);this.ix.shared.action.p1=t,this.updateActiveLabel(),this.updateActiveFilter(e),this.ix=k(m),this.ix.shared.focus=this.getFocusByPoint(t),this.updateCursor(),this.redraw()}}exports.ActionType=e,exports.DimensionLayout=t,exports.DimensionType=i,exports.Direction=s,exports.FocusType=a,exports.LabelPlacement=n,exports.PathType=l,exports.default=fe;
