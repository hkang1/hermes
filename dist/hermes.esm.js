const t={FilterCreate:"filter-create",FilterMove:"filter-move",FilterResizeAfter:"filter-resize-after",FilterResizeBefore:"filter-resize-before",LabelMove:"label-move",None:"none"},e={AxisEvenlySpaced:"axis-evenly-spaced",Equidistant:"equidistant"},i={Categorical:"categorical",Linear:"linear",Logarithmic:"logarithmic"},s={Horizontal:"horizontal",Vertical:"vertical"},a={DimensionAxis:"dimension-axis",DimensionLabel:"dimension-label",Filter:"filter",FilterResize:"filter-resize"},n={After:"after",Before:"before"},l={Bezier:"bezier",Straight:"straight"},o=Number.NaN,r={x:Number.NaN,y:Number.NaN},h={h:Number.NaN,w:Number.NaN,x:Number.NaN,y:Number.NaN},c={dimIndex:-1,p0:r,p1:r,type:t.None},d="normal 12px san-serif",u="butt",f="round",p=10,y="black",g={debug:!1,direction:s.Horizontal,filters:{},hooks:{},interactions:{throttleDelayMouseMove:50,throttleDelayResize:50},style:{axes:{axis:{boundaryPadding:15,infLineDash:[2,4],infOffset:24,lineWidth:1,nanGap:24,strokeStyle:"rgba(147, 147, 147, 1.0)"},axisActive:{lineWidth:3,strokeStyle:"rgba(99, 200, 255, 1.0)"},axisHover:{lineWidth:3,strokeStyle:"rgba(79, 180, 246, 1.0)"},filter:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",strokeStyle:"rgba(255, 255, 255, 1.0)",width:4},filterActive:{cornerRadius:3,fillStyle:"rgba(255, 120, 220, 1.0)",width:8},filterAxisHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:6},filterHover:{cornerRadius:2,fillStyle:"rgba(235, 100, 200, 1.0)",width:8},label:{fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:4,placement:n.After,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(0, 0, 0, 1.0)"},labelHover:{fillStyle:"rgba(0, 0, 0, 1.0)"},tick:{length:4,lineWidth:1,strokeStyle:"rgba(147, 147, 147, 1.0)"},tickActive:{strokeStyle:"rgba(99, 200, 255, 1.0)"},tickHover:{strokeStyle:"rgba(79, 180, 246, 1.0)"}},data:{default:{lineWidth:1,strokeStyle:"rgba(82, 144, 244, 1.0)"},filtered:{lineWidth:1,strokeStyle:"rgba(0, 0, 0, 0.05)"},overrideNaN:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overrideNegativeInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},overridePositiveInfinity:{lineWidth:1,strokeStyle:"rgba(255, 0, 0, 0.2)"},path:{options:{},type:l.Straight},series:[],targetColorScale:[],targetDimensionKey:void 0},dimension:{label:{angle:void 0,boundaryPadding:5,fillStyle:"rgba(0, 0, 0, 1.0)",font:"normal 11px sans-serif",lineWidth:3,offset:16,placement:n.Before,strokeStyle:"rgba(255, 255, 255, 1.0)"},labelActive:{fillStyle:"rgba(99, 200, 255, 1.0)"},labelHover:{fillStyle:"rgba(79, 180, 246, 1.0)"},layout:e.AxisEvenlySpaced},padding:[32,64]}},x={hasNaN:!1,hasNegativeInfinity:!1,hasPositiveInfinity:!1,p0:Number.NaN,p1:Number.NaN,percent0:Number.NaN,percent1:Number.NaN,value0:Number.NaN,value1:Number.NaN},m=.01,v={dimension:{axis:0,bound:void 0,boundOffset:void 0,offset:0},filters:{active:x,key:void 0},shared:{action:c,focus:void 0}},b=t=>"number"==typeof t,S=t=>"object"==typeof t&&null!=t&&Object.getPrototypeOf(t)===Object.prototype&&!Array.isArray(t)&&!(t=>t instanceof Map)(t)&&!N(t),N=t=>t instanceof Set,k=t=>"string"==typeof t,I=t=>JSON.parse(JSON.stringify(t)),M=(t,e)=>Math.min(e[1],Math.max(e[0],t)),L=(...t)=>t.reduce(((t,e)=>(Object.keys(e).forEach((i=>{S(t[i])&&S(e[i])?t[i]=L(t[i],e[i]):(Array.isArray(t[i])&&Array.isArray(e[i]),t[i]=e[i])})),t)),{}),B=(t,e)=>t.reduce(((t,s)=>(b(s)&&!isNaN(s)&&((t=>e===i.Logarithmic?isFinite(Math.log(t)):isFinite(t))(s)&&(s<t.finite[0]&&(t.finite[0]=s),s>t.finite[1]&&(t.finite[1]=s)),s<t.actual[0]&&(t.actual[0]=s),s>t.actual[1]&&(t.actual[1]=s)),t)),{actual:[1/0,-1/0],finite:[Number.MAX_VALUE,-Number.MAX_VALUE]}),E=(t,e)=>t[e%t.length],D=(t,e,i,s,a={})=>{var n,l,o;const r=i>1?i-1:1,h=(t-e)/r;if(0!==Object.keys(a).length){const t=null!==(n=a.includeNaN)&&void 0!==n?n:0,e=(null!==(l=a.includeNegativeInfinity)&&void 0!==l?l:0)+t,r=(null!==(o=a.includePositiveInfinity)&&void 0!==o?o:0)+e,h=s/i;if(h<=t)return Number.NaN;if(h<=e)return Number.NEGATIVE_INFINITY;if(h<=r)return Number.POSITIVE_INFINITY}return s%(r+1)*h+e},w=t=>t[((t,e=0)=>Math.floor(Math.random()*(t-e))+e)(t.length)],z=(t,e,i={})=>{if(null!=i.includeNaN){const t=M(i.includeNaN,[0,1]);if(Math.random()<t)return Number.NaN}if(null!=i.includeNegativeInfinity){const t=M(i.includeNegativeInfinity,[0,1]);if(Math.random()<t)return-1/0}if(null!=i.includePositiveInfinity){const t=M(i.includePositiveInfinity,[0,1]);if(Math.random()<t)return 1/0}return Math.random()*(t-e)+e},P=t=>{let e=((t,e=6)=>{let i=t.toString();const s=Math.abs(t);return isNaN(t)?i="NaN":Number.isFinite(t)?0!==s&&(s<.01||s>999?i=t.toExponential(e):Number.isInteger(t)||(i=t.toFixed(e))):i=(t<0?"-":"")+"Infinity",i})(t);return e=e.replace(/(e)\+(\d+)/,"$1$2"),e=e.replace(/0+(e-?\d+)$/,"$1"),e=e.replace(/(\.[0-9]+?)0+$/,"$1"),e=e.replace(/\.(e)/,"$1"),e},O=(t,e={})=>{var i,s;const a=null!==(i=e.size)&&void 0!==i?i:24,n=null!==(s=e.suffix)&&void 0!==s?s:"...";return t.length<=a?t:`${t.substring(0,a)}${n}`},F=t=>k(t)?t:t.toString();class C{constructor(t,e,i,a={}){this.direction=t,this.minValue=e,this.maxValue=i,this.range=0,this.reverse=false,this.tickLabels=[],this.tickPos=[],this.ticks=[],this.tickPadding=0,this.tickSpacing=0,this.axisLength=1,this.maxTicks=1,this.dataOnEdge=true,this.max=i,this.min=e,null!=a.dataOnEdge&&(this.dataOnEdge=a.dataOnEdge),this.reverse=t===s.Horizontal?null!=a.reverse&&a.reverse:null==a.reverse||!a.reverse,this.setMinMaxValues(e,i,!1)}setAxisLength(t){this.axisLength=t,this.maxTicks=t/50,this.calculate()}setMinMaxValues(t,e,i=!0){if(t===e){const i=t;if(0===i)t=-1,e=1;else if(i<0){t=i-((e=-(2**(Math.log2(Math.abs(i))-1)))-i)}else{e=i+(i-(t=2**(Math.log2(i)-1)))}}this.minValue=t,this.maxValue=e,this.max=e,this.min=t,this.range=e-t,i&&this.calculate()}niceNum(t,e){const i=Math.abs(t),s=Math.floor(Math.log10(i)),a=i/10**s;let n;return n=e?a<1.5?1:a<3?2:a<7?5:10:a<=1?1:a<=2?2:a<=5?5:10,n*10**s}}class A extends C{constructor(t,e=[],i={}){super(t,0,0,i),this.direction=t,this.categories=e,this.reverse&&this.categories.reverse(),this.tickLabels=this.categories.map((t=>F(t)))}percentToValue(t){return this.posToValue(t*this.axisLength)}posToValue(t){let e=1/0,i=Number.NaN;for(let s=0;s<this.tickPos.length;s++){const a=this.tickPos[s],n=Math.abs(t-a);n<e&&(e=n,i=this.categories[s])}return i}valueToPercent(t){const e=F(t),i=this.tickLabels.findIndex((t=>t===e));return-1!==i?this.tickPos[i]/this.axisLength:0}valueToPos(t){return this.valueToPercent(t)*this.axisLength}calculate(){const t=this.tickLabels.length;let e=0;this.tickSpacing=this.axisLength/(this.dataOnEdge?t-1:t),this.tickPos=[];for(let i=0;i<t;i++)[0,t].includes(i)?e+=this.dataOnEdge?0:this.tickSpacing/2:e+=this.tickSpacing,this.tickPos.push(e)}}class T extends Error{constructor(t){super(`[Hermes] ${t instanceof Error?t.message:k(t)?t:"Critical error encountered!"}`)}}class R extends C{constructor(t,e,i,s,a,n={}){super(t,e,i,n),this.direction=t,this.finiteMin=e,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.config=n,this.actualMax=a,this.actualMin=s}percentToValue(t){if(0===t)return this.reverse?this.actualMax:this.actualMin;if(1===t)return this.reverse?this.actualMin:this.actualMax;const e=this.dataOnEdge?this.minValue:this.min,i=this.dataOnEdge?this.maxValue:this.max;return(this.reverse?1-t:t)*(i-e)+e}posToValue(t){return this.percentToValue(t/this.axisLength)}valueToPercent(t){if(!b(t))return Number.NaN;if(t===this.actualMax)return this.reverse?0:1;if(t===this.actualMin)return this.reverse?1:0;const e=this.dataOnEdge?this.minValue:this.min,i=(t-e)/((this.dataOnEdge?this.maxValue:this.max)-e);return this.reverse?1-i:i}valueToPos(t){return this.valueToPercent(t)*this.axisLength}calculate(){this.range=this.niceNum(this.maxValue-this.minValue,!1),this.tickSpacing=this.niceNum(this.range/this.maxTicks,!0),this.min=Math.floor(this.minValue/this.tickSpacing)*this.tickSpacing,this.max=Math.ceil(this.maxValue/this.tickSpacing)*this.tickSpacing;const t=Math.round((this.max-this.min)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let e=0;e<=t;e++){let i=e*this.tickSpacing+this.min;this.dataOnEdge&&0===e&&(i=this.minValue),this.dataOnEdge&&e===t&&(i=this.maxValue),this.ticks.push(i);let s=P(i);this.dataOnEdge&&[0,t].includes(e)&&(s=`*${s}`),this.tickLabels.push(s)}this.tickPos=this.ticks.map((t=>this.valueToPos(t)))}}const _=t=>e=>Math.log(e)/Math.log(t);class V extends C{constructor(t,e,i,s,a,n=10,l={}){super(t,e,i,l),this.direction=t,this.finiteMin=e,this.finiteMax=i,this.actualMin=s,this.actualMax=a,this.logBase=n,this.maxExp=Number.NaN,this.maxExpExact=Number.NaN,this.minExp=Number.NaN,this.minExpExact=Number.NaN,this.log=_(n),this.logBase=n,this.actualMax=a,this.actualMin=s}setLogBase(t=10){this.logBase=t,this.calculate()}percentToValue(t){if(0===t)return this.reverse?this.actualMax:this.actualMin;if(1===t)return this.reverse?this.actualMin:this.actualMax;const e=this.dataOnEdge?this.minExpExact:this.minExp,i=(this.reverse?1-t:t)*this.rangeExp()+e;return this.logBase**i}posToValue(t){return this.percentToValue(t/this.axisLength)}valueToPercent(t){if(!b(t))return 0;const e=this.log(t),i=this.dataOnEdge?this.minExpExact:this.minExp,s=(e-i)/((this.dataOnEdge?this.maxExpExact:this.maxExp)-i);return this.reverse?1-s:s}valueToPos(t){return this.valueToPercent(t)*this.axisLength}rangeExp(){return this.dataOnEdge?this.maxExpExact-this.minExpExact:this.maxExp-this.minExp}calculate(){this.log=_(this.logBase),this.minExpExact=this.log(this.minValue),this.maxExpExact=this.log(this.maxValue),this.minExp=Math.floor(this.minExpExact),this.maxExp=Math.ceil(this.maxExpExact),this.range=this.logBase**this.maxExp-this.logBase**this.minExp,this.tickSpacing=1;const t=Math.round((this.maxExp-this.minExp)/this.tickSpacing);this.ticks=[],this.tickLabels=[];for(let e=0;e<=t;e++){const i=e*this.tickSpacing+this.minExp;let s=this.logBase**i;this.dataOnEdge&&0===e&&(s=this.logBase**this.minExpExact),this.dataOnEdge&&e===t&&(s=this.logBase**this.maxExpExact),this.ticks.push(s);let a=P(s);this.dataOnEdge&&[0,t].includes(e)&&(a=`*${a}`),this.tickLabels.push(a)}this.tickPos=this.ticks.map((t=>this.valueToPos(t)))}}const H=(t,e)=>t.x*e.x+t.y*e.y,$=(t,e,i,s)=>{const a={x:s.x-e.x,y:s.y-e.y},n={x:i.x-e.x,y:i.y-e.y},l={x:t.x-e.x,y:t.y-e.y},o=H(a,a),r=H(a,n),h=H(a,l),c=H(n,n),d=H(n,l),u=1/(o*c-r*r),f=(c*h-r*d)*u,p=(o*d-r*h)*u;return f>=0&&p>=0&&f+p<1},W=(t,e,i={})=>{if(t.save(),i.fillStyle){t.fillStyle=i.fillStyle,t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let i=1;i<e.length;i++)t.lineTo(e[i].x,e[i].y);t.closePath(),t.fill()}if(i.strokeStyle){t.lineCap=i.lineCap||u,t.lineDashOffset=i.lineDashOffset||0,t.lineJoin=i.lineJoin||f,t.lineWidth=i.lineWidth||1,t.miterLimit=i.miterLimit||p,t.strokeStyle=i.strokeStyle,t.beginPath(),t.moveTo(e[0].x,e[0].y);for(let i=1;i<e.length;i++)t.lineTo(e[i].x,e[i].y);t.closePath(),t.stroke()}t.restore()},J=(t,e,i,s,a={})=>{var n;if(e.length<2)return;t.save(),t.lineCap=a.lineCap||u,t.lineDashOffset=a.lineDashOffset||0,t.lineJoin=a.lineJoin||f,t.lineWidth=a.lineWidth||1,t.miterLimit=a.miterLimit||p,t.strokeStyle=a.strokeStyle||y,t.beginPath(),t.moveTo(e[0].x,e[0].y);const o=null!==(n=s.options.bezierFactor)&&void 0!==n?n:.3;for(let a=1;a<e.length;a++){const[n,r]=[e[a].x,e[a].y];if(s.type===l.Straight)t.lineTo(n,r);else if(s.type===l.Bezier){const[s,l]=[e[a-1].x,e[a-1].y],[h,c]=[s+(i?(n-s)*o:0),l+(i?0:(r-l)*o)],[d,u]=[n-(i?(n-s)*o:0),r-(i?0:(r-l)*o)];t.bezierCurveTo(h,c,d,u,n,r)}}t.stroke(),t.restore()},j=(t,e,i,s,a,n={})=>{t.save(),t.lineCap=n.lineCap||u,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||f,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||p,t.strokeStyle=n.strokeStyle||y,t.beginPath(),t.setLineDash(n.lineDash||[]),t.moveTo(Z(e),Z(i)),t.lineTo(Z(s),Z(a)),t.stroke(),t.restore()},q=(t,e,i,s,a,n={})=>{t.save();const l=Z(e),o=Z(i),r=n.cornerRadius||0;n.fillStyle&&(t.fillStyle=n.fillStyle,0===r?t.fillRect(l,o,s,a):(U(t,l,o,s,a,r),t.fill())),n.strokeStyle&&(t.lineCap=n.lineCap||u,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||f,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||p,t.strokeStyle=n.strokeStyle,0===r?t.strokeRect(l,o,s,a):(U(t,l,o,s,a,r),t.stroke())),t.restore()},U=(t,e,i,s,a,n)=>{t.beginPath(),t.moveTo(e+n,i),t.lineTo(e+s-n,i),t.quadraticCurveTo(e+s,i,e+s,i+n),t.lineTo(e+s,i+a-n),t.quadraticCurveTo(e+s,i+a,e+s-n,i+a),t.lineTo(e+n,i+a),t.quadraticCurveTo(e,i+a,e,i+a-n),t.lineTo(e,i+n),t.quadraticCurveTo(e,i,e+n,i),t.closePath()},G=(t,e,i,s,a,n={})=>{const l=Q(a),o=l>Math.PI/2&&l<=3*Math.PI/2,r=-a-(o?Math.PI:0);t.save(),tt(t,n.font),t.direction=n.direction||"inherit",t.textAlign=n.textAlign||(o?"right":"left"),t.textBaseline=n.textBaseline||"middle",r%2*Math.PI!=0&&(t.translate(i,s),t.rotate(r),t.translate(-i,-s)),n.strokeStyle&&(t.lineCap=n.lineCap||u,t.lineDashOffset=n.lineDashOffset||0,t.lineJoin=n.lineJoin||f,t.lineWidth=n.lineWidth||1,t.miterLimit=n.miterLimit||p,t.strokeStyle=n.strokeStyle,t.strokeText(e,i,s)),n.fillStyle&&(t.fillStyle=n.fillStyle,t.fillText(e,i,s)),t.restore()},X=(t,e,i,s,a,n=0,l=0,o=0)=>{const r=t+n-o,h=e+l-o,c=t+i+n+o,d=e+s+l+o,u=[{x:r,y:h},{x:c,y:h},{x:c,y:d},{x:r,y:d}];if(null!=a){const i=Q(a);return u.map((s=>((t,e,i,s=0,a=0)=>{const n=t-s,l=e-a,o=Math.cos(i),r=Math.sin(i);return{x:o*n-r*l+s,y:r*n+o*l+a}})(s.x,s.y,-i,t,e)))}return u},Y=(t,e,i=d)=>{tt(t,i);const s=t.measureText(e),a=s.actualBoundingBoxLeft+s.actualBoundingBoxRight;return{h:s.actualBoundingBoxAscent+s.actualBoundingBoxDescent,w:a}},K=t=>{const e=devicePixelRatio<=1?1:2-.5**(devicePixelRatio-1);return Array.isArray(t)?2===t.length?[t[0]*e,t[1]*e,t[0]*e,t[1]*e]:t.map((t=>t*e)):new Array(4).fill(t*e)},Q=t=>(t+2*Math.PI)%(2*Math.PI),Z=t=>Math.round(t-.5)+.5,tt=(t,e=d)=>{const i=new RegExp(/(-?\d*\.?\d+)px/),s=e.match(i);if(2===(null==s?void 0:s.length)){const a=Math.round(parseFloat(s[1])*devicePixelRatio);t.font=e.replace(i,`${a}px`)}else t.font=e},et=(t,e)=>{const i=t.length;if(i<1)return"#000000";if(1===i)return t[0];const s=e*(i-1),a=Math.floor(s),n=Math.ceil(s),l=((t,e,i)=>{const s=Math.round((e.r-t.r)*i+t.r),a=Math.round((e.g-t.g)*i+t.g),n=Math.round((e.b-t.b)*i+t.b);if(null!=t.a&&null!=e.a)return{a:(e.a-t.a)*i+t.a,b:n,g:a,r:s};return{b:n,g:a,r:s}})(it(t[a]),it(t[n]),s-a);return(t=>null!=t.a?`rgba(${t.r}, ${t.g}, ${t.b}, ${t.a})`:`rgb(${t.r}, ${t.g}, ${t.b})`)(l)},it=t=>{if(/^#/.test(t))return(t=>{const e={b:0,g:0,r:0},i=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);return i&&i.length>3&&(e.r=parseInt(i[1],16),e.g=parseInt(i[2],16),e.b=parseInt(i[3],16)),e})(t);const e=/^rgba?\(\s*?(\d+)\s*?,\s*?(\d+)\s*?,\s*?(\d+)\s*?(,\s*?([\d.]+)\s*?)?\)$/i.exec(t);if(e&&e.length>3){const t={a:1,b:0,g:0,r:0};return t.r=parseInt(e[1]),t.g=parseInt(e[2]),t.b=parseInt(e[3]),e.length>5&&void 0!==e[5]&&(t.a=parseFloat(e[5])),t}return{a:1,b:0,g:0,r:0}},st=(t,e)=>{const i=e.getBoundingClientRect();return{x:(t.clientX-i.x)*devicePixelRatio,y:(t.clientY-i.y)*devicePixelRatio}},at=(t,e)=>{let i;return(...s)=>{null==i&&(i=setTimeout((()=>{t(...s),i=void 0}),e))}},nt=(e,i,s)=>{const a=i.shared.action,n=a.type===t.LabelMove&&a.dimIndex===e,l=i.dimension.bound||h,o=i.dimension.boundOffset||{x:0,y:0};return n?(c=o,{h:(r=l).h,w:r.w,x:r.x+c.x,y:r.y+c.y}):s;var r,c},lt=t=>isNaN(t.p0)&&isNaN(t.p1),ot=(t,e)=>{const i=I(x);return t.p0<e.p0?(i.p0=t.p0,i.percent0=t.percent0,i.value0=t.value0):(i.p0=e.p0,i.percent0=e.percent0,i.value0=e.value0),t.p1>e.p1?(i.p1=t.p1,i.percent1=t.percent1,i.value1=t.value1):(i.p1=e.p1,i.percent1=e.percent1,i.value1=e.value1),i.hasNaN=t.hasNaN||e.hasNaN,i.hasNegativeInfinity=t.hasNegativeInfinity||e.hasNegativeInfinity,i.hasPositiveInfinity=t.hasPositiveInfinity||e.hasPositiveInfinity,i},rt={accuracy:[.55,.99],dropout:[.2,.8],"global-batch-size":[5,30],"layer-free-decay":[.001,.1],"layer-split-factor":[1,16],"learning-rate":[1e-4,.1],"learning-rate-decay":[1e-6,.001],loss:[1.7,2.4],"metrics-base":[.5,.9],"n-filters":[8,64]},ht=[{dataOnEdge:!1,key:"dropout",label:"Dropout",type:i.Linear},{dataOnEdge:!1,key:"global-batch-size",label:"Global Batch Size",type:i.Linear},{categories:[4,8,16,32,64],dataOnEdge:!1,key:"layer-dense-size",label:"Layer Dense Size",type:i.Categorical},{dataOnEdge:!1,key:"layer-free-decay",label:"Layer Free Decay",logBase:10,type:i.Logarithmic},{categories:[!0,!1],dataOnEdge:!1,key:"layer-inverse",label:"Layer Inverse",type:i.Categorical},{dataOnEdge:!1,key:"learning-rate",label:"Learning Rate",logBase:10,type:i.Logarithmic},{dataOnEdge:!1,key:"learning-rate-decay",label:"Learning Rate Decay",logBase:10,type:i.Logarithmic},{dataOnEdge:!1,key:"layer-split-factor",label:"Layer Split Factor",logBase:2,type:i.Logarithmic},{dataOnEdge:!1,key:"metrics-base",label:"Metrics Base",type:i.Linear},{dataOnEdge:!1,key:"n-filters",label:"N Filters",type:i.Linear}],ct=[{dataOnEdge:!0,disableDrag:!0,key:"accuracy",label:"Accuracy",type:i.Linear},{dataOnEdge:!0,disableDrag:!0,key:"loss",label:"Loss",type:i.Logarithmic}];var dt=Object.freeze({__proto__:null,DEFAULT_DIMENSION_COUNT:10,dimensionRanges:rt,dimensionSamples:ht,metricDimensionSamples:ct,generateData:(t,e,s=!0,a={})=>t.reduce(((t,n)=>(t[n.key]=new Array(e).fill(null).map(((t,l)=>{if(n.type===i.Categorical){if(n.categories)return s?w(n.categories):E(n.categories,l)}else if(n.type===i.Linear){const t=rt[n.key];if(t)return s?z(t[1],t[0],a):D(t[1],t[0],e,l,a)}else if(n.type===i.Logarithmic){const t=rt[n.key];if(t&&n.logBase)return s?((t,e,i,s={})=>{const a=10===t?Math.log10:2===t?Math.log2:Math.log,n=a===Math.log?Math.log(t):1,l=a(e)/n,o=a(i)/n,r=z(l,o,s);return isNaN(r)||!isFinite(r)?r:t**r})(n.logBase,t[1],t[0],a):((t,e,i,s,a,n={})=>{const l=10===t?Math.log10:2===t?Math.log2:Math.log,o=l===Math.log?Math.log(t):1,r=l(e)/o,h=l(i)/o;return t**D(r,h,s,a,n)})(n.logBase,t[1],t[0],e,l)}return o})),t)),{}),generateDimensions:(t=10,e=!0)=>{const i=new Array(t-1).fill(null).map(((t,i)=>e?w(ht):E(ht,i))),s=e?w(ct):E(ct,0);return i.push(s),i}});class ut{constructor(t,e,i,s){this.config=g,this.data={},this.dataInfo={hasInfinity:!1,hasNaN:!1,seriesCount:0},this.dimensions=[],this.dimensionsOriginal=[],this.filters={},this.size={h:0,w:0},this.ix=I(v),this._=void 0;const a=(t=>k(t)?document.querySelector(t):t)(t);if(!a)throw new T("Target element selector did not match anything.");this.element=a;const n=this.element.getBoundingClientRect();if(0===n.width||0===n.height)throw new T("Target element width and height must both be greater than 0px.");const l=this.element.querySelectorAll("canvas");0===l.length?(this.canvas=document.createElement("canvas"),this.element.appendChild(this.canvas)):this.canvas=l[0];const o=this.canvas.getContext("2d");if(!o)throw new T("Unable to get context from target element.");this.ctx=o,e&&this.setDimensions(e,!1),i&&this.setConfig(i,!1),s&&this.setData(s,!1),(e||i||s)&&this.redraw(),this.listeners={dblclick:this.handleDoubleClick.bind(this),mousedown:this.handleMouseDown.bind(this),mousemove:0===this.config.interactions.throttleDelayMouseMove?this.handleMouseMove.bind(this):at((t=>this.handleMouseMove.bind(this)(t)),this.config.interactions.throttleDelayMouseMove),mouseup:this.handleMouseUp.bind(this)},this.enable()}static deepMerge(...t){return L(...t)}static getTester(){return dt}static validateData(t,e){const i={count:0,message:"",valid:!0},s=Object.keys(t),a=Object.values(t);for(let t=0;t<a.length;t++){const e=a[t];if(0===t)i.count=e.length;else if(e.length!==i.count)return i.message="The dimension data are not uniform in size.",i.valid=!1,i;if(-1!==e.findIndex((t=>null==t))){const a=null===e;return i.message=`Data for "${s[t]}" has ${a?"null":"undefined"}`,i.valid=!1,i}}const n=Object.keys(t);for(let t=0;t<e.length;t++){const s=e[t].key;if(!n.includes(s))return i.message=`Data for "${s} is missing.`,i.valid=!1,i}return i}static validateDimension(t){if(t.type===i.Categorical){if(!t.categories||0===t.categories.length)return{message:`Categorical dimension "${t.key}" is missing "categories".`,valid:!1}}else if(t.type===i.Logarithmic&&(null==t.logBase||0===t.logBase))return{message:`Logarithmic dimension "${t.key}" is missing "logBase".`,valid:!1};return{message:"",valid:!0}}static validateDimensions(t){if(0===t.length)return{message:"Need at least one dimension defined.",valid:!1};for(let e=0;e<t.length;e++){const{message:i,valid:s}=ut.validateDimension(t[e]);if(!s)return{message:i,valid:s}}return{message:"",valid:!0}}setConfig(t={},e=!0){this.config=L(g,t),this.addObservers(),e&&this.redraw()}setData(t,e=!0){const i=ut.validateData(t,this.dimensionsOriginal);if(!i.valid)throw new T(i.message);this.data=t,this.dataInfo=(t=>{const e=Object.keys(t),i={hasInfinity:!1,hasNaN:!1,seriesCount:0};for(const s of e){i.seriesCount=i.seriesCount||t[s].length;for(const e of t[s])isNaN(e)&&(i.hasNaN=!0),isNaN(e)||isFinite(e)||(i.hasInfinity=!0)}return i})(this.data),this.setDimensions(this.dimensionsOriginal,!1),e&&this.redraw()}setDimensions(t,e=!0){const a=ut.validateDimensions(t);if(!a.valid)throw new T(a.message);const n=this.config.direction===s.Horizontal?s.Vertical:s.Horizontal;this.dimensionsOriginal=t,this.dimensions=I(t).map((t=>{const e=t.key,s=this.data[e]||[],a={...t,labelTruncated:O(t.label,{size:this.config.style.dimension.label.truncate}),rangeActual:void 0,rangeFinite:void 0,scale:new R(n,0,100,0,100)};if(t.type===i.Linear||t.type===i.Logarithmic){const e=B(s,t.type);t.type===i.Linear?a.scale=new R(n,e.finite[0],e.finite[1],e.actual[0],e.actual[1],t):t.type===i.Logarithmic&&(a.scale=new V(n,e.finite[0],e.finite[1],e.actual[0],e.actual[1],t.logBase,t))}else t.type===i.Categorical&&(a.scale=new A(n,t.categories,t));return a})),e&&this.redraw()}setSize(t,e,i=!0){var s,a;const n={h:this.size.h,w:this.size.w},l=Math.round(t*devicePixelRatio),o=Math.round(e*devicePixelRatio);this.canvas.width=l,this.canvas.height=o,this.canvas.style.width=`${t}px`,this.canvas.style.height=`${e}px`,this.size={h:o,w:l},null===(a=(s=this.config.hooks).onResize)||void 0===a||a.call(s,I(this.size),n),i&&this.redraw()}disable(){this.removeListeners(),this.removeObservers(),this.ix=I(v),this.updateCursor(),this.redraw()}enable(){this.addListeners(),this.addObservers()}redraw(){0===this.size.w&&0===this.size.h||(this.calculate(),this.clear(),this.config.debug&&this.drawDebugOutline(),this.draw())}destroy(){this.removeListeners(),this.removeObservers(),this.canvas&&this.element.contains(this.canvas)&&this.element.removeChild(this.canvas)}addListeners(){this.element.addEventListener("dblclick",this.listeners.dblclick),this.element.addEventListener("mousedown",this.listeners.mousedown),window.addEventListener("mousemove",this.listeners.mousemove),window.addEventListener("mouseup",this.listeners.mouseup)}addObservers(){this.resizeObserver&&(this.resizeObserver.unobserve(this.element),this.resizeObserver=void 0),this.resizeObserver=new ResizeObserver(0===this.config.interactions.throttleDelayResize?this.handleResize.bind(this):at((t=>this.handleResize.bind(this)(t)),this.config.interactions.throttleDelayResize)),this.resizeObserver.observe(this.element)}removeListeners(){this.element.removeEventListener("dblclick",this.listeners.dblclick),this.element.removeEventListener("mousedown",this.listeners.mousedown),window.removeEventListener("mousemove",this.listeners.mousemove),window.removeEventListener("mouseup",this.listeners.mouseup)}removeObservers(){var t;null===(t=this.resizeObserver)||void 0===t||t.unobserve(this.element),this.resizeObserver=void 0}calculate(){this.calculateLayout(),this.calculateStyles()}calculateLayout(){var t,i;const a={dims:{list:new Array(this.dimensions.length).fill(void 0).map((()=>({axes:{},label:{},layout:{}}))),map:this.dimensions.reduce(((t,e,i)=>(t[e.key]=i,t)),{}),shared:{axes:{},label:{},layout:{}}},layout:{drawRect:{},padding:K(this.config.style.padding)}},{h:l,w:o}=this.size,r=a.layout,h=a.dims.shared.axes,c=a.dims.shared.label,d=a.dims.shared.layout,u=this.dimensions.length,f=this.config.direction===s.Horizontal,p=this.config.style.dimension.label,y=this.config.style.dimension.label.boundaryPadding,g=this.config.style.dimension.layout,x=this.config.style.axes.label,m=this.config.style.axes.axis,v=this.config.style.axes.axis.boundaryPadding,b=p.placement===n.Before,S=null!=p.angle,N=x.placement===n.Before;if(r.drawRect={h:l-r.padding[0]-r.padding[2],w:o-r.padding[1]-r.padding[3],x:r.padding[3],y:r.padding[0]},c.cos=S?Math.cos(null!==(t=p.angle)&&void 0!==t?t:0):void 0,c.sin=S?Math.sin(null!==(i=p.angle)&&void 0!==i?i:0):void 0,c.rad=p.angle||(f?void 0:b?-Math.PI:0),c.maxLengthCos=0,c.maxLengthSin=0,this.dimensions.forEach(((t,e)=>{const i=Y(this.ctx,t.labelTruncated,p.font),s=a.dims.list[e].label;s.w=i.w,s.h=i.h,s.lengthCos=S?i.w*c.cos:i.w,s.lengthSin=S?i.w*c.sin:i.h,Math.abs(s.lengthCos)>Math.abs(c.maxLengthCos)&&(c.maxLengthCos=s.lengthCos),Math.abs(s.lengthSin)>Math.abs(c.maxLengthSin)&&(c.maxLengthSin=s.lengthSin)})),h.start=h.stop=0,h.startInfinity=h.stopInfinity=h.startNaN=h.stopNaN=void 0,f){if(b){const t=Math.max(0,c.maxLengthSin);h.start=r.padding[0]+t+p.offset,h.stop=l-r.padding[2]}else{const t=S?Math.max(0,-c.maxLengthSin):c.maxLengthSin;h.start=r.padding[0],h.stop=l-r.padding[2]-t-p.offset}h.stopNaN=this.dataInfo.hasNaN?h.stop:void 0,h.startInfinity=h.start,h.stopInfinity=h.stop-(this.dataInfo.hasNaN?m.nanGap:0),h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}else{if(b){const t=S?Math.max(0,-c.maxLengthCos):c.maxLengthCos;h.start=r.padding[3]+t+p.offset,h.stop=o-r.padding[1]}else{const t=Math.max(0,c.maxLengthCos);h.start=r.padding[3],h.stop=o-r.padding[1]-t-p.offset}h.startNaN=this.dataInfo.hasNaN?h.start:void 0,h.startInfinity=h.start+(this.dataInfo.hasNaN?m.nanGap:0),h.stopInfinity=h.stop,h.startData=h.startInfinity+(this.dataInfo.hasInfinity?m.infOffset:0),h.stopData=h.stopInfinity-(this.dataInfo.hasInfinity?m.infOffset:0)}if(h.length=h.stop-h.start,h.labelFactor=N?-1:1,d.totalBoundSpace=0,this.dimensions.forEach(((t,e)=>{const i=a.dims.list[e].axes,s=a.dims.list[e].label,n=a.dims.list[e].layout,c=t.scale;i.tickLabels=[],i.tickPos=[],i.maxLength=0,c&&(c.setAxisLength(h.stopData-h.startData),i.tickLabels=c.tickLabels.slice(),i.tickPos=c.tickPos.slice(),c.tickLabels.forEach((t=>{const e=Y(this.ctx,t,x.font);i.maxLength=Math.max(e.w,i.maxLength)}))),S?(n.spaceBefore=f?s.lengthCos<0?-s.lengthCos:0:s.lengthSin>0?s.lengthSin:0,n.spaceAfter=f?s.lengthCos>0?s.lengthCos:0:s.lengthSin<0?-s.lengthSin:0):(n.spaceBefore=(f?s.lengthCos:s.lengthSin)/2,n.spaceAfter=(f?s.lengthCos:s.lengthSin)/2),N?n.spaceBefore=Math.max(n.spaceBefore,i.maxLength):n.spaceAfter=Math.max(n.spaceAfter,i.maxLength),f?(n.bound={h:l-r.padding[0]-r.padding[2],w:n.spaceBefore+n.spaceAfter,x:0,y:r.padding[0]},d.totalBoundSpace+=n.bound.w):(n.bound={h:n.spaceBefore+n.spaceAfter,w:o-r.padding[1]-r.padding[3],x:r.padding[3],y:0},d.totalBoundSpace+=n.bound.h)})),f){const t=r.drawRect.w-d.totalBoundSpace;d.gap=u>1?Math.max(t,0)/(u-1):0,d.offset=r.padding[3],d.space=u>1?r.drawRect.w/(u-1):0}else{const t=r.drawRect.h-d.totalBoundSpace;d.gap=u>1?Math.max(t,0)/(u-1):0,d.offset=r.padding[0],d.space=u>1?r.drawRect.h/(u-1):0}let k=d.offset;for(let t=0;t<a.dims.list.length;t++){const i=a.dims.list[t].label,s=a.dims.list[t].layout;f?(g===e.AxisEvenlySpaced?(s.bound.x=k-s.spaceBefore,k+=d.space):g===e.Equidistant&&(s.bound.x=k,k+=d.gap+s.bound.w),s.axisBoundaryStart={x:s.spaceBefore,y:h.start-r.padding[0]},s.axisBoundaryStop={x:s.spaceBefore,y:h.stop-r.padding[0]},s.axisInfinityStart={x:s.spaceBefore,y:h.startInfinity-r.padding[0]},s.axisInfinityStop={x:s.spaceBefore,y:h.stopInfinity-r.padding[0]},s.axisDataStart={x:s.spaceBefore,y:h.startData-r.padding[0]},s.axisDataStop={x:s.spaceBefore,y:h.stopData-r.padding[0]},s.labelPoint={x:s.spaceBefore,y:b?h.start-p.offset-r.padding[0]:h.stop+p.offset-r.padding[0]}):(g===e.AxisEvenlySpaced?(s.bound.y=k-s.spaceBefore,k+=d.space):g===e.Equidistant&&(s.bound.y=k,k+=d.gap+s.bound.h),s.axisBoundaryStart={x:h.start-r.padding[3],y:s.spaceBefore},s.axisBoundaryStop={x:h.stop-r.padding[3],y:s.spaceBefore},s.axisInfinityStart={x:h.startInfinity-r.padding[3],y:s.spaceBefore},s.axisInfinityStop={x:h.stopInfinity-r.padding[3],y:s.spaceBefore},s.axisDataStart={x:h.startData-r.padding[3],y:s.spaceBefore},s.axisDataStop={x:h.stopData-r.padding[3],y:s.spaceBefore},s.labelPoint={x:b?h.start-p.offset-r.padding[1]:h.stop+p.offset-r.padding[1],y:s.spaceBefore});const n=f?-i.w/2:0,l=f?b?-i.h:0:-i.h/2;s.labelBoundary=X(s.bound.x+s.labelPoint.x,s.bound.y+s.labelPoint.y,i.w,i.h,c.rad,S?0:n,S?-i.h/2:l,y),s.axisBoundary=[{x:s.bound.x+s.axisBoundaryStart.x-(f?v:0),y:s.bound.y+s.axisBoundaryStart.y-(f?0:v)},{x:s.bound.x+s.axisBoundaryStart.x+(f?v:0),y:s.bound.y+s.axisBoundaryStart.y+(f?0:v)},{x:s.bound.x+s.axisBoundaryStop.x+(f?v:0),y:s.bound.y+s.axisBoundaryStop.y+(f?0:v)},{x:s.bound.x+s.axisBoundaryStop.x-(f?v:0),y:s.bound.y+s.axisBoundaryStop.y-(f?0:v)}]}this._=a}calculateStyles(){if(!this._)return;this._.styles=this._.styles||[];const e=this.config.style,i=e.axes,s=e.dimension,n=this._.dims.list,l=this._.styles,o=this.ix.shared.action,r=this.ix.shared.focus,h=o.type!==t.None;for(let e=0;e<n.length;e++){const n=this.dimensions[e].key,c=this.filters[n]||[],d=o.type===t.LabelMove&&o.dimIndex===e,u=(null==r?void 0:r.type)===a.DimensionLabel&&(null==r?void 0:r.dimIndex)===e,f=(o.type===t.FilterCreate||o.type===t.FilterMove||o.type===t.FilterResizeAfter||o.type===t.FilterResizeBefore)&&o.dimIndex===e,p=((null==r?void 0:r.type)===a.DimensionAxis||(null==r?void 0:r.type)===a.Filter||(null==r?void 0:r.type)===a.FilterResize)&&(null==r?void 0:r.dimIndex)===e;l[e]=l[e]||{},l[e].label={...s.label,...d||!u||h?{}:s.labelHover,...d?s.labelActive:{}},l[e].axis={...i.axis,...f||!p||h?{}:i.axisHover,...f?i.axisActive:{}},l[e].tick={...i.tick,...f||!p||h?{}:i.tickHover,...f?i.tickActive:{}},l[e].tickLabel={...i.label,...f||!p||h?{}:i.labelHover,...f?i.labelActive:{}},l[e].filters=c.map(((t,s)=>{const n=((null==r?void 0:r.type)===a.Filter||(null==r?void 0:r.type)===a.FilterResize)&&(null==r?void 0:r.dimIndex)===e&&(null==r?void 0:r.filterIndex)===s,l=f||p&&!n,h=n&&void 0===o.filterIndex,c=o.dimIndex===e&&o.filterIndex===s;return{...i.filter,...l?i.filterAxisHover:{},...h?i.filterHover:{},...c?i.filterActive:{}}}))}}getFocusByPoint(t){if(!this._)return;const e=this._.dims.shared.axes,i=this.config.direction===s.Horizontal?"y":"x",n=this._.dims.shared.axes.length;for(let s=0;s<this._.dims.list.length;s++){const l=this.dimensions[s].key,o=this._.dims.list[s].layout,r=o.labelBoundary;if(($(t,r[0],r[1],r[2])||$(t,r[2],r[3],r[0]))&&!this.dimensions[s].disableDrag)return{dimIndex:s,type:a.DimensionLabel};const h=o.axisBoundary;if($(t,h[0],h[1],h[2])||$(t,h[2],h[3],h[0])){const r=this.filters[l]||[],h=o.bound[i]+o.axisBoundaryStart[i],c=(t[i]-h)/n,d=r.findIndex((t=>c>=t.p0&&c<=t.p1));let u=a.DimensionAxis;if(-1!==d){const t=3/e.length,i=r[d];u=c<=i.p0+t||c>=i.p1-t?a.FilterResize:a.Filter}return{dimIndex:s,filterIndex:d,type:u}}}}updateActiveLabel(){var e,i;if(!this._||this.ix.shared.action.type!==t.LabelMove)return;const a=this._.dims.list,n=this.ix,l=n.dimension,o=n.shared.action,r=this.config.direction===s.Horizontal,h=r?"x":"y";l.boundOffset={x:r?o.p1.x-o.p0.x:0,y:r?0:o.p1.y-o.p0.y};let c=-1;const d=l.axis+l.boundOffset[h];for(let t=0;t<a.length;t++){if(o.dimIndex===t||this.dimensions[t].disableDrag)continue;const e=a[t].layout,i=e.bound[h]+e.axisBoundaryStart[h],s=Math.abs(d-i)<30;if(o.dimIndex<t){if(d<i&&!s)break;c=t}if(o.dimIndex>t&&(d<i||s)){c=t;break}}if(-1!==c){const t=o.dimIndex,s=this.dimensions.splice(o.dimIndex,1);if(0===s.length)return;this.dimensions.splice(c,0,s[0]),o.dimIndex=c,null===(i=(e=this.config.hooks).onDimensionMove)||void 0===i||i.call(e,I(s[0]),c,t)}}setConfigFilters(t={}){if(this.calculate(),!this._)return;const e=this._.dims.map;Object.keys(t).forEach((t=>{this.filters[t]=this.config.filters[t].map((i=>this.processConfigFilter(i,e[t]))).filter((t=>null!=t))})),this.redraw()}setActiveFilter(e,i){if(!this._)return;const s=this.filters,a=this.ix,n=a.shared.action,l=a.filters,o=this._.dims.shared.axes,r=(s[e]||[]).findIndex((t=>i>=t.p0&&i<=t.p1));-1!==r?(l.active=s[e][r],l.active.startP0=l.active.p0,l.active.startP1=l.active.p1,n.filterIndex=r,i>=l.active.p0&&i<=l.active.p0+3/o.length?n.type=t.FilterResizeBefore:i>=l.active.p1-3/o.length&&i<=l.active.p1?n.type=t.FilterResizeAfter:n.type=t.FilterMove):(n.type=t.FilterCreate,l.active={...x,p0:i,p1:i},s[e]=s[e]||[],s[e].push(l.active),n.filterIndex=s[e].length-1)}updateActiveFilter(e){var i,a,n,l,o,r,h,c,d,u,f,p;if(!this._)return;const y=this._.dims.list,g=this._.dims.shared.axes,m=this.ix,v=m.filters,b=m.shared.action,S=this.filters,N=b.dimIndex,k=this.config.direction===s.Horizontal?"y":"x";if(!(b.type===t.FilterCreate||b.type===t.FilterMove||b.type===t.FilterResizeAfter||b.type===t.FilterResizeBefore)||!v.key)return;const L=this.dimensions[b.dimIndex].key,B=y[b.dimIndex].layout.bound,E=y[b.dimIndex].layout.axisBoundaryStart[k];if(b.type===t.FilterMove){const t=null!==(i=v.active.startP0)&&void 0!==i?i:0,e=null!==(a=v.active.startP1)&&void 0!==a?a:0,s=e-t,n=(b.p1[k]-b.p0[k])/g.length;v.active.p0=t+n,v.active.p1=e+n,v.active.p0<=0?(v.active.p0=0,v.active.p1=s):v.active.p1>=1&&(v.active.p0=1-s,v.active.p1=1)}else b.type===t.FilterResizeBefore?(v.active.p0=(b.p1[k]-B[k]-E)/g.length,v.active.p0=M(v.active.p0,[0,1])):(v.active.p1=(b.p1[k]-B[k]-E)/g.length,v.active.p1=M(v.active.p1,[0,1]));if(this.processFilter(v.active,N),"mouseup"===e.type){if(D=b.p0,w=b.p1,Math.sqrt((w.x-D.x)**2+(w.y-D.y)**2)<1){const t=S[v.key]||[],e=(v.active.p1-v.active.p0)/2+v.active.p0,i=t.findIndex((t=>e>=t.p0&&e<=t.p1));if(-1!==i){const e=I(t[i]);null===(l=(n=this.config.hooks).onFilterRemove)||void 0===l||l.call(n,{[L]:[e]}),t.splice(i,1)}}else{if(v.active.p1<v.active.p0){const t=v.active.p1;v.active.p1=v.active.p0,v.active.p0=t,this.processFilter(v.active,N)}const e={[L]:[I(v.active)]};switch(b.type){case t.FilterCreate:null===(r=(o=this.config.hooks).onFilterCreate)||void 0===r||r.call(o,e);break;case t.FilterMove:null===(c=(h=this.config.hooks).onFilterMove)||void 0===c||c.call(h,e);break;case t.FilterResizeAfter:case t.FilterResizeBefore:null===(u=(d=this.config.hooks).onFilterResize)||void 0===u||u.call(d,e)}}var D,w;v.active={...x},v.key=void 0,this.cleanUpFilters(),null===(p=null===(f=this.config.hooks)||void 0===f?void 0:f.onFilterChange)||void 0===p||p.call(f,I(this.filters))}}getDimensionLayoutInfo(t){if(!this._||!this.dataInfo)return;const e=this._.dims.list[t].layout,i=this.config.direction===s.Horizontal,a=e.axisBoundaryStop.x-e.axisBoundaryStart.x,n=e.axisBoundaryStop.y-e.axisBoundaryStart.y,l=i?(e.axisDataStart.y-e.axisBoundaryStart.y)/n:(e.axisDataStart.x-e.axisBoundaryStart.x)/a,o=i?(e.axisDataStop.y-e.axisBoundaryStart.y)/n:(e.axisDataStop.x-e.axisBoundaryStart.x)/a,r=o-l;return{hasInfinity:this.dataInfo.hasInfinity,hasNaN:this.dataInfo.hasNaN,isHorizontal:i,layout:e,pLength:r,pStart:l,pStop:o,xLength:a,yLength:n}}processFilter(t,e){const i=this.getDimensionLayoutInfo(e);if(!i)return;const s=Math.min(t.p0,t.p1),a=Math.max(t.p0,t.p1);if(i.hasInfinity)if(i.isHorizontal){const e=(i.layout.axisInfinityStop.y-i.layout.axisBoundaryStart.y)/i.yLength;t.hasPositiveInfinity=0===s,t.hasNegativeInfinity=s<=e&&a>=e}else{const e=(i.layout.axisInfinityStart.x-i.layout.axisBoundaryStart.x)/i.xLength;t.hasNegativeInfinity=s<=e&&a>=e,t.hasPositiveInfinity=1===a}i.hasNaN&&(t.hasNaN=i.isHorizontal&&1===a||!i.isHorizontal&&0===s),s<=i.pStart?t.percent0=0:s>i.pStart&&s<=i.pStop&&(t.percent0=(s-i.pStart)/i.pLength),a>=i.pStop?t.percent1=1:a>=i.pStart&&a<i.pStop&&(t.percent1=(a-i.pStart)/i.pLength),isNaN(t.percent0)||(t.value0=this.dimensions[e].scale.percentToValue(t.percent0)),isNaN(t.percent1)||(t.value1=this.dimensions[e].scale.percentToValue(t.percent1))}processConfigFilter(t,e){const i=this.getDimensionLayoutInfo(e);if(!i)return;const s={...x,...t};if(null!=t.p0&&null!=t.p1)this.processFilter(s,e);else{const a=[],n=[];if(null!=t.value0&&null!=t.value1&&(s.percent0=this.dimensions[e].scale.valueToPercent(t.value0),s.percent1=this.dimensions[e].scale.valueToPercent(t.value1),a.push(s.percent0*i.pLength+i.pStart),n.push(s.percent1*i.pLength+i.pStart)),i.hasInfinity)if(i.isHorizontal){if(t.hasPositiveInfinity)a.push(0),n.push(.01);else if(t.hasNegativeInfinity){const t=(i.layout.axisInfinityStop.y-i.layout.axisBoundaryStart.y)/i.yLength;a.push(t-m),n.push(t+m)}}else if(t.hasPositiveInfinity)a.push(.99),n.push(1);else if(t.hasNegativeInfinity){const t=(i.layout.axisInfinityStart.x-i.layout.axisBoundaryStart.x)/i.xLength;a.push(t-m),n.push(t+m)}i.hasNaN&&t.hasNaN&&(i.isHorizontal?(a.push(.99),n.push(1)):(a.push(0),n.push(.01))),s.p0=Math.min(...a),s.p1=Math.max(...n)}return s}cleanUpFilters(){Object.keys(this.filters).forEach((t=>{const e=this.filters[t]||[];for(let t=0;t<e.length;t++)if((a=e[t]).p0>=a.p1)e[t]={...x};else for(let a=t+1;a<e.length;a++)lt(e[t])||lt(e[a])||(i=e[t],s=e[a],i.p0<=s.p1&&s.p0<=i.p1&&(e[a]=ot(e[t],e[a]),e[t]={...x}));var i,s,a;this.filters[t]=e.filter((t=>!lt(t)))}))}updateCursor(){const e=this.ix,i=e.shared.action,n=e.shared.focus,l=this.config.direction===s.Horizontal;let o="default";i.type!==t.None?i.type===t.FilterMove||i.type===t.LabelMove?o="grabbing":i.type===t.FilterResizeAfter||i.type===t.FilterResizeBefore?o=l?"ns-resize":"ew-resize":i.type===t.FilterCreate&&(o="crosshair"):void 0!==n&&(n.type===a.DimensionLabel?o="grab":n.type===a.DimensionAxis?o="crosshair":n.type===a.Filter?o="grab":n.type===a.FilterResize&&(o=l?"ns-resize":"ew-resize")),this.canvas.style.cursor=o}clear(){const{h:t,w:e}=this.size;this.ctx.clearRect(0,0,e,t)}draw(){var t,e;if(!this._)return;const i=this._.dims.list,l=this._.dims.shared.axes,o=this._.dims.shared.label,r=this._.styles,h=this.ix,c=this.ix.shared.focus,d=this.filters,u=this.config.direction===s.Horizontal,f=this.config.style.axes,p=this.config.style.data,y=this.config.style.dimension,g=y.label.placement===n.Before,x=f.label.placement===n.Before;for(let s=0;s<this.dataInfo.seriesCount;s++){let a=p.default,n=!1,l=!1,o=!1,r=!1,c=!1;const f=this.dimensions.map(((t,e)=>{var f,y,g,x,m,v;const S=t.key,N=i[e].layout,k=nt(e,h,N.bound),I=this.data[S][s],M=b(I),L=M&&isNaN(I),B=M&&!L&&!isFinite(I),E=B&&I===-1/0,D=B&&I===1/0,w=L||B?0:null!==(y=null===(f=t.scale)||void 0===f?void 0:f.valueToPercent(I))&&void 0!==y?y:0;let z=k.x,P=k.y;if(L)z+=u?N.axisDataStart.x:N.axisBoundaryStart.x,P+=u?N.axisBoundaryStop.y:N.axisDataStart.y;else if(B){const t=E?u?N.axisInfinityStop.x:N.axisInfinityStart.x:u?N.axisInfinityStart.x:N.axisInfinityStop.x,e=D?u?N.axisInfinityStart.y:N.axisInfinityStop.y:u?N.axisInfinityStop.y:N.axisInfinityStart.y;z+=u?N.axisDataStart.x:t,P+=u?e:N.axisDataStart.y}else{const e=null!==(x=null===(g=t.scale)||void 0===g?void 0:g.valueToPos(I))&&void 0!==x?x:0;z+=N.axisDataStart.x+(u?0:e),P+=N.axisDataStart.y+(u?e:0)}if(S===p.targetDimensionKey){const e=null!==(v=null===(m=t.scale)||void 0===m?void 0:m.reverse)&&void 0!==v&&v,i=p.targetColorScale||[],s=et(e?i.slice().reverse():i,w);a.strokeStyle=s}if(d[S]&&0!==d[S].length){n=!0;let t=!1;for(let e=0;e<d[S].length;e++){const i=d[S][e];L&&i.hasNaN?(t=!0,l=!0):E&&i.hasNegativeInfinity?(t=!0,o=!0):D&&i.hasPositiveInfinity&&(t=!0,r=!0),!L&&!B&&!isNaN(i.percent0)&&!isNaN(i.percent1)&&w>=i.percent0&&w<=i.percent1&&(t=!0)}t||(c=!0)}else L?l=!0:E?o=!0:D&&(r=!0);return{x:z,y:P}}));(null===(t=p.series)||void 0===t?void 0:t[s])&&(a=null===(e=p.series)||void 0===e?void 0:e[s]),n&&c?a=p.filtered:l&&p.overrideNaN?a=p.overrideNaN:o&&p.overrideNegativeInfinity?a=p.overrideNegativeInfinity:r&&p.overridePositiveInfinity&&(a=p.overridePositiveInfinity),J(this.ctx,f,u,p.path,a)}const m=null==y.label.angle&&u,v={textAlign:m?"center":void 0,textBaseline:m?g?"bottom":"top":void 0};this.dimensions.forEach(((t,e)=>{var s;const a=nt(e,h,i[e].layout.bound),n=i[e].layout.labelPoint,l=a.x+n.x,c=a.y+n.y,d={...r[e].label,...v};G(this.ctx,t.labelTruncated,l,c,null!==(s=o.rad)&&void 0!==s?s:0,d)}));const S=null==f.label.angle&&u,N={textAlign:S?void 0:"center",textBaseline:S?void 0:x?"bottom":"top"};i.forEach(((t,e)=>{var i;const s=this.dimensions[e].key,n=nt(e,h,t.layout.bound),o=t.layout.axisBoundaryStart,p=t.layout.axisBoundaryStop,y=t.layout.axisInfinityStart,g=t.layout.axisInfinityStop,m=t.layout.axisDataStart,v=t.layout.axisDataStop,b=t.axes.tickLabels,S=t.axes.tickPos,k=x?-1:1,I={...r[e].tickLabel,...N},M=u?k*f.tick.length:0,L=u?0:k*f.tick.length,B=d[s]||[];if(j(this.ctx,n.x+m.x,n.y+m.y,n.x+v.x,n.y+v.y,r[e].axis),this.dataInfo.hasInfinity){j(this.ctx,n.x+y.x,n.y+y.y,n.x+m.x,n.y+m.y,{...r[e].axis,lineDash:f.axis.infLineDash}),j(this.ctx,n.x+v.x,n.y+v.y,n.x+g.x,n.y+g.y,{...r[e].axis,lineDash:f.axis.infLineDash,lineDashOffset:null!==(i=f.axis.infLineDash[0])&&void 0!==i?i:0});const t=n.x+y.x,s=n.y+y.y,a=t+M,l=s+L;j(this.ctx,t,s,a,l,r[e].tick);const o=n.x+g.x,h=n.y+g.y,c=o+M,d=h+L;j(this.ctx,o,h,c,d,r[e].tick);const p=u?a+k*f.label.offset:t,b=u?s:l+k*f.label.offset,S=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,N=u?"+Ꝏ":"-Ꝏ";G(this.ctx,N,p,b,S,I);const B=u?c+k*f.label.offset:o,E=u?h:d+k*f.label.offset,D=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,w=u?"-Ꝏ":"+Ꝏ";G(this.ctx,w,B,E,D,I)}if(this.dataInfo.hasNaN){const t=n.x+(u?p.x:o.x),i=n.y+(u?p.y:o.y),s=t+M,a=i+L;j(this.ctx,t,i,s,a,r[e].tick);const l=u?s+k*f.label.offset:t,h=u?i:a+k*f.label.offset,c=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0;G(this.ctx,"NaN",l,h,c,I)}for(let t=0;t<b.length;t++){let i=b[t];if("*"===i[0]){if((null==c?void 0:c.dimIndex)!==e||(null==c?void 0:c.type)!==a.DimensionAxis&&(null==c?void 0:c.type)!==a.Filter&&(null==c?void 0:c.type)!==a.FilterResize)continue;i=i.substring(1)}const s=u?0:S[t],l=u?S[t]:0,o=u?k*f.tick.length:0,h=u?0:k*f.tick.length,d=n.x+m.x+s,p=n.y+m.y+l,y=n.x+m.x+s+o,g=n.y+m.y+l+h;j(this.ctx,d,p,y,g,r[e].tick);const v=u?y+k*f.label.offset:d,I=u?p:g+k*f.label.offset,M=null!=f.label.angle?f.label.angle:u&&x?Math.PI:0,L={...r[e].tickLabel,...N};G(this.ctx,i,v,I,M,L)}B.forEach(((t,i)=>{const s=t.p0*l.length,a=t.p1*l.length,h=r[e].filters[i].width,c=h/2,d=n.x+o.x+(u?-c:s),f=n.y+o.y+(u?s:-c),p=u?h:a-s,y=u?a-s:h;q(this.ctx,d,f,p,y,r[e].filters[i])}))}))}drawDebugOutline(){if(!this._)return;const{h:t,w:e}=this.size,i=this._.layout,a=this._.dims.list,n=this._.dims.shared.layout,l=this.config.direction===s.Horizontal,o={strokeStyle:"#dddddd"};j(this.ctx,0,i.padding[0],e,i.padding[0],o),j(this.ctx,0,t-i.padding[2],e,t-i.padding[2],o),j(this.ctx,i.padding[3],0,i.padding[3],t,o),j(this.ctx,e-i.padding[1],0,e-i.padding[1],t,o);const r={strokeStyle:"#999999"},h={strokeStyle:"#ff0000"},c={strokeStyle:"#eeeeee"},d={strokeStyle:"#0099cc"},y={strokeStyle:"#ffcc00"};a.forEach(((t,e)=>{const s=t.layout.bound,a=t.layout.axisBoundary,o=t.layout.labelPoint,g=t.layout.labelBoundary;q(this.ctx,l?i.padding[3]+e*n.space:s.x,l?s.y:i.padding[0]+e*n.space,l?n.space:s.w,l?s.h:n.space,r),q(this.ctx,s.x,s.y,s.w,s.h,h),((t,e,i,s,a={})=>{t.save(),a.fillStyle&&(t.fillStyle=null==a?void 0:a.fillStyle,t.moveTo(e+s,i),t.beginPath(),t.arc(e,i,s,0,2*Math.PI),t.fill()),a.strokeStyle&&(t.lineCap=a.lineCap||u,t.lineDashOffset=a.lineDashOffset||0,t.lineJoin=a.lineJoin||f,t.lineWidth=a.lineWidth||1,t.miterLimit=a.miterLimit||p,t.strokeStyle=a.strokeStyle,t.moveTo(e+s,i),t.beginPath(),t.arc(e,i,s,0,2*Math.PI),t.stroke()),t.restore()})(this.ctx,s.x+o.x,s.y+o.y,3,d),W(this.ctx,g,y),W(this.ctx,a,c)}))}handleResize(t){const e=t.find((t=>t.target===this.element));if(!e)return;const{width:i,height:s}=e.contentRect;0===this.size.w&&0===this.size.h&&0!==i&&0!==s?(this.setSize(i,s),this.setConfigFilters(this.config.filters)):this.setSize(i,s)}handleDoubleClick(){var t,e;this.setDimensions(this.dimensionsOriginal,!1),this.filters={},this.ix=I(v),this.redraw(),null===(e=(t=this.config.hooks).onReset)||void 0===e||e.call(t)}handleMouseDown(e){var i,n;if(!this._)return;const l=this.ix.shared,o=this.ix.shared.action,r=this.ix.dimension,h=this.ix.filters,c=this._.dims.shared.axes,d=this.config.direction===s.Horizontal,u=d?"x":"y",f=d?"y":"x",p=st(e,this.element);if(o.p0=p,o.p1=p,o.filterIndex=-1,l.focus=this.getFocusByPoint(p),l.focus){const e=l.focus.dimIndex,s=this._.dims.list[e].layout,d=s.bound,p=s.axisBoundaryStart;if((null===(i=l.focus)||void 0===i?void 0:i.type)===a.DimensionLabel)o.type=t.LabelMove,o.dimIndex=e,r.axis=d[u]+p[u],r.bound=d;else if([a.DimensionAxis,a.Filter,a.FilterResize].includes(null===(n=l.focus)||void 0===n?void 0:n.type)){o.type=t.FilterCreate,o.dimIndex=e,h.key=this.dimensions[e].key;const i=(o.p0[f]-d[f]-p[f])/c.length;this.setActiveFilter(h.key,i),this.processFilter(h.active,e)}}this.updateCursor(),this.redraw()}handleMouseMove(t){if(!this._)return;const e=st(t,this.element);this.ix.shared.action.p1=e,this.ix.shared.focus=this.getFocusByPoint(e),this.updateActiveLabel(),this.updateActiveFilter(t),this.updateCursor(),this.redraw()}handleMouseUp(t){if(!this._)return;const e=st(t,this.element);this.ix.shared.action.p1=e,this.updateActiveLabel(),this.updateActiveFilter(t),this.ix=I(v),this.ix.shared.focus=this.getFocusByPoint(e),this.updateCursor(),this.redraw()}}export{t as ActionType,e as DimensionLayout,i as DimensionType,s as Direction,a as FocusType,n as LabelPlacement,l as PathType,ut as default};
